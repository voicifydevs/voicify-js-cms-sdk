/**
 * Voicify CMS API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: V1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

let defaultBasePath = 'https://localhost';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class AddFeatureToModuleRequest {
    'featureId'?: string;
    'name': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "featureId",
            "baseName": "featureId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AddFeatureToModuleRequest.attributeTypeMap;
    }
}

export class AddModuleToApplicationRequest {
    'moduleId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "moduleId",
            "baseName": "moduleId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AddModuleToApplicationRequest.attributeTypeMap;
    }
}

export class AlexaVendor {
    'id'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AlexaVendor.attributeTypeMap;
    }
}

export class AlexaVendorResponse {
    'vendors'?: Array<AlexaVendor>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "vendors",
            "baseName": "vendors",
            "type": "Array<AlexaVendor>"
        }    ];

    static getAttributeTypeMap() {
        return AlexaVendorResponse.attributeTypeMap;
    }
}

export class AnswerModel {
    'id'?: string;
    'content'?: string;
    'smallImage'?: MediaItemModel;
    'largeImage'?: MediaItemModel;
    'backgroundImage'?: MediaItemModel;
    'audio'?: MediaItemModel;
    'video'?: MediaItemModel;
    'mediaResponseContainer'?: MediaResponseContainerModel;
    'reprompt'?: RepromptModel;
    'followUp'?: FollowUpModel;
    'repromptId'?: string;
    'createdDate'?: Date;
    'modifiedDate'?: Date;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'followUpId'?: string;
    'questionAnswerId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "smallImage",
            "baseName": "smallImage",
            "type": "MediaItemModel"
        },
        {
            "name": "largeImage",
            "baseName": "largeImage",
            "type": "MediaItemModel"
        },
        {
            "name": "backgroundImage",
            "baseName": "backgroundImage",
            "type": "MediaItemModel"
        },
        {
            "name": "audio",
            "baseName": "audio",
            "type": "MediaItemModel"
        },
        {
            "name": "video",
            "baseName": "video",
            "type": "MediaItemModel"
        },
        {
            "name": "mediaResponseContainer",
            "baseName": "mediaResponseContainer",
            "type": "MediaResponseContainerModel"
        },
        {
            "name": "reprompt",
            "baseName": "reprompt",
            "type": "RepromptModel"
        },
        {
            "name": "followUp",
            "baseName": "followUp",
            "type": "FollowUpModel"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "questionAnswerId",
            "baseName": "questionAnswerId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AnswerModel.attributeTypeMap;
    }
}

export class ApiUserModel {
    'username'?: string;
    'password'?: string;
    'userId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "username",
            "baseName": "username",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApiUserModel.attributeTypeMap;
    }
}

export class ApplicationConversationCountModel {
    'applicationId'?: string;
    'conversationCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "conversationCount",
            "baseName": "conversationCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ApplicationConversationCountModel.attributeTypeMap;
    }
}

export class ApplicationFeatureExportModel {
    'welcomeMessages'?: Array<WelcomeMessageExportModel>;
    'exitMessages'?: Array<ExitMessageExportModel>;
    'fallbackMessages'?: Array<FallbackMessageExportModel>;
    'helpMessages'?: Array<HelpMessageExportModel>;
    'questionAnswers'?: Array<QuestionAnswerExportModel>;
    'eventItems'?: Array<EventItemExportModel>;
    'latestMessages'?: Array<LatestMessageExportModel>;
    'simpleChoices'?: Array<SimpleChoiceExportModel>;
    'recipes'?: Array<RecipeExportModel>;
    'numberRanges'?: Array<NumberRangeExportModel>;
    'customRequests'?: Array<CustomRequestExportModel>;
    'children'?: Array<ApplicationFeatureExportModel>;
    'id'?: string;
    'applicationModuleId'?: string;
    'applicationId'?: string;
    'feature'?: FeatureModel;
    'name'?: string;
    'priority'?: number;
    'parentId'?: string;
    'createdFromId'?: string;
    'applicationFeatureWebhooks'?: Array<ApplicationFeatureWebhookModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "welcomeMessages",
            "baseName": "welcomeMessages",
            "type": "Array<WelcomeMessageExportModel>"
        },
        {
            "name": "exitMessages",
            "baseName": "exitMessages",
            "type": "Array<ExitMessageExportModel>"
        },
        {
            "name": "fallbackMessages",
            "baseName": "fallbackMessages",
            "type": "Array<FallbackMessageExportModel>"
        },
        {
            "name": "helpMessages",
            "baseName": "helpMessages",
            "type": "Array<HelpMessageExportModel>"
        },
        {
            "name": "questionAnswers",
            "baseName": "questionAnswers",
            "type": "Array<QuestionAnswerExportModel>"
        },
        {
            "name": "eventItems",
            "baseName": "eventItems",
            "type": "Array<EventItemExportModel>"
        },
        {
            "name": "latestMessages",
            "baseName": "latestMessages",
            "type": "Array<LatestMessageExportModel>"
        },
        {
            "name": "simpleChoices",
            "baseName": "simpleChoices",
            "type": "Array<SimpleChoiceExportModel>"
        },
        {
            "name": "recipes",
            "baseName": "recipes",
            "type": "Array<RecipeExportModel>"
        },
        {
            "name": "numberRanges",
            "baseName": "numberRanges",
            "type": "Array<NumberRangeExportModel>"
        },
        {
            "name": "customRequests",
            "baseName": "customRequests",
            "type": "Array<CustomRequestExportModel>"
        },
        {
            "name": "children",
            "baseName": "children",
            "type": "Array<ApplicationFeatureExportModel>"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationModuleId",
            "baseName": "applicationModuleId",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "feature",
            "baseName": "feature",
            "type": "FeatureModel"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "parentId",
            "baseName": "parentId",
            "type": "string"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        },
        {
            "name": "applicationFeatureWebhooks",
            "baseName": "applicationFeatureWebhooks",
            "type": "Array<ApplicationFeatureWebhookModel>"
        }    ];

    static getAttributeTypeMap() {
        return ApplicationFeatureExportModel.attributeTypeMap;
    }
}

export class ApplicationFeatureModel {
    'id'?: string;
    'applicationModuleId'?: string;
    'applicationId'?: string;
    'feature'?: FeatureModel;
    'name'?: string;
    'priority'?: number;
    'parentId'?: string;
    'createdFromId'?: string;
    'applicationFeatureWebhooks'?: Array<ApplicationFeatureWebhookModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationModuleId",
            "baseName": "applicationModuleId",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "feature",
            "baseName": "feature",
            "type": "FeatureModel"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "parentId",
            "baseName": "parentId",
            "type": "string"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        },
        {
            "name": "applicationFeatureWebhooks",
            "baseName": "applicationFeatureWebhooks",
            "type": "Array<ApplicationFeatureWebhookModel>"
        }    ];

    static getAttributeTypeMap() {
        return ApplicationFeatureModel.attributeTypeMap;
    }
}

export class ApplicationFeatureRequestItem {
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApplicationFeatureRequestItem.attributeTypeMap;
    }
}

export class ApplicationFeatureWebhookModel {
    'id'?: string;
    'applicationFeatureId'?: string;
    'webhook'?: WebhookModel;
    'parameterValues'?: Array<WebhookParameterValueModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "webhook",
            "baseName": "webhook",
            "type": "WebhookModel"
        },
        {
            "name": "parameterValues",
            "baseName": "parameterValues",
            "type": "Array<WebhookParameterValueModel>"
        }    ];

    static getAttributeTypeMap() {
        return ApplicationFeatureWebhookModel.attributeTypeMap;
    }
}

export class ApplicationFulfillmentEndpoints {
    'applicationId'?: string;
    'alexaEndpoint'?: string;
    'alexaProxyEndpoint'?: string;
    'dialogFlowEndpoint'?: string;
    'botServiceEndpoint'?: string;
    'bixbyEndpoint'?: string;
    'customAssistantEndpoint'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "alexaEndpoint",
            "baseName": "alexaEndpoint",
            "type": "string"
        },
        {
            "name": "alexaProxyEndpoint",
            "baseName": "alexaProxyEndpoint",
            "type": "string"
        },
        {
            "name": "dialogFlowEndpoint",
            "baseName": "dialogFlowEndpoint",
            "type": "string"
        },
        {
            "name": "botServiceEndpoint",
            "baseName": "botServiceEndpoint",
            "type": "string"
        },
        {
            "name": "bixbyEndpoint",
            "baseName": "bixbyEndpoint",
            "type": "string"
        },
        {
            "name": "customAssistantEndpoint",
            "baseName": "customAssistantEndpoint",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApplicationFulfillmentEndpoints.attributeTypeMap;
    }
}

export class ApplicationInformationModel {
    'id'?: string;
    'applicationId'?: string;
    'languageId'?: string;
    'name'?: string;
    'shortDescription'?: string;
    'description'?: string;
    'keywords'?: string;
    'invocationPhrase'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "languageId",
            "baseName": "languageId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "shortDescription",
            "baseName": "shortDescription",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "keywords",
            "baseName": "keywords",
            "type": "string"
        },
        {
            "name": "invocationPhrase",
            "baseName": "invocationPhrase",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApplicationInformationModel.attributeTypeMap;
    }
}

export class ApplicationMemberModel {
    'id'?: string;
    'applicationId'?: string;
    'organizationMemberId'?: string;
    'isAdmin'?: boolean;
    'canEdit'?: boolean;
    'organizationMember'?: OrganizationMemberModel;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "organizationMemberId",
            "baseName": "organizationMemberId",
            "type": "string"
        },
        {
            "name": "isAdmin",
            "baseName": "isAdmin",
            "type": "boolean"
        },
        {
            "name": "canEdit",
            "baseName": "canEdit",
            "type": "boolean"
        },
        {
            "name": "organizationMember",
            "baseName": "organizationMember",
            "type": "OrganizationMemberModel"
        }    ];

    static getAttributeTypeMap() {
        return ApplicationMemberModel.attributeTypeMap;
    }
}

export class ApplicationMemberRoleModel {
    'id'?: string;
    'roleId'?: string;
    'userId'?: string;
    'isAdmin'?: boolean;
    'canEdit'?: boolean;
    'applicationId'?: string;
    'applicationName'?: string;
    'applicationImageUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "roleId",
            "baseName": "roleId",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "string"
        },
        {
            "name": "isAdmin",
            "baseName": "isAdmin",
            "type": "boolean"
        },
        {
            "name": "canEdit",
            "baseName": "canEdit",
            "type": "boolean"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationName",
            "baseName": "applicationName",
            "type": "string"
        },
        {
            "name": "applicationImageUrl",
            "baseName": "applicationImageUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApplicationMemberRoleModel.attributeTypeMap;
    }
}

export class ApplicationModel {
    'id'?: string;
    'name'?: string;
    'secret'?: string;
    'shortDescription'?: string;
    'description'?: string;
    'keywords'?: string;
    'invocationPhrase'?: string;
    'imageUrl'?: string;
    'shortCode'?: string;
    'imageItemId'?: string;
    'applicationInformationItems'?: Array<ApplicationInformationModel>;
    'languages'?: Array<LanguageModel>;
    'isDisabled'?: boolean;
    'alexaFallbackSensitivity'?: ApplicationModel.AlexaFallbackSensitivityEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "secret",
            "baseName": "secret",
            "type": "string"
        },
        {
            "name": "shortDescription",
            "baseName": "shortDescription",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "keywords",
            "baseName": "keywords",
            "type": "string"
        },
        {
            "name": "invocationPhrase",
            "baseName": "invocationPhrase",
            "type": "string"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "shortCode",
            "baseName": "shortCode",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "applicationInformationItems",
            "baseName": "applicationInformationItems",
            "type": "Array<ApplicationInformationModel>"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        },
        {
            "name": "isDisabled",
            "baseName": "isDisabled",
            "type": "boolean"
        },
        {
            "name": "alexaFallbackSensitivity",
            "baseName": "alexaFallbackSensitivity",
            "type": "ApplicationModel.AlexaFallbackSensitivityEnum"
        }    ];

    static getAttributeTypeMap() {
        return ApplicationModel.attributeTypeMap;
    }
}

export namespace ApplicationModel {
    export enum AlexaFallbackSensitivityEnum {
        LOW = <any> 'LOW',
        MEDIUM = <any> 'MEDIUM',
        HIGH = <any> 'HIGH'
    }
}
export class ApplicationWebhookModel {
    'id'?: string;
    'applicationId'?: string;
    'webhook'?: WebhookModel;
    'parameterValues'?: Array<WebhookParameterValueModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "webhook",
            "baseName": "webhook",
            "type": "WebhookModel"
        },
        {
            "name": "parameterValues",
            "baseName": "parameterValues",
            "type": "Array<WebhookParameterValueModel>"
        }    ];

    static getAttributeTypeMap() {
        return ApplicationWebhookModel.attributeTypeMap;
    }
}

export class ApplicationWithFeaturesModel {
    'id'?: string;
    'name'?: string;
    'secret'?: string;
    'imageUrl'?: string;
    'invocationPhrase'?: string;
    'description'?: string;
    'shortDescription'?: string;
    'keywords'?: string;
    'imageItemId'?: string;
    'defaultLanguageId'?: string;
    'applicationFeatures'?: Array<ApplicationFeatureModel>;
    'languages'?: Array<LanguageModel>;
    'applicationInformationItems'?: Array<ApplicationInformationModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "secret",
            "baseName": "secret",
            "type": "string"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "invocationPhrase",
            "baseName": "invocationPhrase",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "shortDescription",
            "baseName": "shortDescription",
            "type": "string"
        },
        {
            "name": "keywords",
            "baseName": "keywords",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "defaultLanguageId",
            "baseName": "defaultLanguageId",
            "type": "string"
        },
        {
            "name": "applicationFeatures",
            "baseName": "applicationFeatures",
            "type": "Array<ApplicationFeatureModel>"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        },
        {
            "name": "applicationInformationItems",
            "baseName": "applicationInformationItems",
            "type": "Array<ApplicationInformationModel>"
        }    ];

    static getAttributeTypeMap() {
        return ApplicationWithFeaturesModel.attributeTypeMap;
    }
}

export class ApplicationsByAmazonAccount {
    'platform'?: string;
    'applicationIds'?: Array<string>;
    'userName'?: string;
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "platform",
            "baseName": "platform",
            "type": "string"
        },
        {
            "name": "applicationIds",
            "baseName": "applicationIds",
            "type": "Array<string>"
        },
        {
            "name": "userName",
            "baseName": "userName",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApplicationsByAmazonAccount.attributeTypeMap;
    }
}

export class ApplicationsByGoogleAccount {
    'platform'?: string;
    'applicationIds'?: Array<string>;
    'userName'?: string;
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "platform",
            "baseName": "platform",
            "type": "string"
        },
        {
            "name": "applicationIds",
            "baseName": "applicationIds",
            "type": "Array<string>"
        },
        {
            "name": "userName",
            "baseName": "userName",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApplicationsByGoogleAccount.attributeTypeMap;
    }
}

export class ApplicationsByMicrosoftAccount {
    'platform'?: string;
    'applicationIds'?: Array<string>;
    'userName'?: string;
    'id'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "platform",
            "baseName": "platform",
            "type": "string"
        },
        {
            "name": "applicationIds",
            "baseName": "applicationIds",
            "type": "Array<string>"
        },
        {
            "name": "userName",
            "baseName": "userName",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ApplicationsByMicrosoftAccount.attributeTypeMap;
    }
}

export class AppliedApplicationTemplateFormModel {
    'id'?: string;
    'createdDate'?: Date;
    'modifiedDate'?: Date;
    'createdByUserId'?: string;
    'modifiedByUserId'?: string;
    'templateFormId'?: string;
    'appliedApplicationId'?: string;
    'lastSyncedDate'?: Date;
    'templateForm'?: TemplateFormWithConfigurationModel;
    'templateFormFieldValues'?: Array<TemplateFormFieldValueModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "createdByUserId",
            "baseName": "createdByUserId",
            "type": "string"
        },
        {
            "name": "modifiedByUserId",
            "baseName": "modifiedByUserId",
            "type": "string"
        },
        {
            "name": "templateFormId",
            "baseName": "templateFormId",
            "type": "string"
        },
        {
            "name": "appliedApplicationId",
            "baseName": "appliedApplicationId",
            "type": "string"
        },
        {
            "name": "lastSyncedDate",
            "baseName": "lastSyncedDate",
            "type": "Date"
        },
        {
            "name": "templateForm",
            "baseName": "templateForm",
            "type": "TemplateFormWithConfigurationModel"
        },
        {
            "name": "templateFormFieldValues",
            "baseName": "templateFormFieldValues",
            "type": "Array<TemplateFormFieldValueModel>"
        }    ];

    static getAttributeTypeMap() {
        return AppliedApplicationTemplateFormModel.attributeTypeMap;
    }
}

export class AuthenticationResponse {
    'user'?: UserModel;
    'accessToken'?: string;
    'refreshToken'?: string;
    'accessTokenExpirationDate'?: Date;
    'refreshTokenExpirationDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "user",
            "baseName": "user",
            "type": "UserModel"
        },
        {
            "name": "accessToken",
            "baseName": "accessToken",
            "type": "string"
        },
        {
            "name": "refreshToken",
            "baseName": "refreshToken",
            "type": "string"
        },
        {
            "name": "accessTokenExpirationDate",
            "baseName": "accessTokenExpirationDate",
            "type": "Date"
        },
        {
            "name": "refreshTokenExpirationDate",
            "baseName": "refreshTokenExpirationDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return AuthenticationResponse.attributeTypeMap;
    }
}

export class AzureBotServiceInformation {
    'registrationUrl'?: string;
    'microsoftAppId'?: string;
    'microsoftAppPassword'?: string;
    'id'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "registrationUrl",
            "baseName": "registrationUrl",
            "type": "string"
        },
        {
            "name": "microsoftAppId",
            "baseName": "microsoftAppId",
            "type": "string"
        },
        {
            "name": "microsoftAppPassword",
            "baseName": "microsoftAppPassword",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AzureBotServiceInformation.attributeTypeMap;
    }
}

export class AzureSubscriptionInformation {
    'id'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AzureSubscriptionInformation.attributeTypeMap;
    }
}

export class BasicDeviceTargetModel {
    'id'?: string;
    'assistant'?: string;
    'displayName'?: string;
    'supportsForegroundImages'?: boolean;
    'supportsRichAudio'?: boolean;
    'supportsSsml'?: boolean;
    'supportsVideo'?: boolean;
    'supportsBackgroundImages'?: boolean;
    'supportsDisplayTitle'?: boolean;
    'supportsDisplayText'?: boolean;
    'iconUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "assistant",
            "baseName": "assistant",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "supportsForegroundImages",
            "baseName": "supportsForegroundImages",
            "type": "boolean"
        },
        {
            "name": "supportsRichAudio",
            "baseName": "supportsRichAudio",
            "type": "boolean"
        },
        {
            "name": "supportsSsml",
            "baseName": "supportsSsml",
            "type": "boolean"
        },
        {
            "name": "supportsVideo",
            "baseName": "supportsVideo",
            "type": "boolean"
        },
        {
            "name": "supportsBackgroundImages",
            "baseName": "supportsBackgroundImages",
            "type": "boolean"
        },
        {
            "name": "supportsDisplayTitle",
            "baseName": "supportsDisplayTitle",
            "type": "boolean"
        },
        {
            "name": "supportsDisplayText",
            "baseName": "supportsDisplayText",
            "type": "boolean"
        },
        {
            "name": "iconUrl",
            "baseName": "iconUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BasicDeviceTargetModel.attributeTypeMap;
    }
}

export class BasicInvitationRequest {
    'email': string;
    'isAdmin': boolean;
    'isAddedToApplications'?: boolean;
    'applicationRoleId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "isAdmin",
            "baseName": "isAdmin",
            "type": "boolean"
        },
        {
            "name": "isAddedToApplications",
            "baseName": "isAddedToApplications",
            "type": "boolean"
        },
        {
            "name": "applicationRoleId",
            "baseName": "applicationRoleId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BasicInvitationRequest.attributeTypeMap;
    }
}

export class BulkContentRequest {
    'applicationId': string;
    'content'?: Array<ContentRequestItem>;
    'applicationFeatures'?: Array<ApplicationFeatureRequestItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "Array<ContentRequestItem>"
        },
        {
            "name": "applicationFeatures",
            "baseName": "applicationFeatures",
            "type": "Array<ApplicationFeatureRequestItem>"
        }    ];

    static getAttributeTypeMap() {
        return BulkContentRequest.attributeTypeMap;
    }
}

export class BulkQuestionAnswerUpdateRequest {
    'questions': Array<UpdateQuestionRequest>;
    'answers': Array<UpdateAnswerRequest>;
    'title': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "questions",
            "baseName": "questions",
            "type": "Array<UpdateQuestionRequest>"
        },
        {
            "name": "answers",
            "baseName": "answers",
            "type": "Array<UpdateAnswerRequest>"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return BulkQuestionAnswerUpdateRequest.attributeTypeMap;
    }
}

export class BulkQuestionAnswerUpdateStubRequest {
    'title': string;
    'questions'?: Array<UpdateQuestionRequest>;
    'answers'?: Array<UpdateAnswerRequest>;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "questions",
            "baseName": "questions",
            "type": "Array<UpdateQuestionRequest>"
        },
        {
            "name": "answers",
            "baseName": "answers",
            "type": "Array<UpdateAnswerRequest>"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return BulkQuestionAnswerUpdateStubRequest.attributeTypeMap;
    }
}

export class BulkUpdateCustomRequestRequest {
    'responses': Array<UpdateCustomRequestResponseRequest>;
    'applicationId': string;
    'title': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;
    'requestTypes'?: string;
    'requestNames'?: string;
    'platformFilter'?: string;
    'startDate'?: Date;
    'endDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<UpdateCustomRequestResponseRequest>"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        },
        {
            "name": "requestTypes",
            "baseName": "requestTypes",
            "type": "string"
        },
        {
            "name": "requestNames",
            "baseName": "requestNames",
            "type": "string"
        },
        {
            "name": "platformFilter",
            "baseName": "platformFilter",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return BulkUpdateCustomRequestRequest.attributeTypeMap;
    }
}

export class BulkUpdateCustomRequestStubRequest {
    'applicationId': string;
    'title': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'responses'?: Array<UpdateCustomRequestResponseRequest>;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;
    'requestTypes'?: string;
    'requestNames'?: string;
    'platformFilter'?: string;
    'startDate'?: Date;
    'endDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<UpdateCustomRequestResponseRequest>"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        },
        {
            "name": "requestTypes",
            "baseName": "requestTypes",
            "type": "string"
        },
        {
            "name": "requestNames",
            "baseName": "requestNames",
            "type": "string"
        },
        {
            "name": "platformFilter",
            "baseName": "platformFilter",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return BulkUpdateCustomRequestStubRequest.attributeTypeMap;
    }
}

export class BulkUpdateEventRequest {
    'eventName': string;
    'startDate': Date;
    'responses': Array<UpdateEventResponseRequest>;
    'title': string;
    'description'?: string;
    'locationName'?: string;
    'categoryNames'?: Array<string>;
    'ownerName'?: string;
    'address'?: string;
    'status'?: string;
    'endDate'?: Date;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<UpdateEventResponseRequest>"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "locationName",
            "baseName": "locationName",
            "type": "string"
        },
        {
            "name": "categoryNames",
            "baseName": "categoryNames",
            "type": "Array<string>"
        },
        {
            "name": "ownerName",
            "baseName": "ownerName",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return BulkUpdateEventRequest.attributeTypeMap;
    }
}

export class BulkUpdateEventStubRequest {
    'title': string;
    'eventName'?: string;
    'description'?: string;
    'locationName'?: string;
    'categoryNames'?: Array<string>;
    'ownerName'?: string;
    'address'?: string;
    'status'?: string;
    'startDate'?: Date;
    'endDate'?: Date;
    'responses'?: Array<UpdateEventResponseRequest>;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "locationName",
            "baseName": "locationName",
            "type": "string"
        },
        {
            "name": "categoryNames",
            "baseName": "categoryNames",
            "type": "Array<string>"
        },
        {
            "name": "ownerName",
            "baseName": "ownerName",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<UpdateEventResponseRequest>"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return BulkUpdateEventStubRequest.attributeTypeMap;
    }
}

export class BulkUpdateLatestMessageRequest {
    'startDate': Date;
    'category': string;
    'responses': Array<UpdateLatestMessageResponseRequest>;
    'applicationId': string;
    'endDate'?: Date;
    'title': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<UpdateLatestMessageResponseRequest>"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return BulkUpdateLatestMessageRequest.attributeTypeMap;
    }
}

export class BulkUpdateLatestMessageStubRequest {
    'applicationId': string;
    'startDate'?: Date;
    'endDate'?: Date;
    'category'?: string;
    'title': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'responses'?: Array<UpdateLatestMessageResponseRequest>;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<UpdateLatestMessageResponseRequest>"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return BulkUpdateLatestMessageStubRequest.attributeTypeMap;
    }
}

export class BulkUpdateNumberRangeRequest {
    'responses': Array<UpdateNumberRangeResponseRequest>;
    'applicationId': string;
    'minimumValue'?: number;
    'maximumValue'?: number;
    'title': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<UpdateNumberRangeResponseRequest>"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "minimumValue",
            "baseName": "minimumValue",
            "type": "number"
        },
        {
            "name": "maximumValue",
            "baseName": "maximumValue",
            "type": "number"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return BulkUpdateNumberRangeRequest.attributeTypeMap;
    }
}

export class BulkUpdateNumberRangeStubRequest {
    'applicationId': string;
    'minimumValue'?: number;
    'maximumValue'?: number;
    'title': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'responses'?: Array<UpdateNumberRangeResponseRequest>;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "minimumValue",
            "baseName": "minimumValue",
            "type": "number"
        },
        {
            "name": "maximumValue",
            "baseName": "maximumValue",
            "type": "number"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<UpdateNumberRangeResponseRequest>"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return BulkUpdateNumberRangeStubRequest.attributeTypeMap;
    }
}

export class BulkUpdateRecipeRequest {
    'recipeName': string;
    'steps': Array<UpdateStepRequest>;
    'ingredients': Array<UpdateIngredientRequest>;
    'title': string;
    'keywords'?: string;
    'description'?: string;
    'mealType'?: string;
    'servings'?: string;
    'totalTime'?: string;
    'calories'?: number;
    'videoItemId'?: string;
    'smallImageItemId'?: string;
    'largeImageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'content'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "recipeName",
            "baseName": "recipeName",
            "type": "string"
        },
        {
            "name": "steps",
            "baseName": "steps",
            "type": "Array<UpdateStepRequest>"
        },
        {
            "name": "ingredients",
            "baseName": "ingredients",
            "type": "Array<UpdateIngredientRequest>"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "keywords",
            "baseName": "keywords",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "mealType",
            "baseName": "mealType",
            "type": "string"
        },
        {
            "name": "servings",
            "baseName": "servings",
            "type": "string"
        },
        {
            "name": "totalTime",
            "baseName": "totalTime",
            "type": "string"
        },
        {
            "name": "calories",
            "baseName": "calories",
            "type": "number"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "smallImageItemId",
            "baseName": "smallImageItemId",
            "type": "string"
        },
        {
            "name": "largeImageItemId",
            "baseName": "largeImageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return BulkUpdateRecipeRequest.attributeTypeMap;
    }
}

export class BulkUpdateRecipeStubRequest {
    'title': string;
    'recipeName'?: string;
    'keywords'?: string;
    'description'?: string;
    'mealType'?: string;
    'servings'?: string;
    'totalTime'?: string;
    'calories'?: number;
    'videoItemId'?: string;
    'smallImageItemId'?: string;
    'largeImageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'content'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'steps'?: Array<UpdateStepRequest>;
    'ingredients'?: Array<UpdateIngredientRequest>;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "recipeName",
            "baseName": "recipeName",
            "type": "string"
        },
        {
            "name": "keywords",
            "baseName": "keywords",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "mealType",
            "baseName": "mealType",
            "type": "string"
        },
        {
            "name": "servings",
            "baseName": "servings",
            "type": "string"
        },
        {
            "name": "totalTime",
            "baseName": "totalTime",
            "type": "string"
        },
        {
            "name": "calories",
            "baseName": "calories",
            "type": "number"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "smallImageItemId",
            "baseName": "smallImageItemId",
            "type": "string"
        },
        {
            "name": "largeImageItemId",
            "baseName": "largeImageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "steps",
            "baseName": "steps",
            "type": "Array<UpdateStepRequest>"
        },
        {
            "name": "ingredients",
            "baseName": "ingredients",
            "type": "Array<UpdateIngredientRequest>"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return BulkUpdateRecipeStubRequest.attributeTypeMap;
    }
}

export class BulkUpdateSimpleChoiceRequest {
    'choiceType': BulkUpdateSimpleChoiceRequest.ChoiceTypeEnum;
    'title': string;
    'responses': Array<UpdateSimpleChoiceResponseRequest>;
    'applicationId': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "choiceType",
            "baseName": "choiceType",
            "type": "BulkUpdateSimpleChoiceRequest.ChoiceTypeEnum"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<UpdateSimpleChoiceResponseRequest>"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return BulkUpdateSimpleChoiceRequest.attributeTypeMap;
    }
}

export namespace BulkUpdateSimpleChoiceRequest {
    export enum ChoiceTypeEnum {
        Yes = <any> 'Yes',
        No = <any> 'No',
        Maybe = <any> 'Maybe'
    }
}
export class BulkUpdateSimpleChoiceStubRequest {
    'applicationId': string;
    'choiceType'?: BulkUpdateSimpleChoiceStubRequest.ChoiceTypeEnum;
    'title'?: string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'responses'?: Array<UpdateSimpleChoiceResponseRequest>;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "choiceType",
            "baseName": "choiceType",
            "type": "BulkUpdateSimpleChoiceStubRequest.ChoiceTypeEnum"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<UpdateSimpleChoiceResponseRequest>"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return BulkUpdateSimpleChoiceStubRequest.attributeTypeMap;
    }
}

export namespace BulkUpdateSimpleChoiceStubRequest {
    export enum ChoiceTypeEnum {
        Yes = <any> 'Yes',
        No = <any> 'No',
        Maybe = <any> 'Maybe'
    }
}
export class ChangePasswordRequest {
    'oldPassword': string;
    'newPassword': string;
    'newPasswordConfirmation': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "oldPassword",
            "baseName": "oldPassword",
            "type": "string"
        },
        {
            "name": "newPassword",
            "baseName": "newPassword",
            "type": "string"
        },
        {
            "name": "newPasswordConfirmation",
            "baseName": "newPasswordConfirmation",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ChangePasswordRequest.attributeTypeMap;
    }
}

export class ChildContentContainerModel {
    'id'?: string;
    'isLimitedToChildren'?: boolean;
    'applicationId'?: string;
    'welcomeMessages'?: Array<WelcomeMessageModel>;
    'helpMessages'?: Array<HelpMessageModel>;
    'fallbackMessages'?: Array<FallbackMessageModel>;
    'exitMessages'?: Array<ExitMessageModel>;
    'questionAnswers'?: Array<QuestionAnswerModel>;
    'latestMessages'?: Array<LatestMessageModel>;
    'eventItems'?: Array<EventItemModel>;
    'recipes'?: Array<RecipeModel>;
    'simpleChoices'?: Array<SimpleChoiceModel>;
    'numberRanges'?: Array<NumberRangeModel>;
    'customRequests'?: Array<CustomRequestModel>;
    'contentItems'?: Array<GenericContentModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "isLimitedToChildren",
            "baseName": "isLimitedToChildren",
            "type": "boolean"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "welcomeMessages",
            "baseName": "welcomeMessages",
            "type": "Array<WelcomeMessageModel>"
        },
        {
            "name": "helpMessages",
            "baseName": "helpMessages",
            "type": "Array<HelpMessageModel>"
        },
        {
            "name": "fallbackMessages",
            "baseName": "fallbackMessages",
            "type": "Array<FallbackMessageModel>"
        },
        {
            "name": "exitMessages",
            "baseName": "exitMessages",
            "type": "Array<ExitMessageModel>"
        },
        {
            "name": "questionAnswers",
            "baseName": "questionAnswers",
            "type": "Array<QuestionAnswerModel>"
        },
        {
            "name": "latestMessages",
            "baseName": "latestMessages",
            "type": "Array<LatestMessageModel>"
        },
        {
            "name": "eventItems",
            "baseName": "eventItems",
            "type": "Array<EventItemModel>"
        },
        {
            "name": "recipes",
            "baseName": "recipes",
            "type": "Array<RecipeModel>"
        },
        {
            "name": "simpleChoices",
            "baseName": "simpleChoices",
            "type": "Array<SimpleChoiceModel>"
        },
        {
            "name": "numberRanges",
            "baseName": "numberRanges",
            "type": "Array<NumberRangeModel>"
        },
        {
            "name": "customRequests",
            "baseName": "customRequests",
            "type": "Array<CustomRequestModel>"
        },
        {
            "name": "contentItems",
            "baseName": "contentItems",
            "type": "Array<GenericContentModel>"
        }    ];

    static getAttributeTypeMap() {
        return ChildContentContainerModel.attributeTypeMap;
    }
}

export class CompleteTemplateFormModel {
    'templateConfigurationId': string;
    'templateFormFieldValues'?: Array<TemplateFormFieldValueModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "templateConfigurationId",
            "baseName": "templateConfigurationId",
            "type": "string"
        },
        {
            "name": "templateFormFieldValues",
            "baseName": "templateFormFieldValues",
            "type": "Array<TemplateFormFieldValueModel>"
        }    ];

    static getAttributeTypeMap() {
        return CompleteTemplateFormModel.attributeTypeMap;
    }
}

export class ContentRequestItem {
    'id'?: string;
    'featureTypeId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "featureTypeId",
            "baseName": "featureTypeId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ContentRequestItem.attributeTypeMap;
    }
}

export class ConversationCountModel {
    'applicationFeatureId'?: string;
    'conversationCount'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "conversationCount",
            "baseName": "conversationCount",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return ConversationCountModel.attributeTypeMap;
    }
}

export class CreateAnswerRequest {
    'content': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateAnswerRequest.attributeTypeMap;
    }
}

export class CreateApplicationFeatureRequest {
    'name': string;
    'parentApplicationFeatureId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "parentApplicationFeatureId",
            "baseName": "parentApplicationFeatureId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateApplicationFeatureRequest.attributeTypeMap;
    }
}

export class CreateApplicationFromCompletedFormsRequest {
    'organizationId': string;
    'applicationInfo': NewApplicationRequest;
    'completeForms': Array<CompleteTemplateFormModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "applicationInfo",
            "baseName": "applicationInfo",
            "type": "NewApplicationRequest"
        },
        {
            "name": "completeForms",
            "baseName": "completeForms",
            "type": "Array<CompleteTemplateFormModel>"
        }    ];

    static getAttributeTypeMap() {
        return CreateApplicationFromCompletedFormsRequest.attributeTypeMap;
    }
}

export class CreateEventRequest {
    'eventName': string;
    'startDate': Date;
    'applicationId': string;
    'applicationFeatureId': string;
    'responses': Array<CreateEventResponseRequest>;
    'title': string;
    'description'?: string;
    'locationName'?: string;
    'categoryNames'?: Array<string>;
    'ownerName'?: string;
    'address'?: string;
    'status'?: string;
    'endDate'?: Date;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'mediaResponseContainerId'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<CreateEventResponseRequest>"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "locationName",
            "baseName": "locationName",
            "type": "string"
        },
        {
            "name": "categoryNames",
            "baseName": "categoryNames",
            "type": "Array<string>"
        },
        {
            "name": "ownerName",
            "baseName": "ownerName",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CreateEventRequest.attributeTypeMap;
    }
}

export class CreateEventResponseRequest {
    'content': string;
    'eventQueryType'?: CreateEventResponseRequest.EventQueryTypeEnum;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'mediaResponseContainerId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "eventQueryType",
            "baseName": "eventQueryType",
            "type": "CreateEventResponseRequest.EventQueryTypeEnum"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateEventResponseRequest.attributeTypeMap;
    }
}

export namespace CreateEventResponseRequest {
    export enum EventQueryTypeEnum {
        General = <any> 'General',
        Location = <any> 'Location',
        StartDate = <any> 'StartDate',
        Status = <any> 'Status'
    }
}
export class CreateEventStubRequest {
    'title': string;
    'eventName'?: string;
    'description'?: string;
    'locationName'?: string;
    'categoryNames'?: Array<string>;
    'ownerName'?: string;
    'address'?: string;
    'status'?: string;
    'startDate'?: Date;
    'endDate'?: Date;
    'applicationId': string;
    'applicationFeatureId': string;
    'responses'?: Array<CreateEventResponseRequest>;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'mediaResponseContainerId'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "locationName",
            "baseName": "locationName",
            "type": "string"
        },
        {
            "name": "categoryNames",
            "baseName": "categoryNames",
            "type": "Array<string>"
        },
        {
            "name": "ownerName",
            "baseName": "ownerName",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<CreateEventResponseRequest>"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CreateEventStubRequest.attributeTypeMap;
    }
}

export class CreateFollowUpHintRequest {
    'content': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateFollowUpHintRequest.attributeTypeMap;
    }
}

export class CreateFollowUpRequest {
    'content'?: string;
    'name'?: string;
    'followUpHints'?: Array<CreateFollowUpHintRequest>;
    'childContentContainer'?: UpdateChildContentContainerRequest;
    'fallbackMessageId'?: string;
    'helpMessageId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "followUpHints",
            "baseName": "followUpHints",
            "type": "Array<CreateFollowUpHintRequest>"
        },
        {
            "name": "childContentContainer",
            "baseName": "childContentContainer",
            "type": "UpdateChildContentContainerRequest"
        },
        {
            "name": "fallbackMessageId",
            "baseName": "fallbackMessageId",
            "type": "string"
        },
        {
            "name": "helpMessageId",
            "baseName": "helpMessageId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateFollowUpRequest.attributeTypeMap;
    }
}

export class CreateIngredientRequest {
    'content': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateIngredientRequest.attributeTypeMap;
    }
}

export class CreateNewPasswordRequest {
    'resetCode': string;
    'newPassword': string;
    'confirmNewPassword': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "resetCode",
            "baseName": "resetCode",
            "type": "string"
        },
        {
            "name": "newPassword",
            "baseName": "newPassword",
            "type": "string"
        },
        {
            "name": "confirmNewPassword",
            "baseName": "confirmNewPassword",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateNewPasswordRequest.attributeTypeMap;
    }
}

export class CreateQuestionRequest {
    'content': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateQuestionRequest.attributeTypeMap;
    }
}

export class CreateRecipeRequest {
    'recipeName': string;
    'steps': Array<CreateStepRequest>;
    'ingredients': Array<CreateIngredientRequest>;
    'title': string;
    'keywords'?: string;
    'description'?: string;
    'mealType'?: string;
    'servings'?: string;
    'totalTime'?: string;
    'calories'?: number;
    'videoItemId'?: string;
    'smallImageItemId'?: string;
    'largeImageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'content'?: string;
    'applicationId': string;
    'applicationFeatureId': string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "recipeName",
            "baseName": "recipeName",
            "type": "string"
        },
        {
            "name": "steps",
            "baseName": "steps",
            "type": "Array<CreateStepRequest>"
        },
        {
            "name": "ingredients",
            "baseName": "ingredients",
            "type": "Array<CreateIngredientRequest>"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "keywords",
            "baseName": "keywords",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "mealType",
            "baseName": "mealType",
            "type": "string"
        },
        {
            "name": "servings",
            "baseName": "servings",
            "type": "string"
        },
        {
            "name": "totalTime",
            "baseName": "totalTime",
            "type": "string"
        },
        {
            "name": "calories",
            "baseName": "calories",
            "type": "number"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "smallImageItemId",
            "baseName": "smallImageItemId",
            "type": "string"
        },
        {
            "name": "largeImageItemId",
            "baseName": "largeImageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CreateRecipeRequest.attributeTypeMap;
    }
}

export class CreateRecipeStubRequest {
    'title': string;
    'recipeName'?: string;
    'keywords'?: string;
    'description'?: string;
    'mealType'?: string;
    'servings'?: string;
    'totalTime'?: string;
    'calories'?: number;
    'videoItemId'?: string;
    'smallImageItemId'?: string;
    'largeImageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'content'?: string;
    'applicationId': string;
    'applicationFeatureId': string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'steps'?: Array<CreateStepRequest>;
    'ingredients'?: Array<CreateIngredientRequest>;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "recipeName",
            "baseName": "recipeName",
            "type": "string"
        },
        {
            "name": "keywords",
            "baseName": "keywords",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "mealType",
            "baseName": "mealType",
            "type": "string"
        },
        {
            "name": "servings",
            "baseName": "servings",
            "type": "string"
        },
        {
            "name": "totalTime",
            "baseName": "totalTime",
            "type": "string"
        },
        {
            "name": "calories",
            "baseName": "calories",
            "type": "number"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "smallImageItemId",
            "baseName": "smallImageItemId",
            "type": "string"
        },
        {
            "name": "largeImageItemId",
            "baseName": "largeImageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "steps",
            "baseName": "steps",
            "type": "Array<CreateStepRequest>"
        },
        {
            "name": "ingredients",
            "baseName": "ingredients",
            "type": "Array<CreateIngredientRequest>"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return CreateRecipeStubRequest.attributeTypeMap;
    }
}

export class CreateRepromptRequest {
    'content': string;
    'name'?: string;
    'includeFollowUp'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "includeFollowUp",
            "baseName": "includeFollowUp",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CreateRepromptRequest.attributeTypeMap;
    }
}

export class CreateStepRequest {
    'content': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CreateStepRequest.attributeTypeMap;
    }
}

export class CustomRequestExportModel {
    'applicationId'?: string;
    'applicationFeatureId'?: string;
    'title'?: string;
    'id'?: string;
    'isLive'?: boolean;
    'applicationModuleId'?: string;
    'startDate'?: Date;
    'endDate'?: Date;
    'responses'?: Array<CustomRequestResponseModel>;
    'customRequestWebhooks'?: Array<CustomRequestWebhookModel>;
    'hits'?: number;
    'modifiedDate'?: Date;
    'createdDate'?: Date;
    'requestTypes'?: string;
    'requestNames'?: string;
    'platformFilter'?: string;
    'requiresParent'?: boolean;
    'isComplete'?: boolean;
    'createdFromId'?: string;
    'languages'?: Array<LanguageModel>;
    'shouldNotSync'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        },
        {
            "name": "applicationModuleId",
            "baseName": "applicationModuleId",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<CustomRequestResponseModel>"
        },
        {
            "name": "customRequestWebhooks",
            "baseName": "customRequestWebhooks",
            "type": "Array<CustomRequestWebhookModel>"
        },
        {
            "name": "hits",
            "baseName": "hits",
            "type": "number"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "requestTypes",
            "baseName": "requestTypes",
            "type": "string"
        },
        {
            "name": "requestNames",
            "baseName": "requestNames",
            "type": "string"
        },
        {
            "name": "platformFilter",
            "baseName": "platformFilter",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "isComplete",
            "baseName": "isComplete",
            "type": "boolean"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        },
        {
            "name": "shouldNotSync",
            "baseName": "shouldNotSync",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CustomRequestExportModel.attributeTypeMap;
    }
}

export class CustomRequestModel {
    'applicationId'?: string;
    'applicationFeatureId'?: string;
    'title'?: string;
    'id'?: string;
    'isLive'?: boolean;
    'applicationModuleId'?: string;
    'startDate'?: Date;
    'endDate'?: Date;
    'responses'?: Array<CustomRequestResponseModel>;
    'customRequestWebhooks'?: Array<CustomRequestWebhookModel>;
    'hits'?: number;
    'modifiedDate'?: Date;
    'createdDate'?: Date;
    'requestTypes'?: string;
    'requestNames'?: string;
    'platformFilter'?: string;
    'requiresParent'?: boolean;
    'isComplete'?: boolean;
    'createdFromId'?: string;
    'languages'?: Array<LanguageModel>;
    'shouldNotSync'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        },
        {
            "name": "applicationModuleId",
            "baseName": "applicationModuleId",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<CustomRequestResponseModel>"
        },
        {
            "name": "customRequestWebhooks",
            "baseName": "customRequestWebhooks",
            "type": "Array<CustomRequestWebhookModel>"
        },
        {
            "name": "hits",
            "baseName": "hits",
            "type": "number"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "requestTypes",
            "baseName": "requestTypes",
            "type": "string"
        },
        {
            "name": "requestNames",
            "baseName": "requestNames",
            "type": "string"
        },
        {
            "name": "platformFilter",
            "baseName": "platformFilter",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "isComplete",
            "baseName": "isComplete",
            "type": "boolean"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        },
        {
            "name": "shouldNotSync",
            "baseName": "shouldNotSync",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return CustomRequestModel.attributeTypeMap;
    }
}

export class CustomRequestResponseModel {
    'id'?: string;
    'content'?: string;
    'customRequestId'?: string;
    'smallImage'?: MediaItemModel;
    'largeImage'?: MediaItemModel;
    'backgroundImage'?: MediaItemModel;
    'audio'?: MediaItemModel;
    'video'?: MediaItemModel;
    'reprompt'?: RepromptModel;
    'mediaResponseContainer'?: MediaResponseContainerModel;
    'followUp'?: FollowUpModel;
    'repromptId'?: string;
    'createdDate'?: Date;
    'modifiedDate'?: Date;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'followUpId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "customRequestId",
            "baseName": "customRequestId",
            "type": "string"
        },
        {
            "name": "smallImage",
            "baseName": "smallImage",
            "type": "MediaItemModel"
        },
        {
            "name": "largeImage",
            "baseName": "largeImage",
            "type": "MediaItemModel"
        },
        {
            "name": "backgroundImage",
            "baseName": "backgroundImage",
            "type": "MediaItemModel"
        },
        {
            "name": "audio",
            "baseName": "audio",
            "type": "MediaItemModel"
        },
        {
            "name": "video",
            "baseName": "video",
            "type": "MediaItemModel"
        },
        {
            "name": "reprompt",
            "baseName": "reprompt",
            "type": "RepromptModel"
        },
        {
            "name": "mediaResponseContainer",
            "baseName": "mediaResponseContainer",
            "type": "MediaResponseContainerModel"
        },
        {
            "name": "followUp",
            "baseName": "followUp",
            "type": "FollowUpModel"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CustomRequestResponseModel.attributeTypeMap;
    }
}

export class CustomRequestWebhookModel {
    'id'?: string;
    'customRequestId'?: string;
    'webhook'?: WebhookModel;
    'parameterValues'?: Array<WebhookParameterValueModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "customRequestId",
            "baseName": "customRequestId",
            "type": "string"
        },
        {
            "name": "webhook",
            "baseName": "webhook",
            "type": "WebhookModel"
        },
        {
            "name": "parameterValues",
            "baseName": "parameterValues",
            "type": "Array<WebhookParameterValueModel>"
        }    ];

    static getAttributeTypeMap() {
        return CustomRequestWebhookModel.attributeTypeMap;
    }
}

export class DeploymentLink {
    'userName'?: string;
    'tokenId'?: string;
    'linkedProjectId'?: string;
    'vendorId'?: string;
    'additionalProperties'?: any;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "userName",
            "baseName": "userName",
            "type": "string"
        },
        {
            "name": "tokenId",
            "baseName": "tokenId",
            "type": "string"
        },
        {
            "name": "linkedProjectId",
            "baseName": "linkedProjectId",
            "type": "string"
        },
        {
            "name": "vendorId",
            "baseName": "vendorId",
            "type": "string"
        },
        {
            "name": "additionalProperties",
            "baseName": "additionalProperties",
            "type": "any"
        }    ];

    static getAttributeTypeMap() {
        return DeploymentLink.attributeTypeMap;
    }
}

export class DeviceTargetModel {
    'id'?: string;
    'assistant'?: string;
    'displayName'?: string;
    'supportsForegroundImages'?: boolean;
    'supportsRichAudio'?: boolean;
    'supportsSsml'?: boolean;
    'supportsVideo'?: boolean;
    'supportsBackgroundImages'?: boolean;
    'supportsDisplayTitle'?: boolean;
    'supportsDisplayText'?: boolean;
    'iconUrl'?: string;
    'responseTemplates'?: Array<ResponseTemplateTypeModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "assistant",
            "baseName": "assistant",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "supportsForegroundImages",
            "baseName": "supportsForegroundImages",
            "type": "boolean"
        },
        {
            "name": "supportsRichAudio",
            "baseName": "supportsRichAudio",
            "type": "boolean"
        },
        {
            "name": "supportsSsml",
            "baseName": "supportsSsml",
            "type": "boolean"
        },
        {
            "name": "supportsVideo",
            "baseName": "supportsVideo",
            "type": "boolean"
        },
        {
            "name": "supportsBackgroundImages",
            "baseName": "supportsBackgroundImages",
            "type": "boolean"
        },
        {
            "name": "supportsDisplayTitle",
            "baseName": "supportsDisplayTitle",
            "type": "boolean"
        },
        {
            "name": "supportsDisplayText",
            "baseName": "supportsDisplayText",
            "type": "boolean"
        },
        {
            "name": "iconUrl",
            "baseName": "iconUrl",
            "type": "string"
        },
        {
            "name": "responseTemplates",
            "baseName": "responseTemplates",
            "type": "Array<ResponseTemplateTypeModel>"
        }    ];

    static getAttributeTypeMap() {
        return DeviceTargetModel.attributeTypeMap;
    }
}

export class DialogflowAgentInformation {
    'parent'?: string;
    'displayName'?: string;
    'defaultLanguageCode'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "parent",
            "baseName": "parent",
            "type": "string"
        },
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "defaultLanguageCode",
            "baseName": "defaultLanguageCode",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DialogflowAgentInformation.attributeTypeMap;
    }
}

export class DisabledIntent {
    'displayName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DisabledIntent.attributeTypeMap;
    }
}

export class EventCategoryModel {
    'id'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EventCategoryModel.attributeTypeMap;
    }
}

export class EventItemExportModel {
    'id'?: string;
    'applicationId'?: string;
    'applicationFeatureId'?: string;
    'title'?: string;
    'isLive'?: boolean;
    'applicationModuleId'?: string;
    'eventName'?: string;
    'description'?: string;
    'locationName'?: string;
    'ownerName'?: string;
    'address'?: string;
    'status'?: string;
    'eventStartDate'?: Date;
    'eventEndDate'?: Date;
    'categories'?: Array<EventCategoryModel>;
    'responses'?: Array<EventResponseModel>;
    'eventItemWebhooks'?: Array<EventItemWebhookModel>;
    'hits'?: number;
    'modifiedDate'?: Date;
    'createdDate'?: Date;
    'requiresParent'?: boolean;
    'isComplete'?: boolean;
    'languages'?: Array<LanguageModel>;
    'createdFromId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        },
        {
            "name": "applicationModuleId",
            "baseName": "applicationModuleId",
            "type": "string"
        },
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "locationName",
            "baseName": "locationName",
            "type": "string"
        },
        {
            "name": "ownerName",
            "baseName": "ownerName",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "eventStartDate",
            "baseName": "eventStartDate",
            "type": "Date"
        },
        {
            "name": "eventEndDate",
            "baseName": "eventEndDate",
            "type": "Date"
        },
        {
            "name": "categories",
            "baseName": "categories",
            "type": "Array<EventCategoryModel>"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<EventResponseModel>"
        },
        {
            "name": "eventItemWebhooks",
            "baseName": "eventItemWebhooks",
            "type": "Array<EventItemWebhookModel>"
        },
        {
            "name": "hits",
            "baseName": "hits",
            "type": "number"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "isComplete",
            "baseName": "isComplete",
            "type": "boolean"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EventItemExportModel.attributeTypeMap;
    }
}

export class EventItemModel {
    'id'?: string;
    'applicationId'?: string;
    'applicationFeatureId'?: string;
    'title'?: string;
    'isLive'?: boolean;
    'applicationModuleId'?: string;
    'eventName'?: string;
    'description'?: string;
    'locationName'?: string;
    'ownerName'?: string;
    'address'?: string;
    'status'?: string;
    'eventStartDate'?: Date;
    'eventEndDate'?: Date;
    'categories'?: Array<EventCategoryModel>;
    'responses'?: Array<EventResponseModel>;
    'eventItemWebhooks'?: Array<EventItemWebhookModel>;
    'hits'?: number;
    'modifiedDate'?: Date;
    'createdDate'?: Date;
    'requiresParent'?: boolean;
    'isComplete'?: boolean;
    'languages'?: Array<LanguageModel>;
    'createdFromId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        },
        {
            "name": "applicationModuleId",
            "baseName": "applicationModuleId",
            "type": "string"
        },
        {
            "name": "eventName",
            "baseName": "eventName",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "locationName",
            "baseName": "locationName",
            "type": "string"
        },
        {
            "name": "ownerName",
            "baseName": "ownerName",
            "type": "string"
        },
        {
            "name": "address",
            "baseName": "address",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "eventStartDate",
            "baseName": "eventStartDate",
            "type": "Date"
        },
        {
            "name": "eventEndDate",
            "baseName": "eventEndDate",
            "type": "Date"
        },
        {
            "name": "categories",
            "baseName": "categories",
            "type": "Array<EventCategoryModel>"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<EventResponseModel>"
        },
        {
            "name": "eventItemWebhooks",
            "baseName": "eventItemWebhooks",
            "type": "Array<EventItemWebhookModel>"
        },
        {
            "name": "hits",
            "baseName": "hits",
            "type": "number"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "isComplete",
            "baseName": "isComplete",
            "type": "boolean"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EventItemModel.attributeTypeMap;
    }
}

export class EventItemWebhookModel {
    'id'?: string;
    'eventItemId'?: string;
    'webhook'?: WebhookModel;
    'parameterValues'?: Array<WebhookParameterValueModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "eventItemId",
            "baseName": "eventItemId",
            "type": "string"
        },
        {
            "name": "webhook",
            "baseName": "webhook",
            "type": "WebhookModel"
        },
        {
            "name": "parameterValues",
            "baseName": "parameterValues",
            "type": "Array<WebhookParameterValueModel>"
        }    ];

    static getAttributeTypeMap() {
        return EventItemWebhookModel.attributeTypeMap;
    }
}

export class EventResponseModel {
    'id'?: string;
    'content'?: string;
    'eventQueryType'?: EventResponseModel.EventQueryTypeEnum;
    'eventId'?: string;
    'smallImage'?: MediaItemModel;
    'largeImage'?: MediaItemModel;
    'backgroundImage'?: MediaItemModel;
    'audio'?: MediaItemModel;
    'video'?: MediaItemModel;
    'reprompt'?: RepromptModel;
    'repromptId'?: string;
    'createdDate'?: Date;
    'modifiedDate'?: Date;
    'mediaResponseContainer'?: MediaResponseContainerModel;
    'followUp'?: FollowUpModel;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'followUpId'?: string;
    'applicationFeatureId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "eventQueryType",
            "baseName": "eventQueryType",
            "type": "EventResponseModel.EventQueryTypeEnum"
        },
        {
            "name": "eventId",
            "baseName": "eventId",
            "type": "string"
        },
        {
            "name": "smallImage",
            "baseName": "smallImage",
            "type": "MediaItemModel"
        },
        {
            "name": "largeImage",
            "baseName": "largeImage",
            "type": "MediaItemModel"
        },
        {
            "name": "backgroundImage",
            "baseName": "backgroundImage",
            "type": "MediaItemModel"
        },
        {
            "name": "audio",
            "baseName": "audio",
            "type": "MediaItemModel"
        },
        {
            "name": "video",
            "baseName": "video",
            "type": "MediaItemModel"
        },
        {
            "name": "reprompt",
            "baseName": "reprompt",
            "type": "RepromptModel"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "mediaResponseContainer",
            "baseName": "mediaResponseContainer",
            "type": "MediaResponseContainerModel"
        },
        {
            "name": "followUp",
            "baseName": "followUp",
            "type": "FollowUpModel"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return EventResponseModel.attributeTypeMap;
    }
}

export namespace EventResponseModel {
    export enum EventQueryTypeEnum {
        General = <any> 'General',
        Location = <any> 'Location',
        StartDate = <any> 'StartDate',
        Status = <any> 'Status'
    }
}
export class ExitMessageExportModel {
    'id'?: string;
    'applicationId'?: string;
    'applicationFeatureId'?: string;
    'title'?: string;
    'isLive'?: boolean;
    'startDate'?: Date;
    'endDate'?: Date;
    'content'?: string;
    'createdFromId'?: string;
    'smallImage'?: MediaItemModel;
    'largeImage'?: MediaItemModel;
    'backgroundImage'?: MediaItemModel;
    'audio'?: MediaItemModel;
    'video'?: MediaItemModel;
    'exitMessageWebhooks'?: Array<ExitMessageWebhookModel>;
    'mediaResponseContainer'?: MediaResponseContainerModel;
    'hits'?: number;
    'reprompt'?: RepromptModel;
    'repromptId'?: string;
    'createdDate'?: Date;
    'modifiedDate'?: Date;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'followUpId'?: string;
    'requiresParent'?: boolean;
    'isComplete'?: boolean;
    'languages'?: Array<LanguageModel>;
    'shouldNotSync'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        },
        {
            "name": "smallImage",
            "baseName": "smallImage",
            "type": "MediaItemModel"
        },
        {
            "name": "largeImage",
            "baseName": "largeImage",
            "type": "MediaItemModel"
        },
        {
            "name": "backgroundImage",
            "baseName": "backgroundImage",
            "type": "MediaItemModel"
        },
        {
            "name": "audio",
            "baseName": "audio",
            "type": "MediaItemModel"
        },
        {
            "name": "video",
            "baseName": "video",
            "type": "MediaItemModel"
        },
        {
            "name": "exitMessageWebhooks",
            "baseName": "exitMessageWebhooks",
            "type": "Array<ExitMessageWebhookModel>"
        },
        {
            "name": "mediaResponseContainer",
            "baseName": "mediaResponseContainer",
            "type": "MediaResponseContainerModel"
        },
        {
            "name": "hits",
            "baseName": "hits",
            "type": "number"
        },
        {
            "name": "reprompt",
            "baseName": "reprompt",
            "type": "RepromptModel"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "isComplete",
            "baseName": "isComplete",
            "type": "boolean"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        },
        {
            "name": "shouldNotSync",
            "baseName": "shouldNotSync",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ExitMessageExportModel.attributeTypeMap;
    }
}

export class ExitMessageModel {
    'id'?: string;
    'applicationId'?: string;
    'applicationFeatureId'?: string;
    'title'?: string;
    'isLive'?: boolean;
    'startDate'?: Date;
    'endDate'?: Date;
    'content'?: string;
    'createdFromId'?: string;
    'smallImage'?: MediaItemModel;
    'largeImage'?: MediaItemModel;
    'backgroundImage'?: MediaItemModel;
    'audio'?: MediaItemModel;
    'video'?: MediaItemModel;
    'exitMessageWebhooks'?: Array<ExitMessageWebhookModel>;
    'mediaResponseContainer'?: MediaResponseContainerModel;
    'hits'?: number;
    'reprompt'?: RepromptModel;
    'repromptId'?: string;
    'createdDate'?: Date;
    'modifiedDate'?: Date;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'followUpId'?: string;
    'requiresParent'?: boolean;
    'isComplete'?: boolean;
    'languages'?: Array<LanguageModel>;
    'shouldNotSync'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        },
        {
            "name": "smallImage",
            "baseName": "smallImage",
            "type": "MediaItemModel"
        },
        {
            "name": "largeImage",
            "baseName": "largeImage",
            "type": "MediaItemModel"
        },
        {
            "name": "backgroundImage",
            "baseName": "backgroundImage",
            "type": "MediaItemModel"
        },
        {
            "name": "audio",
            "baseName": "audio",
            "type": "MediaItemModel"
        },
        {
            "name": "video",
            "baseName": "video",
            "type": "MediaItemModel"
        },
        {
            "name": "exitMessageWebhooks",
            "baseName": "exitMessageWebhooks",
            "type": "Array<ExitMessageWebhookModel>"
        },
        {
            "name": "mediaResponseContainer",
            "baseName": "mediaResponseContainer",
            "type": "MediaResponseContainerModel"
        },
        {
            "name": "hits",
            "baseName": "hits",
            "type": "number"
        },
        {
            "name": "reprompt",
            "baseName": "reprompt",
            "type": "RepromptModel"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "isComplete",
            "baseName": "isComplete",
            "type": "boolean"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        },
        {
            "name": "shouldNotSync",
            "baseName": "shouldNotSync",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ExitMessageModel.attributeTypeMap;
    }
}

export class ExitMessageWebhookModel {
    'id'?: string;
    'exitMessageId'?: string;
    'webhook'?: WebhookModel;
    'parameterValues'?: Array<WebhookParameterValueModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "exitMessageId",
            "baseName": "exitMessageId",
            "type": "string"
        },
        {
            "name": "webhook",
            "baseName": "webhook",
            "type": "WebhookModel"
        },
        {
            "name": "parameterValues",
            "baseName": "parameterValues",
            "type": "Array<WebhookParameterValueModel>"
        }    ];

    static getAttributeTypeMap() {
        return ExitMessageWebhookModel.attributeTypeMap;
    }
}

export class ExportModel {
    'applicationFeatures'?: Array<ApplicationFeatureExportModel>;
    'sharedReferences'?: SharedReferencesExportModel;
    'welcomeMessages'?: Array<WelcomeMessageExportModel>;
    'exitMessages'?: Array<ExitMessageExportModel>;
    'fallbackMessages'?: Array<FallbackMessageExportModel>;
    'helpMessages'?: Array<HelpMessageExportModel>;
    'questionAnswers'?: Array<QuestionAnswerExportModel>;
    'eventItems'?: Array<EventItemExportModel>;
    'latestMessages'?: Array<LatestMessageExportModel>;
    'simpleChoices'?: Array<SimpleChoiceExportModel>;
    'recipes'?: Array<RecipeExportModel>;
    'numberRanges'?: Array<NumberRangeExportModel>;
    'customRequests'?: Array<CustomRequestExportModel>;
    'interactionModelUpdates'?: Array<InteractionModelUpdateWithReference>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applicationFeatures",
            "baseName": "applicationFeatures",
            "type": "Array<ApplicationFeatureExportModel>"
        },
        {
            "name": "sharedReferences",
            "baseName": "sharedReferences",
            "type": "SharedReferencesExportModel"
        },
        {
            "name": "welcomeMessages",
            "baseName": "welcomeMessages",
            "type": "Array<WelcomeMessageExportModel>"
        },
        {
            "name": "exitMessages",
            "baseName": "exitMessages",
            "type": "Array<ExitMessageExportModel>"
        },
        {
            "name": "fallbackMessages",
            "baseName": "fallbackMessages",
            "type": "Array<FallbackMessageExportModel>"
        },
        {
            "name": "helpMessages",
            "baseName": "helpMessages",
            "type": "Array<HelpMessageExportModel>"
        },
        {
            "name": "questionAnswers",
            "baseName": "questionAnswers",
            "type": "Array<QuestionAnswerExportModel>"
        },
        {
            "name": "eventItems",
            "baseName": "eventItems",
            "type": "Array<EventItemExportModel>"
        },
        {
            "name": "latestMessages",
            "baseName": "latestMessages",
            "type": "Array<LatestMessageExportModel>"
        },
        {
            "name": "simpleChoices",
            "baseName": "simpleChoices",
            "type": "Array<SimpleChoiceExportModel>"
        },
        {
            "name": "recipes",
            "baseName": "recipes",
            "type": "Array<RecipeExportModel>"
        },
        {
            "name": "numberRanges",
            "baseName": "numberRanges",
            "type": "Array<NumberRangeExportModel>"
        },
        {
            "name": "customRequests",
            "baseName": "customRequests",
            "type": "Array<CustomRequestExportModel>"
        },
        {
            "name": "interactionModelUpdates",
            "baseName": "interactionModelUpdates",
            "type": "Array<InteractionModelUpdateWithReference>"
        }    ];

    static getAttributeTypeMap() {
        return ExportModel.attributeTypeMap;
    }
}

export class FallbackMessageCategoryModel {
    'id'?: string;
    'featureTypeId'?: string;
    'name'?: string;
    'featureType'?: FeatureTypeModel;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "featureTypeId",
            "baseName": "featureTypeId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "featureType",
            "baseName": "featureType",
            "type": "FeatureTypeModel"
        }    ];

    static getAttributeTypeMap() {
        return FallbackMessageCategoryModel.attributeTypeMap;
    }
}

export class FallbackMessageExportModel {
    'id'?: string;
    'applicationId'?: string;
    'applicationFeatureId'?: string;
    'title'?: string;
    'isLive'?: boolean;
    'startDate'?: Date;
    'endDate'?: Date;
    'content'?: string;
    'smallImage'?: MediaItemModel;
    'largeImage'?: MediaItemModel;
    'backgroundImage'?: MediaItemModel;
    'audio'?: MediaItemModel;
    'video'?: MediaItemModel;
    'hits'?: number;
    'category'?: FallbackMessageCategoryModel;
    'reprompt'?: RepromptModel;
    'repromptId'?: string;
    'fallbackMessageWebhooks'?: Array<FallbackMessageWebhookModel>;
    'createdDate'?: Date;
    'modifiedDate'?: Date;
    'mediaResponseContainerId'?: string;
    'createdFromId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'followUpId'?: string;
    'followUp'?: FollowUpModel;
    'mediaResponseContainer'?: MediaResponseContainerModel;
    'requiresParent'?: boolean;
    'isComplete'?: boolean;
    'languages'?: Array<LanguageModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "smallImage",
            "baseName": "smallImage",
            "type": "MediaItemModel"
        },
        {
            "name": "largeImage",
            "baseName": "largeImage",
            "type": "MediaItemModel"
        },
        {
            "name": "backgroundImage",
            "baseName": "backgroundImage",
            "type": "MediaItemModel"
        },
        {
            "name": "audio",
            "baseName": "audio",
            "type": "MediaItemModel"
        },
        {
            "name": "video",
            "baseName": "video",
            "type": "MediaItemModel"
        },
        {
            "name": "hits",
            "baseName": "hits",
            "type": "number"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "FallbackMessageCategoryModel"
        },
        {
            "name": "reprompt",
            "baseName": "reprompt",
            "type": "RepromptModel"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "fallbackMessageWebhooks",
            "baseName": "fallbackMessageWebhooks",
            "type": "Array<FallbackMessageWebhookModel>"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "followUp",
            "baseName": "followUp",
            "type": "FollowUpModel"
        },
        {
            "name": "mediaResponseContainer",
            "baseName": "mediaResponseContainer",
            "type": "MediaResponseContainerModel"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "isComplete",
            "baseName": "isComplete",
            "type": "boolean"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        }    ];

    static getAttributeTypeMap() {
        return FallbackMessageExportModel.attributeTypeMap;
    }
}

export class FallbackMessageModel {
    'id'?: string;
    'applicationId'?: string;
    'applicationFeatureId'?: string;
    'title'?: string;
    'isLive'?: boolean;
    'startDate'?: Date;
    'endDate'?: Date;
    'content'?: string;
    'smallImage'?: MediaItemModel;
    'largeImage'?: MediaItemModel;
    'backgroundImage'?: MediaItemModel;
    'audio'?: MediaItemModel;
    'video'?: MediaItemModel;
    'hits'?: number;
    'category'?: FallbackMessageCategoryModel;
    'reprompt'?: RepromptModel;
    'repromptId'?: string;
    'fallbackMessageWebhooks'?: Array<FallbackMessageWebhookModel>;
    'createdDate'?: Date;
    'modifiedDate'?: Date;
    'mediaResponseContainerId'?: string;
    'createdFromId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'followUpId'?: string;
    'followUp'?: FollowUpModel;
    'mediaResponseContainer'?: MediaResponseContainerModel;
    'requiresParent'?: boolean;
    'isComplete'?: boolean;
    'languages'?: Array<LanguageModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "smallImage",
            "baseName": "smallImage",
            "type": "MediaItemModel"
        },
        {
            "name": "largeImage",
            "baseName": "largeImage",
            "type": "MediaItemModel"
        },
        {
            "name": "backgroundImage",
            "baseName": "backgroundImage",
            "type": "MediaItemModel"
        },
        {
            "name": "audio",
            "baseName": "audio",
            "type": "MediaItemModel"
        },
        {
            "name": "video",
            "baseName": "video",
            "type": "MediaItemModel"
        },
        {
            "name": "hits",
            "baseName": "hits",
            "type": "number"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "FallbackMessageCategoryModel"
        },
        {
            "name": "reprompt",
            "baseName": "reprompt",
            "type": "RepromptModel"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "fallbackMessageWebhooks",
            "baseName": "fallbackMessageWebhooks",
            "type": "Array<FallbackMessageWebhookModel>"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "followUp",
            "baseName": "followUp",
            "type": "FollowUpModel"
        },
        {
            "name": "mediaResponseContainer",
            "baseName": "mediaResponseContainer",
            "type": "MediaResponseContainerModel"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "isComplete",
            "baseName": "isComplete",
            "type": "boolean"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        }    ];

    static getAttributeTypeMap() {
        return FallbackMessageModel.attributeTypeMap;
    }
}

export class FallbackMessageWebhookModel {
    'id'?: string;
    'fallbackMessageId'?: string;
    'webhook'?: WebhookModel;
    'parameterValues'?: Array<WebhookParameterValueModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "fallbackMessageId",
            "baseName": "fallbackMessageId",
            "type": "string"
        },
        {
            "name": "webhook",
            "baseName": "webhook",
            "type": "WebhookModel"
        },
        {
            "name": "parameterValues",
            "baseName": "parameterValues",
            "type": "Array<WebhookParameterValueModel>"
        }    ];

    static getAttributeTypeMap() {
        return FallbackMessageWebhookModel.attributeTypeMap;
    }
}

export class FeatureModel {
    'id'?: string;
    'name'?: string;
    'isCustom'?: boolean;
    'featureType'?: FeatureTypeModel;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "isCustom",
            "baseName": "isCustom",
            "type": "boolean"
        },
        {
            "name": "featureType",
            "baseName": "featureType",
            "type": "FeatureTypeModel"
        }    ];

    static getAttributeTypeMap() {
        return FeatureModel.attributeTypeMap;
    }
}

export class FeatureTypeModel {
    'id'?: string;
    'name'?: string;
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FeatureTypeModel.attributeTypeMap;
    }
}

export class FollowUpHintModel {
    'id'?: string;
    'content'?: string;
    'followUpId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FollowUpHintModel.attributeTypeMap;
    }
}

export class FollowUpModel {
    'id'?: string;
    'applicationId'?: string;
    'content'?: string;
    'name'?: string;
    'followUpHints'?: Array<FollowUpHintModel>;
    'childContentContainerId'?: string;
    'childContentContainer'?: ChildContentContainerModel;
    'helpMessageId'?: string;
    'helpMessage'?: HelpMessageModel;
    'fallbackMessageId'?: string;
    'fallbackMessage'?: FallbackMessageModel;
    'createdFromId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "followUpHints",
            "baseName": "followUpHints",
            "type": "Array<FollowUpHintModel>"
        },
        {
            "name": "childContentContainerId",
            "baseName": "childContentContainerId",
            "type": "string"
        },
        {
            "name": "childContentContainer",
            "baseName": "childContentContainer",
            "type": "ChildContentContainerModel"
        },
        {
            "name": "helpMessageId",
            "baseName": "helpMessageId",
            "type": "string"
        },
        {
            "name": "helpMessage",
            "baseName": "helpMessage",
            "type": "HelpMessageModel"
        },
        {
            "name": "fallbackMessageId",
            "baseName": "fallbackMessageId",
            "type": "string"
        },
        {
            "name": "fallbackMessage",
            "baseName": "fallbackMessage",
            "type": "FallbackMessageModel"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FollowUpModel.attributeTypeMap;
    }
}

export class GenericContentModel {
    'id'?: string;
    'isLive'?: boolean;
    'hits'?: number;
    'title'?: string;
    'requiresParent'?: boolean;
    'isComplete'?: boolean;
    'featureTypeId'?: string;
    'applicationId'?: string;
    'applicationFeatureId'?: string;
    'modifiedDate'?: Date;
    'createdDate'?: Date;
    'hasAudio'?: boolean;
    'hasVideo'?: boolean;
    'hasBackgroundImage'?: boolean;
    'hasForegroundImage'?: boolean;
    'followUpId'?: string;
    'languages'?: Array<LanguageModel>;
    'shouldNotSync'?: boolean;
    'createdFromId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        },
        {
            "name": "hits",
            "baseName": "hits",
            "type": "number"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "isComplete",
            "baseName": "isComplete",
            "type": "boolean"
        },
        {
            "name": "featureTypeId",
            "baseName": "featureTypeId",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "hasAudio",
            "baseName": "hasAudio",
            "type": "boolean"
        },
        {
            "name": "hasVideo",
            "baseName": "hasVideo",
            "type": "boolean"
        },
        {
            "name": "hasBackgroundImage",
            "baseName": "hasBackgroundImage",
            "type": "boolean"
        },
        {
            "name": "hasForegroundImage",
            "baseName": "hasForegroundImage",
            "type": "boolean"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        },
        {
            "name": "shouldNotSync",
            "baseName": "shouldNotSync",
            "type": "boolean"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return GenericContentModel.attributeTypeMap;
    }
}

export class HelpMessageExportModel {
    'id'?: string;
    'isLive'?: boolean;
    'startDate'?: Date;
    'endDate'?: Date;
    'applicationId'?: string;
    'applicationFeatureId'?: string;
    'title'?: string;
    'content'?: string;
    'smallImage'?: MediaItemModel;
    'largeImage'?: MediaItemModel;
    'backgroundImage'?: MediaItemModel;
    'audio'?: MediaItemModel;
    'video'?: MediaItemModel;
    'helpMessageWebhooks'?: Array<HelpMessageWebhookModel>;
    'mediaResponseContainer'?: MediaResponseContainerModel;
    'followUp'?: FollowUpModel;
    'hits'?: number;
    'createdDate'?: Date;
    'modifiedDate'?: Date;
    'reprompt'?: RepromptModel;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'followUpId'?: string;
    'requiresParent'?: boolean;
    'repromptId'?: string;
    'createdFromId'?: string;
    'isComplete'?: boolean;
    'languages'?: Array<LanguageModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "smallImage",
            "baseName": "smallImage",
            "type": "MediaItemModel"
        },
        {
            "name": "largeImage",
            "baseName": "largeImage",
            "type": "MediaItemModel"
        },
        {
            "name": "backgroundImage",
            "baseName": "backgroundImage",
            "type": "MediaItemModel"
        },
        {
            "name": "audio",
            "baseName": "audio",
            "type": "MediaItemModel"
        },
        {
            "name": "video",
            "baseName": "video",
            "type": "MediaItemModel"
        },
        {
            "name": "helpMessageWebhooks",
            "baseName": "helpMessageWebhooks",
            "type": "Array<HelpMessageWebhookModel>"
        },
        {
            "name": "mediaResponseContainer",
            "baseName": "mediaResponseContainer",
            "type": "MediaResponseContainerModel"
        },
        {
            "name": "followUp",
            "baseName": "followUp",
            "type": "FollowUpModel"
        },
        {
            "name": "hits",
            "baseName": "hits",
            "type": "number"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "reprompt",
            "baseName": "reprompt",
            "type": "RepromptModel"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        },
        {
            "name": "isComplete",
            "baseName": "isComplete",
            "type": "boolean"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        }    ];

    static getAttributeTypeMap() {
        return HelpMessageExportModel.attributeTypeMap;
    }
}

export class HelpMessageModel {
    'id'?: string;
    'isLive'?: boolean;
    'startDate'?: Date;
    'endDate'?: Date;
    'applicationId'?: string;
    'applicationFeatureId'?: string;
    'title'?: string;
    'content'?: string;
    'smallImage'?: MediaItemModel;
    'largeImage'?: MediaItemModel;
    'backgroundImage'?: MediaItemModel;
    'audio'?: MediaItemModel;
    'video'?: MediaItemModel;
    'helpMessageWebhooks'?: Array<HelpMessageWebhookModel>;
    'mediaResponseContainer'?: MediaResponseContainerModel;
    'followUp'?: FollowUpModel;
    'hits'?: number;
    'createdDate'?: Date;
    'modifiedDate'?: Date;
    'reprompt'?: RepromptModel;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'followUpId'?: string;
    'requiresParent'?: boolean;
    'repromptId'?: string;
    'createdFromId'?: string;
    'isComplete'?: boolean;
    'languages'?: Array<LanguageModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "smallImage",
            "baseName": "smallImage",
            "type": "MediaItemModel"
        },
        {
            "name": "largeImage",
            "baseName": "largeImage",
            "type": "MediaItemModel"
        },
        {
            "name": "backgroundImage",
            "baseName": "backgroundImage",
            "type": "MediaItemModel"
        },
        {
            "name": "audio",
            "baseName": "audio",
            "type": "MediaItemModel"
        },
        {
            "name": "video",
            "baseName": "video",
            "type": "MediaItemModel"
        },
        {
            "name": "helpMessageWebhooks",
            "baseName": "helpMessageWebhooks",
            "type": "Array<HelpMessageWebhookModel>"
        },
        {
            "name": "mediaResponseContainer",
            "baseName": "mediaResponseContainer",
            "type": "MediaResponseContainerModel"
        },
        {
            "name": "followUp",
            "baseName": "followUp",
            "type": "FollowUpModel"
        },
        {
            "name": "hits",
            "baseName": "hits",
            "type": "number"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "reprompt",
            "baseName": "reprompt",
            "type": "RepromptModel"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        },
        {
            "name": "isComplete",
            "baseName": "isComplete",
            "type": "boolean"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        }    ];

    static getAttributeTypeMap() {
        return HelpMessageModel.attributeTypeMap;
    }
}

export class HelpMessageWebhookModel {
    'id'?: string;
    'helpMessageId'?: string;
    'webhook'?: WebhookModel;
    'parameterValues'?: Array<WebhookParameterValueModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "helpMessageId",
            "baseName": "helpMessageId",
            "type": "string"
        },
        {
            "name": "webhook",
            "baseName": "webhook",
            "type": "WebhookModel"
        },
        {
            "name": "parameterValues",
            "baseName": "parameterValues",
            "type": "Array<WebhookParameterValueModel>"
        }    ];

    static getAttributeTypeMap() {
        return HelpMessageWebhookModel.attributeTypeMap;
    }
}

export class Intent {
    'displayName'?: string;
    'name'?: { [key: string]: string; };
    'utterances'?: Array<string>;
    'slots'?: Array<Slot>;
    'isUserEditable'?: boolean;
    'platformsToIgnoreUtterances'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "displayName",
            "baseName": "displayName",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "utterances",
            "baseName": "utterances",
            "type": "Array<string>"
        },
        {
            "name": "slots",
            "baseName": "slots",
            "type": "Array<Slot>"
        },
        {
            "name": "isUserEditable",
            "baseName": "isUserEditable",
            "type": "boolean"
        },
        {
            "name": "platformsToIgnoreUtterances",
            "baseName": "platformsToIgnoreUtterances",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return Intent.attributeTypeMap;
    }
}

export class IntentStatusUpdate {
    'intentName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "intentName",
            "baseName": "intentName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return IntentStatusUpdate.attributeTypeMap;
    }
}

export class IntentUpdate {
    'addedUtterances'?: Array<string>;
    'removedUtterances'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "addedUtterances",
            "baseName": "addedUtterances",
            "type": "Array<string>"
        },
        {
            "name": "removedUtterances",
            "baseName": "removedUtterances",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return IntentUpdate.attributeTypeMap;
    }
}

export class InteractionModel {
    'validAsOf'?: number;
    'locale'?: string;
    'intents'?: Array<Intent>;
    'disabledIntents'?: Array<DisabledIntent>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "validAsOf",
            "baseName": "validAsOf",
            "type": "number"
        },
        {
            "name": "locale",
            "baseName": "locale",
            "type": "string"
        },
        {
            "name": "intents",
            "baseName": "intents",
            "type": "Array<Intent>"
        },
        {
            "name": "disabledIntents",
            "baseName": "disabledIntents",
            "type": "Array<DisabledIntent>"
        }    ];

    static getAttributeTypeMap() {
        return InteractionModel.attributeTypeMap;
    }
}

export class InteractionModelDeploymentResultModel {
    'applicationId'?: string;
    'success'?: boolean;
    'platform'?: string;
    'error'?: string;
    'validAsOfTicks'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "success",
            "baseName": "success",
            "type": "boolean"
        },
        {
            "name": "platform",
            "baseName": "platform",
            "type": "string"
        },
        {
            "name": "error",
            "baseName": "error",
            "type": "string"
        },
        {
            "name": "validAsOfTicks",
            "baseName": "validAsOfTicks",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return InteractionModelDeploymentResultModel.attributeTypeMap;
    }
}

export class InteractionModelStatus {
    'latestDeploymentResults'?: Array<InteractionModelDeploymentResultModel>;
    'queuedForDeploymentToPlatforms'?: Array<QueuedInteractionModelUpdate>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "latestDeploymentResults",
            "baseName": "latestDeploymentResults",
            "type": "Array<InteractionModelDeploymentResultModel>"
        },
        {
            "name": "queuedForDeploymentToPlatforms",
            "baseName": "queuedForDeploymentToPlatforms",
            "type": "Array<QueuedInteractionModelUpdate>"
        }    ];

    static getAttributeTypeMap() {
        return InteractionModelStatus.attributeTypeMap;
    }
}

export class InteractionModelUpdate {
    'effectiveAsOf'?: number;
    'intents'?: { [key: string]: IntentUpdate; };
    'disableIntents'?: Array<IntentStatusUpdate>;
    'enableIntents'?: Array<IntentStatusUpdate>;
    'isBaseUpdate'?: boolean;
    'locale'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "effectiveAsOf",
            "baseName": "effectiveAsOf",
            "type": "number"
        },
        {
            "name": "intents",
            "baseName": "intents",
            "type": "{ [key: string]: IntentUpdate; }"
        },
        {
            "name": "disableIntents",
            "baseName": "disableIntents",
            "type": "Array<IntentStatusUpdate>"
        },
        {
            "name": "enableIntents",
            "baseName": "enableIntents",
            "type": "Array<IntentStatusUpdate>"
        },
        {
            "name": "isBaseUpdate",
            "baseName": "isBaseUpdate",
            "type": "boolean"
        },
        {
            "name": "locale",
            "baseName": "locale",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InteractionModelUpdate.attributeTypeMap;
    }
}

export class InteractionModelUpdateWithReference {
    'createdFromReferenceId'?: string;
    'effectiveAsOf'?: number;
    'intents'?: { [key: string]: IntentUpdate; };
    'disableIntents'?: Array<IntentStatusUpdate>;
    'enableIntents'?: Array<IntentStatusUpdate>;
    'isBaseUpdate'?: boolean;
    'locale'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdFromReferenceId",
            "baseName": "createdFromReferenceId",
            "type": "string"
        },
        {
            "name": "effectiveAsOf",
            "baseName": "effectiveAsOf",
            "type": "number"
        },
        {
            "name": "intents",
            "baseName": "intents",
            "type": "{ [key: string]: IntentUpdate; }"
        },
        {
            "name": "disableIntents",
            "baseName": "disableIntents",
            "type": "Array<IntentStatusUpdate>"
        },
        {
            "name": "enableIntents",
            "baseName": "enableIntents",
            "type": "Array<IntentStatusUpdate>"
        },
        {
            "name": "isBaseUpdate",
            "baseName": "isBaseUpdate",
            "type": "boolean"
        },
        {
            "name": "locale",
            "baseName": "locale",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return InteractionModelUpdateWithReference.attributeTypeMap;
    }
}

export class InvitationModel {
    'id'?: string;
    'organizationId'?: string;
    'email'?: string;
    'expirationDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "expirationDate",
            "baseName": "expirationDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return InvitationModel.attributeTypeMap;
    }
}

export class LanguageModel {
    'id'?: string;
    'shortCode'?: string;
    'languageGroupCode'?: string;
    'regionCode'?: string;
    'supportedPlatforms'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "shortCode",
            "baseName": "shortCode",
            "type": "string"
        },
        {
            "name": "languageGroupCode",
            "baseName": "languageGroupCode",
            "type": "string"
        },
        {
            "name": "regionCode",
            "baseName": "regionCode",
            "type": "string"
        },
        {
            "name": "supportedPlatforms",
            "baseName": "supportedPlatforms",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LanguageModel.attributeTypeMap;
    }
}

export class LatestMessageExportModel {
    'id'?: string;
    'applicationId'?: string;
    'applicationFeatureId'?: string;
    'title'?: string;
    'isLive'?: boolean;
    'applicationModuleId'?: string;
    'createdFromId'?: string;
    'startDate'?: Date;
    'endDate'?: Date;
    'responses'?: Array<LatestMessageResponseModel>;
    'latestMessageWebhooks'?: Array<LatestMessageWebhookModel>;
    'hits'?: number;
    'modifiedDate'?: Date;
    'createdDate'?: Date;
    'category'?: string;
    'requiresParent'?: boolean;
    'isComplete'?: boolean;
    'languages'?: Array<LanguageModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        },
        {
            "name": "applicationModuleId",
            "baseName": "applicationModuleId",
            "type": "string"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<LatestMessageResponseModel>"
        },
        {
            "name": "latestMessageWebhooks",
            "baseName": "latestMessageWebhooks",
            "type": "Array<LatestMessageWebhookModel>"
        },
        {
            "name": "hits",
            "baseName": "hits",
            "type": "number"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "isComplete",
            "baseName": "isComplete",
            "type": "boolean"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        }    ];

    static getAttributeTypeMap() {
        return LatestMessageExportModel.attributeTypeMap;
    }
}

export class LatestMessageModel {
    'id'?: string;
    'applicationId'?: string;
    'applicationFeatureId'?: string;
    'title'?: string;
    'isLive'?: boolean;
    'applicationModuleId'?: string;
    'createdFromId'?: string;
    'startDate'?: Date;
    'endDate'?: Date;
    'responses'?: Array<LatestMessageResponseModel>;
    'latestMessageWebhooks'?: Array<LatestMessageWebhookModel>;
    'hits'?: number;
    'modifiedDate'?: Date;
    'createdDate'?: Date;
    'category'?: string;
    'requiresParent'?: boolean;
    'isComplete'?: boolean;
    'languages'?: Array<LanguageModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        },
        {
            "name": "applicationModuleId",
            "baseName": "applicationModuleId",
            "type": "string"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<LatestMessageResponseModel>"
        },
        {
            "name": "latestMessageWebhooks",
            "baseName": "latestMessageWebhooks",
            "type": "Array<LatestMessageWebhookModel>"
        },
        {
            "name": "hits",
            "baseName": "hits",
            "type": "number"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "isComplete",
            "baseName": "isComplete",
            "type": "boolean"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        }    ];

    static getAttributeTypeMap() {
        return LatestMessageModel.attributeTypeMap;
    }
}

export class LatestMessageResponseModel {
    'id'?: string;
    'content'?: string;
    'latestMessageId'?: string;
    'smallImage'?: MediaItemModel;
    'largeImage'?: MediaItemModel;
    'backgroundImage'?: MediaItemModel;
    'audio'?: MediaItemModel;
    'video'?: MediaItemModel;
    'repromptId'?: string;
    'reprompt'?: RepromptModel;
    'mediaResponseContainer'?: MediaResponseContainerModel;
    'followUp'?: FollowUpModel;
    'createdDate'?: Date;
    'modifiedDate'?: Date;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'followUpId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "latestMessageId",
            "baseName": "latestMessageId",
            "type": "string"
        },
        {
            "name": "smallImage",
            "baseName": "smallImage",
            "type": "MediaItemModel"
        },
        {
            "name": "largeImage",
            "baseName": "largeImage",
            "type": "MediaItemModel"
        },
        {
            "name": "backgroundImage",
            "baseName": "backgroundImage",
            "type": "MediaItemModel"
        },
        {
            "name": "audio",
            "baseName": "audio",
            "type": "MediaItemModel"
        },
        {
            "name": "video",
            "baseName": "video",
            "type": "MediaItemModel"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "reprompt",
            "baseName": "reprompt",
            "type": "RepromptModel"
        },
        {
            "name": "mediaResponseContainer",
            "baseName": "mediaResponseContainer",
            "type": "MediaResponseContainerModel"
        },
        {
            "name": "followUp",
            "baseName": "followUp",
            "type": "FollowUpModel"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LatestMessageResponseModel.attributeTypeMap;
    }
}

export class LatestMessageWebhookModel {
    'id'?: string;
    'latestMessageId'?: string;
    'webhook'?: WebhookModel;
    'parameterValues'?: Array<WebhookParameterValueModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "latestMessageId",
            "baseName": "latestMessageId",
            "type": "string"
        },
        {
            "name": "webhook",
            "baseName": "webhook",
            "type": "WebhookModel"
        },
        {
            "name": "parameterValues",
            "baseName": "parameterValues",
            "type": "Array<WebhookParameterValueModel>"
        }    ];

    static getAttributeTypeMap() {
        return LatestMessageWebhookModel.attributeTypeMap;
    }
}

export class LuisAppEndpoint {
    'endpointRegion'?: string;
    'endpointUrl'?: string;
    'versionId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "endpointRegion",
            "baseName": "endpointRegion",
            "type": "string"
        },
        {
            "name": "endpointUrl",
            "baseName": "endpointUrl",
            "type": "string"
        },
        {
            "name": "versionId",
            "baseName": "versionId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LuisAppEndpoint.attributeTypeMap;
    }
}

export class LuisAppEndpointsContainer {
    'PRODUCTION'?: LuisAppEndpoint;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "PRODUCTION",
            "baseName": "PRODUCTION",
            "type": "LuisAppEndpoint"
        }    ];

    static getAttributeTypeMap() {
        return LuisAppEndpointsContainer.attributeTypeMap;
    }
}

export class LuisApplicationInformation {
    'endpoints'?: LuisAppEndpointsContainer;
    'activeVersion'?: string;
    'id'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "endpoints",
            "baseName": "endpoints",
            "type": "LuisAppEndpointsContainer"
        },
        {
            "name": "activeVersion",
            "baseName": "activeVersion",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return LuisApplicationInformation.attributeTypeMap;
    }
}

export class MediaContentItems {
    'mediaItemId'?: string;
    'contentItems'?: Array<MediaRelatedContentItem>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mediaItemId",
            "baseName": "mediaItemId",
            "type": "string"
        },
        {
            "name": "contentItems",
            "baseName": "contentItems",
            "type": "Array<MediaRelatedContentItem>"
        }    ];

    static getAttributeTypeMap() {
        return MediaContentItems.attributeTypeMap;
    }
}

export class MediaItemModel {
    'id'?: string;
    'name'?: string;
    'url'?: string;
    'fileExtension'?: string;
    'mediaType'?: string;
    'applicationId'?: string;
    'modifiedDate'?: Date;
    'caption'?: string;
    'isDisabled'?: boolean;
    'modifiedByUserId'?: string;
    'createdFromId'?: string;
    'modifiedByUser'?: UserModel;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "fileExtension",
            "baseName": "fileExtension",
            "type": "string"
        },
        {
            "name": "mediaType",
            "baseName": "mediaType",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "caption",
            "baseName": "caption",
            "type": "string"
        },
        {
            "name": "isDisabled",
            "baseName": "isDisabled",
            "type": "boolean"
        },
        {
            "name": "modifiedByUserId",
            "baseName": "modifiedByUserId",
            "type": "string"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        },
        {
            "name": "modifiedByUser",
            "baseName": "modifiedByUser",
            "type": "UserModel"
        }    ];

    static getAttributeTypeMap() {
        return MediaItemModel.attributeTypeMap;
    }
}

export class MediaRelatedContentItem {
    'name'?: string;
    'applicationFeatureId'?: string;
    'featureTypeId'?: string;
    'contentItemId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "featureTypeId",
            "baseName": "featureTypeId",
            "type": "string"
        },
        {
            "name": "contentItemId",
            "baseName": "contentItemId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MediaRelatedContentItem.attributeTypeMap;
    }
}

export class MediaResponseContainerModel {
    'id'?: string;
    'applicationId'?: string;
    'additionalMediaItems'?: Array<MediaItemModel>;
    'responses'?: Array<MediaResponseModel>;
    'createdFromId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "additionalMediaItems",
            "baseName": "additionalMediaItems",
            "type": "Array<MediaItemModel>"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<MediaResponseModel>"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MediaResponseContainerModel.attributeTypeMap;
    }
}

export class MediaResponseModel {
    'id'?: string;
    'responseTemplateTypeId'?: string;
    'applicationId'?: string;
    'displayTitle'?: string;
    'displayText'?: string;
    'readoutOverride'?: string;
    'foregroundImageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'deviceTargetId'?: string;
    'customMarkup'?: string;
    'createdFromId'?: string;
    'responseTemplateType'?: ResponseTemplateTypeModel;
    'foregroundImageItem'?: MediaItemModel;
    'backgroundImageItem'?: MediaItemModel;
    'audioItem'?: MediaItemModel;
    'videoItem'?: MediaItemModel;
    'deviceTarget'?: BasicDeviceTargetModel;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "responseTemplateTypeId",
            "baseName": "responseTemplateTypeId",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "displayTitle",
            "baseName": "displayTitle",
            "type": "string"
        },
        {
            "name": "displayText",
            "baseName": "displayText",
            "type": "string"
        },
        {
            "name": "readoutOverride",
            "baseName": "readoutOverride",
            "type": "string"
        },
        {
            "name": "foregroundImageItemId",
            "baseName": "foregroundImageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "deviceTargetId",
            "baseName": "deviceTargetId",
            "type": "string"
        },
        {
            "name": "customMarkup",
            "baseName": "customMarkup",
            "type": "string"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        },
        {
            "name": "responseTemplateType",
            "baseName": "responseTemplateType",
            "type": "ResponseTemplateTypeModel"
        },
        {
            "name": "foregroundImageItem",
            "baseName": "foregroundImageItem",
            "type": "MediaItemModel"
        },
        {
            "name": "backgroundImageItem",
            "baseName": "backgroundImageItem",
            "type": "MediaItemModel"
        },
        {
            "name": "audioItem",
            "baseName": "audioItem",
            "type": "MediaItemModel"
        },
        {
            "name": "videoItem",
            "baseName": "videoItem",
            "type": "MediaItemModel"
        },
        {
            "name": "deviceTarget",
            "baseName": "deviceTarget",
            "type": "BasicDeviceTargetModel"
        }    ];

    static getAttributeTypeMap() {
        return MediaResponseModel.attributeTypeMap;
    }
}

export class MemberRoleUpdateRequest {
    'roleId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "roleId",
            "baseName": "roleId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MemberRoleUpdateRequest.attributeTypeMap;
    }
}

export class MembershipModel {
    'id'?: string;
    'userId'?: string;
    'email'?: string;
    'firstName'?: string;
    'lastName'?: string;
    'imageUrl'?: string;
    'organizationId'?: string;
    'isAdmin'?: boolean;
    'canEdit'?: boolean;
    'applicationMemberships'?: Array<ApplicationMemberRoleModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "isAdmin",
            "baseName": "isAdmin",
            "type": "boolean"
        },
        {
            "name": "canEdit",
            "baseName": "canEdit",
            "type": "boolean"
        },
        {
            "name": "applicationMemberships",
            "baseName": "applicationMemberships",
            "type": "Array<ApplicationMemberRoleModel>"
        }    ];

    static getAttributeTypeMap() {
        return MembershipModel.attributeTypeMap;
    }
}

export class MicrosoftDeploymentLink {
    'botServiceName'?: string;
    'microsoftAppId'?: string;
    'microsoftAppPassword'?: string;
    'luisRegion'?: string;
    'luisAuthoringKey'?: string;
    'luisAppId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "botServiceName",
            "baseName": "botServiceName",
            "type": "string"
        },
        {
            "name": "microsoftAppId",
            "baseName": "microsoftAppId",
            "type": "string"
        },
        {
            "name": "microsoftAppPassword",
            "baseName": "microsoftAppPassword",
            "type": "string"
        },
        {
            "name": "luisRegion",
            "baseName": "luisRegion",
            "type": "string"
        },
        {
            "name": "luisAuthoringKey",
            "baseName": "luisAuthoringKey",
            "type": "string"
        },
        {
            "name": "luisAppId",
            "baseName": "luisAppId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MicrosoftDeploymentLink.attributeTypeMap;
    }
}

export class NewApiUserRequest {
    'organizationId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NewApiUserRequest.attributeTypeMap;
    }
}

export class NewApplicationMemberRequest {
    'organizationMemberId'?: string;
    'roleId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organizationMemberId",
            "baseName": "organizationMemberId",
            "type": "string"
        },
        {
            "name": "roleId",
            "baseName": "roleId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NewApplicationMemberRequest.attributeTypeMap;
    }
}

export class NewApplicationRequest {
    'name': string;
    'shortDescription'?: string;
    'description'?: string;
    'invocationPhrase': string;
    'keywords'?: string;
    'defaultLanguageId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "shortDescription",
            "baseName": "shortDescription",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "invocationPhrase",
            "baseName": "invocationPhrase",
            "type": "string"
        },
        {
            "name": "keywords",
            "baseName": "keywords",
            "type": "string"
        },
        {
            "name": "defaultLanguageId",
            "baseName": "defaultLanguageId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NewApplicationRequest.attributeTypeMap;
    }
}

export class NewBulkApplicationMemberRequest {
    'organizationMemberIds'?: Array<string>;
    'roleId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "organizationMemberIds",
            "baseName": "organizationMemberIds",
            "type": "Array<string>"
        },
        {
            "name": "roleId",
            "baseName": "roleId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NewBulkApplicationMemberRequest.attributeTypeMap;
    }
}

export class NewBulkMediaResponseContainerRequest {
    'applicationId': string;
    'additionalMediaItemIds': Array<string>;
    'responses': Array<NewMediaResponseRequest>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "additionalMediaItemIds",
            "baseName": "additionalMediaItemIds",
            "type": "Array<string>"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<NewMediaResponseRequest>"
        }    ];

    static getAttributeTypeMap() {
        return NewBulkMediaResponseContainerRequest.attributeTypeMap;
    }
}

export class NewCustomRequestRequest {
    'responses': Array<NewCustomRequestResponseRequest>;
    'applicationId': string;
    'applicationFeatureId': string;
    'startDate'?: Date;
    'endDate'?: Date;
    'requestTypes'?: string;
    'requestNames'?: string;
    'platformFilter'?: string;
    'title': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<NewCustomRequestResponseRequest>"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "requestTypes",
            "baseName": "requestTypes",
            "type": "string"
        },
        {
            "name": "requestNames",
            "baseName": "requestNames",
            "type": "string"
        },
        {
            "name": "platformFilter",
            "baseName": "platformFilter",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return NewCustomRequestRequest.attributeTypeMap;
    }
}

export class NewCustomRequestResponseRequest {
    'content': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NewCustomRequestResponseRequest.attributeTypeMap;
    }
}

export class NewCustomRequestStubRequest {
    'applicationId': string;
    'applicationFeatureId': string;
    'startDate'?: Date;
    'endDate'?: Date;
    'requestTypes'?: string;
    'requestNames'?: string;
    'platformFilter'?: string;
    'title': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'responses'?: Array<NewCustomRequestResponseRequest>;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "requestTypes",
            "baseName": "requestTypes",
            "type": "string"
        },
        {
            "name": "requestNames",
            "baseName": "requestNames",
            "type": "string"
        },
        {
            "name": "platformFilter",
            "baseName": "platformFilter",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<NewCustomRequestResponseRequest>"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return NewCustomRequestStubRequest.attributeTypeMap;
    }
}

export class NewExitMessageRequest {
    'content': string;
    'title': string;
    'applicationId': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'applicationFeatureId': string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return NewExitMessageRequest.attributeTypeMap;
    }
}

export class NewExitMessageStubRequest {
    'content'?: string;
    'title': string;
    'applicationId': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'applicationFeatureId': string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return NewExitMessageStubRequest.attributeTypeMap;
    }
}

export class NewFallbackMessageRequest {
    'content': string;
    'title': string;
    'applicationId'?: string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'applicationFeatureId': string;
    'categoryId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "categoryId",
            "baseName": "categoryId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return NewFallbackMessageRequest.attributeTypeMap;
    }
}

export class NewFallbackMessageStubRequest {
    'content'?: string;
    'title': string;
    'applicationId'?: string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'applicationFeatureId': string;
    'categoryId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "categoryId",
            "baseName": "categoryId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return NewFallbackMessageStubRequest.attributeTypeMap;
    }
}

export class NewHelpMessageRequest {
    'content': string;
    'title': string;
    'applicationId'?: string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'applicationFeatureId': string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return NewHelpMessageRequest.attributeTypeMap;
    }
}

export class NewHelpMessageStubRequest {
    'content'?: string;
    'title': string;
    'applicationId'?: string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'applicationFeatureId': string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return NewHelpMessageStubRequest.attributeTypeMap;
    }
}

export class NewInvitationRequest {
    'email': string;
    'roleId': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "roleId",
            "baseName": "roleId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NewInvitationRequest.attributeTypeMap;
    }
}

export class NewLatestMessageRequest {
    'responses': Array<NewLatestMessageResponseRequest>;
    'startDate': Date;
    'endDate': Date;
    'category': string;
    'applicationId': string;
    'applicationFeatureId': string;
    'title': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<NewLatestMessageResponseRequest>"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return NewLatestMessageRequest.attributeTypeMap;
    }
}

export class NewLatestMessageResponseRequest {
    'content': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NewLatestMessageResponseRequest.attributeTypeMap;
    }
}

export class NewLatestMessageStubRequest {
    'applicationId': string;
    'applicationFeatureId': string;
    'startDate'?: Date;
    'endDate'?: Date;
    'category'?: string;
    'title': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'responses'?: Array<NewLatestMessageResponseRequest>;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<NewLatestMessageResponseRequest>"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return NewLatestMessageStubRequest.attributeTypeMap;
    }
}

export class NewLuisAppResponse {
    'luisAppId'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "luisAppId",
            "baseName": "luisAppId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NewLuisAppResponse.attributeTypeMap;
    }
}

export class NewMediaItemRequest {
    'url': string;
    'name': string;
    'fileName': string;
    'caption'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "fileName",
            "baseName": "fileName",
            "type": "string"
        },
        {
            "name": "caption",
            "baseName": "caption",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NewMediaItemRequest.attributeTypeMap;
    }
}

export class NewMediaResponseContainerRequest {
    'applicationId': string;
    'additionalMediaItemIds': Array<string>;
    'responseIds': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "additionalMediaItemIds",
            "baseName": "additionalMediaItemIds",
            "type": "Array<string>"
        },
        {
            "name": "responseIds",
            "baseName": "responseIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return NewMediaResponseContainerRequest.attributeTypeMap;
    }
}

export class NewMediaResponseRequest {
    'responseTemplateTypeId': string;
    'applicationId': string;
    'displayTitle'?: string;
    'displayText'?: string;
    'readoutOverride'?: string;
    'foregroundImageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'deviceTargetId'?: string;
    'customMarkup'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "responseTemplateTypeId",
            "baseName": "responseTemplateTypeId",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "displayTitle",
            "baseName": "displayTitle",
            "type": "string"
        },
        {
            "name": "displayText",
            "baseName": "displayText",
            "type": "string"
        },
        {
            "name": "readoutOverride",
            "baseName": "readoutOverride",
            "type": "string"
        },
        {
            "name": "foregroundImageItemId",
            "baseName": "foregroundImageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "deviceTargetId",
            "baseName": "deviceTargetId",
            "type": "string"
        },
        {
            "name": "customMarkup",
            "baseName": "customMarkup",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NewMediaResponseRequest.attributeTypeMap;
    }
}

export class NewModuleRequest {
    'name': string;
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NewModuleRequest.attributeTypeMap;
    }
}

export class NewNumberRangeRequest {
    'responses': Array<NewNumberRangeResponseRequest>;
    'applicationId': string;
    'applicationFeatureId': string;
    'minimumValue'?: number;
    'maximumValue'?: number;
    'title': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<NewNumberRangeResponseRequest>"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "minimumValue",
            "baseName": "minimumValue",
            "type": "number"
        },
        {
            "name": "maximumValue",
            "baseName": "maximumValue",
            "type": "number"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return NewNumberRangeRequest.attributeTypeMap;
    }
}

export class NewNumberRangeResponseRequest {
    'content': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NewNumberRangeResponseRequest.attributeTypeMap;
    }
}

export class NewNumberRangeStubRequest {
    'applicationId': string;
    'responses'?: Array<NewNumberRangeResponseRequest>;
    'applicationFeatureId': string;
    'minimumValue'?: number;
    'maximumValue'?: number;
    'title': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<NewNumberRangeResponseRequest>"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "minimumValue",
            "baseName": "minimumValue",
            "type": "number"
        },
        {
            "name": "maximumValue",
            "baseName": "maximumValue",
            "type": "number"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return NewNumberRangeStubRequest.attributeTypeMap;
    }
}

export class NewOrganizationRequest {
    'name': string;
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NewOrganizationRequest.attributeTypeMap;
    }
}

export class NewQuestionAnswerRequest {
    'questions': Array<CreateQuestionRequest>;
    'answers': Array<CreateAnswerRequest>;
    'title': string;
    'applicationId': string;
    'applicationFeatureId': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "questions",
            "baseName": "questions",
            "type": "Array<CreateQuestionRequest>"
        },
        {
            "name": "answers",
            "baseName": "answers",
            "type": "Array<CreateAnswerRequest>"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return NewQuestionAnswerRequest.attributeTypeMap;
    }
}

export class NewQuestionAnswerStubRequest {
    'title': string;
    'applicationId': string;
    'questions'?: Array<CreateQuestionRequest>;
    'answers'?: Array<CreateAnswerRequest>;
    'applicationFeatureId': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "questions",
            "baseName": "questions",
            "type": "Array<CreateQuestionRequest>"
        },
        {
            "name": "answers",
            "baseName": "answers",
            "type": "Array<CreateAnswerRequest>"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return NewQuestionAnswerStubRequest.attributeTypeMap;
    }
}

export class NewResponseTemplateTypeRequest {
    'name': string;
    'nativeName': string;
    'description': string;
    'assistant': string;
    'iconUrl': string;
    'usesVideo': boolean;
    'usesAudio': boolean;
    'usesBackgroundImage': boolean;
    'usesForegroundImage': boolean;
    'usesDisplayText': boolean;
    'usesDisplayTitle': boolean;
    'usesReadout': boolean;
    'requiresVideo': boolean;
    'requiresAudio': boolean;
    'requiresBackgroundImage': boolean;
    'requiresForegroundImage': boolean;
    'requiresDisplayText': boolean;
    'requiresDisplayTitle': boolean;
    'requiresReadout': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "nativeName",
            "baseName": "nativeName",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "assistant",
            "baseName": "assistant",
            "type": "string"
        },
        {
            "name": "iconUrl",
            "baseName": "iconUrl",
            "type": "string"
        },
        {
            "name": "usesVideo",
            "baseName": "usesVideo",
            "type": "boolean"
        },
        {
            "name": "usesAudio",
            "baseName": "usesAudio",
            "type": "boolean"
        },
        {
            "name": "usesBackgroundImage",
            "baseName": "usesBackgroundImage",
            "type": "boolean"
        },
        {
            "name": "usesForegroundImage",
            "baseName": "usesForegroundImage",
            "type": "boolean"
        },
        {
            "name": "usesDisplayText",
            "baseName": "usesDisplayText",
            "type": "boolean"
        },
        {
            "name": "usesDisplayTitle",
            "baseName": "usesDisplayTitle",
            "type": "boolean"
        },
        {
            "name": "usesReadout",
            "baseName": "usesReadout",
            "type": "boolean"
        },
        {
            "name": "requiresVideo",
            "baseName": "requiresVideo",
            "type": "boolean"
        },
        {
            "name": "requiresAudio",
            "baseName": "requiresAudio",
            "type": "boolean"
        },
        {
            "name": "requiresBackgroundImage",
            "baseName": "requiresBackgroundImage",
            "type": "boolean"
        },
        {
            "name": "requiresForegroundImage",
            "baseName": "requiresForegroundImage",
            "type": "boolean"
        },
        {
            "name": "requiresDisplayText",
            "baseName": "requiresDisplayText",
            "type": "boolean"
        },
        {
            "name": "requiresDisplayTitle",
            "baseName": "requiresDisplayTitle",
            "type": "boolean"
        },
        {
            "name": "requiresReadout",
            "baseName": "requiresReadout",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return NewResponseTemplateTypeRequest.attributeTypeMap;
    }
}

export class NewSimpleChoiceRequest {
    'responses': Array<NewSimpleChoiceResponseRequest>;
    'choiceType': NewSimpleChoiceRequest.ChoiceTypeEnum;
    'applicationId': string;
    'applicationFeatureId': string;
    'title': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<NewSimpleChoiceResponseRequest>"
        },
        {
            "name": "choiceType",
            "baseName": "choiceType",
            "type": "NewSimpleChoiceRequest.ChoiceTypeEnum"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return NewSimpleChoiceRequest.attributeTypeMap;
    }
}

export namespace NewSimpleChoiceRequest {
    export enum ChoiceTypeEnum {
        Yes = <any> 'Yes',
        No = <any> 'No',
        Maybe = <any> 'Maybe'
    }
}
export class NewSimpleChoiceResponseRequest {
    'content': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NewSimpleChoiceResponseRequest.attributeTypeMap;
    }
}

export class NewSimpleChoiceStubRequest {
    'applicationId': string;
    'responses'?: Array<NewSimpleChoiceResponseRequest>;
    'applicationFeatureId': string;
    'choiceType'?: NewSimpleChoiceStubRequest.ChoiceTypeEnum;
    'title': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<NewSimpleChoiceResponseRequest>"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "choiceType",
            "baseName": "choiceType",
            "type": "NewSimpleChoiceStubRequest.ChoiceTypeEnum"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return NewSimpleChoiceStubRequest.attributeTypeMap;
    }
}

export namespace NewSimpleChoiceStubRequest {
    export enum ChoiceTypeEnum {
        Yes = <any> 'Yes',
        No = <any> 'No',
        Maybe = <any> 'Maybe'
    }
}
export class NewSkillResponse {
    'id'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NewSkillResponse.attributeTypeMap;
    }
}

export class NewUserRequest {
    'email': string;
    'firstName': string;
    'lastName': string;
    'password': string;
    'confirmPassword': string;
    'agreedToTerms': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "password",
            "baseName": "password",
            "type": "string"
        },
        {
            "name": "confirmPassword",
            "baseName": "confirmPassword",
            "type": "string"
        },
        {
            "name": "agreedToTerms",
            "baseName": "agreedToTerms",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return NewUserRequest.attributeTypeMap;
    }
}

export class NewUserTermRequestModel {
    'termId': string;
    'agreed': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "termId",
            "baseName": "termId",
            "type": "string"
        },
        {
            "name": "agreed",
            "baseName": "agreed",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return NewUserTermRequestModel.attributeTypeMap;
    }
}

export class NewWebhookParameterRequest {
    'name': string;
    'description': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NewWebhookParameterRequest.attributeTypeMap;
    }
}

export class NewWebhookRequest {
    'title': string;
    'description': string;
    'webhookTypeId': string;
    'url': string;
    'accessToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "webhookTypeId",
            "baseName": "webhookTypeId",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "accessToken",
            "baseName": "accessToken",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NewWebhookRequest.attributeTypeMap;
    }
}

export class NewWelcomeMessageRequest {
    'content': string;
    'title': string;
    'applicationId'?: string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'applicationFeatureId': string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return NewWelcomeMessageRequest.attributeTypeMap;
    }
}

export class NewWelcomeMessageStubRequest {
    'title': string;
    'applicationId'?: string;
    'content'?: string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'applicationFeatureId': string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return NewWelcomeMessageStubRequest.attributeTypeMap;
    }
}

export class NumberRangeExportModel {
    'id'?: string;
    'applicationId'?: string;
    'applicationFeatureId'?: string;
    'title'?: string;
    'isLive'?: boolean;
    'applicationModuleId'?: string;
    'responses'?: Array<NumberRangeResponseModel>;
    'numberRangeWebhooks'?: Array<NumberRangeWebhookModel>;
    'hits'?: number;
    'modifiedDate'?: Date;
    'createdDate'?: Date;
    'minimumValue'?: number;
    'maximumValue'?: number;
    'requiresParent'?: boolean;
    'isComplete'?: boolean;
    'createdFromId'?: string;
    'languages'?: Array<LanguageModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        },
        {
            "name": "applicationModuleId",
            "baseName": "applicationModuleId",
            "type": "string"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<NumberRangeResponseModel>"
        },
        {
            "name": "numberRangeWebhooks",
            "baseName": "numberRangeWebhooks",
            "type": "Array<NumberRangeWebhookModel>"
        },
        {
            "name": "hits",
            "baseName": "hits",
            "type": "number"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "minimumValue",
            "baseName": "minimumValue",
            "type": "number"
        },
        {
            "name": "maximumValue",
            "baseName": "maximumValue",
            "type": "number"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "isComplete",
            "baseName": "isComplete",
            "type": "boolean"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        }    ];

    static getAttributeTypeMap() {
        return NumberRangeExportModel.attributeTypeMap;
    }
}

export class NumberRangeModel {
    'id'?: string;
    'applicationId'?: string;
    'applicationFeatureId'?: string;
    'title'?: string;
    'isLive'?: boolean;
    'applicationModuleId'?: string;
    'responses'?: Array<NumberRangeResponseModel>;
    'numberRangeWebhooks'?: Array<NumberRangeWebhookModel>;
    'hits'?: number;
    'modifiedDate'?: Date;
    'createdDate'?: Date;
    'minimumValue'?: number;
    'maximumValue'?: number;
    'requiresParent'?: boolean;
    'isComplete'?: boolean;
    'createdFromId'?: string;
    'languages'?: Array<LanguageModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        },
        {
            "name": "applicationModuleId",
            "baseName": "applicationModuleId",
            "type": "string"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<NumberRangeResponseModel>"
        },
        {
            "name": "numberRangeWebhooks",
            "baseName": "numberRangeWebhooks",
            "type": "Array<NumberRangeWebhookModel>"
        },
        {
            "name": "hits",
            "baseName": "hits",
            "type": "number"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "minimumValue",
            "baseName": "minimumValue",
            "type": "number"
        },
        {
            "name": "maximumValue",
            "baseName": "maximumValue",
            "type": "number"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "isComplete",
            "baseName": "isComplete",
            "type": "boolean"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        }    ];

    static getAttributeTypeMap() {
        return NumberRangeModel.attributeTypeMap;
    }
}

export class NumberRangeResponseModel {
    'id'?: string;
    'content'?: string;
    'numberRangeId'?: string;
    'smallImage'?: MediaItemModel;
    'largeImage'?: MediaItemModel;
    'backgroundImage'?: MediaItemModel;
    'audio'?: MediaItemModel;
    'video'?: MediaItemModel;
    'reprompt'?: RepromptModel;
    'repromptId'?: string;
    'mediaResponseContainer'?: MediaResponseContainerModel;
    'followUp'?: FollowUpModel;
    'createdDate'?: Date;
    'modifiedDate'?: Date;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'followUpId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "numberRangeId",
            "baseName": "numberRangeId",
            "type": "string"
        },
        {
            "name": "smallImage",
            "baseName": "smallImage",
            "type": "MediaItemModel"
        },
        {
            "name": "largeImage",
            "baseName": "largeImage",
            "type": "MediaItemModel"
        },
        {
            "name": "backgroundImage",
            "baseName": "backgroundImage",
            "type": "MediaItemModel"
        },
        {
            "name": "audio",
            "baseName": "audio",
            "type": "MediaItemModel"
        },
        {
            "name": "video",
            "baseName": "video",
            "type": "MediaItemModel"
        },
        {
            "name": "reprompt",
            "baseName": "reprompt",
            "type": "RepromptModel"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainer",
            "baseName": "mediaResponseContainer",
            "type": "MediaResponseContainerModel"
        },
        {
            "name": "followUp",
            "baseName": "followUp",
            "type": "FollowUpModel"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return NumberRangeResponseModel.attributeTypeMap;
    }
}

export class NumberRangeWebhookModel {
    'id'?: string;
    'numberRangeId'?: string;
    'webhook'?: WebhookModel;
    'parameterValues'?: Array<WebhookParameterValueModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "numberRangeId",
            "baseName": "numberRangeId",
            "type": "string"
        },
        {
            "name": "webhook",
            "baseName": "webhook",
            "type": "WebhookModel"
        },
        {
            "name": "parameterValues",
            "baseName": "parameterValues",
            "type": "Array<WebhookParameterValueModel>"
        }    ];

    static getAttributeTypeMap() {
        return NumberRangeWebhookModel.attributeTypeMap;
    }
}

export class OrganizationMemberModel {
    'id'?: string;
    'organizationId'?: string;
    'userId'?: string;
    'email'?: string;
    'firstName'?: string;
    'lastName'?: string;
    'isAdmin'?: boolean;
    'canEdit'?: boolean;
    'imageUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "userId",
            "baseName": "userId",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "isAdmin",
            "baseName": "isAdmin",
            "type": "boolean"
        },
        {
            "name": "canEdit",
            "baseName": "canEdit",
            "type": "boolean"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrganizationMemberModel.attributeTypeMap;
    }
}

export class OrganizationModel {
    'id'?: string;
    'name'?: string;
    'description'?: string;
    'subscriptions'?: Array<SubscriptionModel>;
    'secret'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "subscriptions",
            "baseName": "subscriptions",
            "type": "Array<SubscriptionModel>"
        },
        {
            "name": "secret",
            "baseName": "secret",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return OrganizationModel.attributeTypeMap;
    }
}

export class ParentContentContainerModel {
    'welcomeMessages'?: Array<WelcomeMessageModel>;
    'helpMessages'?: Array<HelpMessageModel>;
    'fallbackMessages'?: Array<FallbackMessageModel>;
    'exitMessages'?: Array<ExitMessageModel>;
    'questionAnswers'?: Array<QuestionAnswerModel>;
    'latestMessages'?: Array<LatestMessageModel>;
    'eventItems'?: Array<EventItemModel>;
    'recipes'?: Array<RecipeModel>;
    'simpleChoices'?: Array<SimpleChoiceModel>;
    'numberRanges'?: Array<NumberRangeModel>;
    'customRequests'?: Array<CustomRequestModel>;
    'contentItems'?: Array<GenericContentModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "welcomeMessages",
            "baseName": "welcomeMessages",
            "type": "Array<WelcomeMessageModel>"
        },
        {
            "name": "helpMessages",
            "baseName": "helpMessages",
            "type": "Array<HelpMessageModel>"
        },
        {
            "name": "fallbackMessages",
            "baseName": "fallbackMessages",
            "type": "Array<FallbackMessageModel>"
        },
        {
            "name": "exitMessages",
            "baseName": "exitMessages",
            "type": "Array<ExitMessageModel>"
        },
        {
            "name": "questionAnswers",
            "baseName": "questionAnswers",
            "type": "Array<QuestionAnswerModel>"
        },
        {
            "name": "latestMessages",
            "baseName": "latestMessages",
            "type": "Array<LatestMessageModel>"
        },
        {
            "name": "eventItems",
            "baseName": "eventItems",
            "type": "Array<EventItemModel>"
        },
        {
            "name": "recipes",
            "baseName": "recipes",
            "type": "Array<RecipeModel>"
        },
        {
            "name": "simpleChoices",
            "baseName": "simpleChoices",
            "type": "Array<SimpleChoiceModel>"
        },
        {
            "name": "numberRanges",
            "baseName": "numberRanges",
            "type": "Array<NumberRangeModel>"
        },
        {
            "name": "customRequests",
            "baseName": "customRequests",
            "type": "Array<CustomRequestModel>"
        },
        {
            "name": "contentItems",
            "baseName": "contentItems",
            "type": "Array<GenericContentModel>"
        }    ];

    static getAttributeTypeMap() {
        return ParentContentContainerModel.attributeTypeMap;
    }
}

export class PasswordResetModel {
    'id'?: string;
    'createdDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return PasswordResetModel.attributeTypeMap;
    }
}

export class ProcessedLanguage {
    'intent'?: string;
    'intentDisplayName'?: string;
    'slots'?: { [key: string]: string; };
    'utteranceMatched'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "intent",
            "baseName": "intent",
            "type": "string"
        },
        {
            "name": "intentDisplayName",
            "baseName": "intentDisplayName",
            "type": "string"
        },
        {
            "name": "slots",
            "baseName": "slots",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "utteranceMatched",
            "baseName": "utteranceMatched",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ProcessedLanguage.attributeTypeMap;
    }
}

export class QuestionAnswerExportModel {
    'id'?: string;
    'applicationId'?: string;
    'applicationFeatureId'?: string;
    'isLive'?: boolean;
    'title'?: string;
    'startDate'?: Date;
    'endDate'?: Date;
    'responses'?: Array<AnswerModel>;
    'questionSet'?: Array<QuestionModel>;
    'hits'?: number;
    'modifiedDate'?: Date;
    'createdDate'?: Date;
    'requiresParent'?: boolean;
    'isComplete'?: boolean;
    'createdFromId'?: string;
    'languages'?: Array<LanguageModel>;
    'questionAnswerWebhooks'?: Array<QuestionAnswerWebhookModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<AnswerModel>"
        },
        {
            "name": "questionSet",
            "baseName": "questionSet",
            "type": "Array<QuestionModel>"
        },
        {
            "name": "hits",
            "baseName": "hits",
            "type": "number"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "isComplete",
            "baseName": "isComplete",
            "type": "boolean"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        },
        {
            "name": "questionAnswerWebhooks",
            "baseName": "questionAnswerWebhooks",
            "type": "Array<QuestionAnswerWebhookModel>"
        }    ];

    static getAttributeTypeMap() {
        return QuestionAnswerExportModel.attributeTypeMap;
    }
}

export class QuestionAnswerModel {
    'id'?: string;
    'applicationId'?: string;
    'applicationFeatureId'?: string;
    'isLive'?: boolean;
    'title'?: string;
    'startDate'?: Date;
    'endDate'?: Date;
    'responses'?: Array<AnswerModel>;
    'questionSet'?: Array<QuestionModel>;
    'hits'?: number;
    'modifiedDate'?: Date;
    'createdDate'?: Date;
    'requiresParent'?: boolean;
    'isComplete'?: boolean;
    'createdFromId'?: string;
    'languages'?: Array<LanguageModel>;
    'questionAnswerWebhooks'?: Array<QuestionAnswerWebhookModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<AnswerModel>"
        },
        {
            "name": "questionSet",
            "baseName": "questionSet",
            "type": "Array<QuestionModel>"
        },
        {
            "name": "hits",
            "baseName": "hits",
            "type": "number"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "isComplete",
            "baseName": "isComplete",
            "type": "boolean"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        },
        {
            "name": "questionAnswerWebhooks",
            "baseName": "questionAnswerWebhooks",
            "type": "Array<QuestionAnswerWebhookModel>"
        }    ];

    static getAttributeTypeMap() {
        return QuestionAnswerModel.attributeTypeMap;
    }
}

export class QuestionAnswerWebhookModel {
    'id'?: string;
    'questionAnswerId'?: string;
    'webhook'?: WebhookModel;
    'parameterValues'?: Array<WebhookParameterValueModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "questionAnswerId",
            "baseName": "questionAnswerId",
            "type": "string"
        },
        {
            "name": "webhook",
            "baseName": "webhook",
            "type": "WebhookModel"
        },
        {
            "name": "parameterValues",
            "baseName": "parameterValues",
            "type": "Array<WebhookParameterValueModel>"
        }    ];

    static getAttributeTypeMap() {
        return QuestionAnswerWebhookModel.attributeTypeMap;
    }
}

export class QuestionModel {
    'id'?: string;
    'content'?: string;
    'applicationId'?: string;
    'applicationModuleId'?: string;
    'questionAnswerId'?: string;
    'isLive'?: boolean;
    'isComplete'?: boolean;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;
    'requiredPhrases'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationModuleId",
            "baseName": "applicationModuleId",
            "type": "string"
        },
        {
            "name": "questionAnswerId",
            "baseName": "questionAnswerId",
            "type": "string"
        },
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        },
        {
            "name": "isComplete",
            "baseName": "isComplete",
            "type": "boolean"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        },
        {
            "name": "requiredPhrases",
            "baseName": "requiredPhrases",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return QuestionModel.attributeTypeMap;
    }
}

export class QueuedInteractionModelUpdate {
    'createdDate'?: Date;
    'platform'?: string;
    'applicationId'?: string;
    'locale'?: string;
    'id'?: string;
    'retryCount'?: number;
    'actions'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "platform",
            "baseName": "platform",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "locale",
            "baseName": "locale",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "retryCount",
            "baseName": "retryCount",
            "type": "number"
        },
        {
            "name": "actions",
            "baseName": "actions",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return QueuedInteractionModelUpdate.attributeTypeMap;
    }
}

export class RecipeExportModel {
    'id'?: string;
    'applicationId'?: string;
    'applicationFeatureId'?: string;
    'title'?: string;
    'hits'?: number;
    'isLive'?: boolean;
    'applicationModuleId'?: string;
    'recipeName'?: string;
    'keywords'?: string;
    'description'?: string;
    'mealType'?: string;
    'servings'?: string;
    'totalTime'?: string;
    'calories'?: number;
    'createdDate'?: Date;
    'modifiedDate'?: Date;
    'smallImage'?: MediaItemModel;
    'largeImage'?: MediaItemModel;
    'backgroundImage'?: MediaItemModel;
    'audio'?: MediaItemModel;
    'video'?: MediaItemModel;
    'mediaResponseContainer'?: MediaResponseContainerModel;
    'content'?: string;
    'ingredients'?: Array<RecipeIngredientModel>;
    'steps'?: Array<RecipeStepModel>;
    'recipeWebhooks'?: Array<RecipeWebhookModel>;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'mediaResponseContainerId'?: string;
    'requiresParent'?: boolean;
    'isComplete'?: boolean;
    'createdFromId'?: string;
    'languages'?: Array<LanguageModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "hits",
            "baseName": "hits",
            "type": "number"
        },
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        },
        {
            "name": "applicationModuleId",
            "baseName": "applicationModuleId",
            "type": "string"
        },
        {
            "name": "recipeName",
            "baseName": "recipeName",
            "type": "string"
        },
        {
            "name": "keywords",
            "baseName": "keywords",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "mealType",
            "baseName": "mealType",
            "type": "string"
        },
        {
            "name": "servings",
            "baseName": "servings",
            "type": "string"
        },
        {
            "name": "totalTime",
            "baseName": "totalTime",
            "type": "string"
        },
        {
            "name": "calories",
            "baseName": "calories",
            "type": "number"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "smallImage",
            "baseName": "smallImage",
            "type": "MediaItemModel"
        },
        {
            "name": "largeImage",
            "baseName": "largeImage",
            "type": "MediaItemModel"
        },
        {
            "name": "backgroundImage",
            "baseName": "backgroundImage",
            "type": "MediaItemModel"
        },
        {
            "name": "audio",
            "baseName": "audio",
            "type": "MediaItemModel"
        },
        {
            "name": "video",
            "baseName": "video",
            "type": "MediaItemModel"
        },
        {
            "name": "mediaResponseContainer",
            "baseName": "mediaResponseContainer",
            "type": "MediaResponseContainerModel"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "ingredients",
            "baseName": "ingredients",
            "type": "Array<RecipeIngredientModel>"
        },
        {
            "name": "steps",
            "baseName": "steps",
            "type": "Array<RecipeStepModel>"
        },
        {
            "name": "recipeWebhooks",
            "baseName": "recipeWebhooks",
            "type": "Array<RecipeWebhookModel>"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "isComplete",
            "baseName": "isComplete",
            "type": "boolean"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        }    ];

    static getAttributeTypeMap() {
        return RecipeExportModel.attributeTypeMap;
    }
}

export class RecipeIngredientModel {
    'id'?: string;
    'smallImage'?: MediaItemModel;
    'largeImage'?: MediaItemModel;
    'backgroundImage'?: MediaItemModel;
    'audio'?: MediaItemModel;
    'video'?: MediaItemModel;
    'mediaResponseContainer'?: MediaResponseContainerModel;
    'content'?: string;
    'recipeId'?: string;
    'reprompt'?: RepromptModel;
    'createdDate'?: Date;
    'modifiedDate'?: Date;
    'mediaResponseContainerId'?: string;
    'repromptId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'followUpId'?: string;
    'position'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "smallImage",
            "baseName": "smallImage",
            "type": "MediaItemModel"
        },
        {
            "name": "largeImage",
            "baseName": "largeImage",
            "type": "MediaItemModel"
        },
        {
            "name": "backgroundImage",
            "baseName": "backgroundImage",
            "type": "MediaItemModel"
        },
        {
            "name": "audio",
            "baseName": "audio",
            "type": "MediaItemModel"
        },
        {
            "name": "video",
            "baseName": "video",
            "type": "MediaItemModel"
        },
        {
            "name": "mediaResponseContainer",
            "baseName": "mediaResponseContainer",
            "type": "MediaResponseContainerModel"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "recipeId",
            "baseName": "recipeId",
            "type": "string"
        },
        {
            "name": "reprompt",
            "baseName": "reprompt",
            "type": "RepromptModel"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "position",
            "baseName": "position",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return RecipeIngredientModel.attributeTypeMap;
    }
}

export class RecipeModel {
    'id'?: string;
    'applicationId'?: string;
    'applicationFeatureId'?: string;
    'title'?: string;
    'hits'?: number;
    'isLive'?: boolean;
    'applicationModuleId'?: string;
    'recipeName'?: string;
    'keywords'?: string;
    'description'?: string;
    'mealType'?: string;
    'servings'?: string;
    'totalTime'?: string;
    'calories'?: number;
    'createdDate'?: Date;
    'modifiedDate'?: Date;
    'smallImage'?: MediaItemModel;
    'largeImage'?: MediaItemModel;
    'backgroundImage'?: MediaItemModel;
    'audio'?: MediaItemModel;
    'video'?: MediaItemModel;
    'mediaResponseContainer'?: MediaResponseContainerModel;
    'content'?: string;
    'ingredients'?: Array<RecipeIngredientModel>;
    'steps'?: Array<RecipeStepModel>;
    'recipeWebhooks'?: Array<RecipeWebhookModel>;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'mediaResponseContainerId'?: string;
    'requiresParent'?: boolean;
    'isComplete'?: boolean;
    'createdFromId'?: string;
    'languages'?: Array<LanguageModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "hits",
            "baseName": "hits",
            "type": "number"
        },
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        },
        {
            "name": "applicationModuleId",
            "baseName": "applicationModuleId",
            "type": "string"
        },
        {
            "name": "recipeName",
            "baseName": "recipeName",
            "type": "string"
        },
        {
            "name": "keywords",
            "baseName": "keywords",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "mealType",
            "baseName": "mealType",
            "type": "string"
        },
        {
            "name": "servings",
            "baseName": "servings",
            "type": "string"
        },
        {
            "name": "totalTime",
            "baseName": "totalTime",
            "type": "string"
        },
        {
            "name": "calories",
            "baseName": "calories",
            "type": "number"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "smallImage",
            "baseName": "smallImage",
            "type": "MediaItemModel"
        },
        {
            "name": "largeImage",
            "baseName": "largeImage",
            "type": "MediaItemModel"
        },
        {
            "name": "backgroundImage",
            "baseName": "backgroundImage",
            "type": "MediaItemModel"
        },
        {
            "name": "audio",
            "baseName": "audio",
            "type": "MediaItemModel"
        },
        {
            "name": "video",
            "baseName": "video",
            "type": "MediaItemModel"
        },
        {
            "name": "mediaResponseContainer",
            "baseName": "mediaResponseContainer",
            "type": "MediaResponseContainerModel"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "ingredients",
            "baseName": "ingredients",
            "type": "Array<RecipeIngredientModel>"
        },
        {
            "name": "steps",
            "baseName": "steps",
            "type": "Array<RecipeStepModel>"
        },
        {
            "name": "recipeWebhooks",
            "baseName": "recipeWebhooks",
            "type": "Array<RecipeWebhookModel>"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "isComplete",
            "baseName": "isComplete",
            "type": "boolean"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        }    ];

    static getAttributeTypeMap() {
        return RecipeModel.attributeTypeMap;
    }
}

export class RecipeStepModel {
    'id'?: string;
    'smallImage'?: MediaItemModel;
    'largeImage'?: MediaItemModel;
    'backgroundImage'?: MediaItemModel;
    'audio'?: MediaItemModel;
    'video'?: MediaItemModel;
    'mediaResponseContainer'?: MediaResponseContainerModel;
    'content'?: string;
    'recipeId'?: string;
    'stepNumber'?: number;
    'reprompt'?: RepromptModel;
    'createdDate'?: Date;
    'modifiedDate'?: Date;
    'mediaResponseContainerId'?: string;
    'repromptId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'followUpId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "smallImage",
            "baseName": "smallImage",
            "type": "MediaItemModel"
        },
        {
            "name": "largeImage",
            "baseName": "largeImage",
            "type": "MediaItemModel"
        },
        {
            "name": "backgroundImage",
            "baseName": "backgroundImage",
            "type": "MediaItemModel"
        },
        {
            "name": "audio",
            "baseName": "audio",
            "type": "MediaItemModel"
        },
        {
            "name": "video",
            "baseName": "video",
            "type": "MediaItemModel"
        },
        {
            "name": "mediaResponseContainer",
            "baseName": "mediaResponseContainer",
            "type": "MediaResponseContainerModel"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "recipeId",
            "baseName": "recipeId",
            "type": "string"
        },
        {
            "name": "stepNumber",
            "baseName": "stepNumber",
            "type": "number"
        },
        {
            "name": "reprompt",
            "baseName": "reprompt",
            "type": "RepromptModel"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RecipeStepModel.attributeTypeMap;
    }
}

export class RecipeWebhookModel {
    'id'?: string;
    'recipeId'?: string;
    'webhook'?: WebhookModel;
    'parameterValues'?: Array<WebhookParameterValueModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "recipeId",
            "baseName": "recipeId",
            "type": "string"
        },
        {
            "name": "webhook",
            "baseName": "webhook",
            "type": "WebhookModel"
        },
        {
            "name": "parameterValues",
            "baseName": "parameterValues",
            "type": "Array<WebhookParameterValueModel>"
        }    ];

    static getAttributeTypeMap() {
        return RecipeWebhookModel.attributeTypeMap;
    }
}

export class RepromptModel {
    'id'?: string;
    'applicationId'?: string;
    'content'?: string;
    'name'?: string;
    'includeFollowUp'?: boolean;
    'createdFromId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "includeFollowUp",
            "baseName": "includeFollowUp",
            "type": "boolean"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RepromptModel.attributeTypeMap;
    }
}

export class RequiredPhrasesRequest {
    'phrases': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "phrases",
            "baseName": "phrases",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return RequiredPhrasesRequest.attributeTypeMap;
    }
}

export class ResetRequest {
    'email': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ResetRequest.attributeTypeMap;
    }
}

export class ResponseTemplateTypeModel {
    'id'?: string;
    'name'?: string;
    'nativeName'?: string;
    'description'?: string;
    'assistant'?: string;
    'iconUrl'?: string;
    'isDisabled'?: boolean;
    'usesVideo'?: boolean;
    'usesAudio'?: boolean;
    'usesBackgroundImage'?: boolean;
    'usesForegroundImage'?: boolean;
    'usesDisplayText'?: boolean;
    'usesDisplayTitle'?: boolean;
    'usesReadout'?: boolean;
    'usesCustomMarkup'?: boolean;
    'requiresVideo'?: boolean;
    'requiresAudio'?: boolean;
    'requiresBackgroundImage'?: boolean;
    'requiresForegroundImage'?: boolean;
    'requiresDisplayText'?: boolean;
    'requiresDisplayTitle'?: boolean;
    'requiresReadout'?: boolean;
    'requiresCustomMarkup'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "nativeName",
            "baseName": "nativeName",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "assistant",
            "baseName": "assistant",
            "type": "string"
        },
        {
            "name": "iconUrl",
            "baseName": "iconUrl",
            "type": "string"
        },
        {
            "name": "isDisabled",
            "baseName": "isDisabled",
            "type": "boolean"
        },
        {
            "name": "usesVideo",
            "baseName": "usesVideo",
            "type": "boolean"
        },
        {
            "name": "usesAudio",
            "baseName": "usesAudio",
            "type": "boolean"
        },
        {
            "name": "usesBackgroundImage",
            "baseName": "usesBackgroundImage",
            "type": "boolean"
        },
        {
            "name": "usesForegroundImage",
            "baseName": "usesForegroundImage",
            "type": "boolean"
        },
        {
            "name": "usesDisplayText",
            "baseName": "usesDisplayText",
            "type": "boolean"
        },
        {
            "name": "usesDisplayTitle",
            "baseName": "usesDisplayTitle",
            "type": "boolean"
        },
        {
            "name": "usesReadout",
            "baseName": "usesReadout",
            "type": "boolean"
        },
        {
            "name": "usesCustomMarkup",
            "baseName": "usesCustomMarkup",
            "type": "boolean"
        },
        {
            "name": "requiresVideo",
            "baseName": "requiresVideo",
            "type": "boolean"
        },
        {
            "name": "requiresAudio",
            "baseName": "requiresAudio",
            "type": "boolean"
        },
        {
            "name": "requiresBackgroundImage",
            "baseName": "requiresBackgroundImage",
            "type": "boolean"
        },
        {
            "name": "requiresForegroundImage",
            "baseName": "requiresForegroundImage",
            "type": "boolean"
        },
        {
            "name": "requiresDisplayText",
            "baseName": "requiresDisplayText",
            "type": "boolean"
        },
        {
            "name": "requiresDisplayTitle",
            "baseName": "requiresDisplayTitle",
            "type": "boolean"
        },
        {
            "name": "requiresReadout",
            "baseName": "requiresReadout",
            "type": "boolean"
        },
        {
            "name": "requiresCustomMarkup",
            "baseName": "requiresCustomMarkup",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ResponseTemplateTypeModel.attributeTypeMap;
    }
}

export class SharedReferencesExportModel {
    'mediaItems'?: Array<MediaItemModel>;
    'mediaResponses'?: Array<MediaResponseModel>;
    'mediaResponseContainers'?: Array<MediaResponseContainerModel>;
    'followUps'?: Array<FollowUpModel>;
    'reprompts'?: Array<RepromptModel>;
    'webhookParameters'?: Array<WebhookParameterModel>;
    'webhooks'?: Array<WebhookModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "mediaItems",
            "baseName": "mediaItems",
            "type": "Array<MediaItemModel>"
        },
        {
            "name": "mediaResponses",
            "baseName": "mediaResponses",
            "type": "Array<MediaResponseModel>"
        },
        {
            "name": "mediaResponseContainers",
            "baseName": "mediaResponseContainers",
            "type": "Array<MediaResponseContainerModel>"
        },
        {
            "name": "followUps",
            "baseName": "followUps",
            "type": "Array<FollowUpModel>"
        },
        {
            "name": "reprompts",
            "baseName": "reprompts",
            "type": "Array<RepromptModel>"
        },
        {
            "name": "webhookParameters",
            "baseName": "webhookParameters",
            "type": "Array<WebhookParameterModel>"
        },
        {
            "name": "webhooks",
            "baseName": "webhooks",
            "type": "Array<WebhookModel>"
        }    ];

    static getAttributeTypeMap() {
        return SharedReferencesExportModel.attributeTypeMap;
    }
}

export class SimpleChoiceExportModel {
    'id'?: string;
    'applicationId'?: string;
    'applicationFeatureId'?: string;
    'title'?: string;
    'isLive'?: boolean;
    'applicationModuleId'?: string;
    'responses'?: Array<SimpleChoiceResponseModel>;
    'hits'?: number;
    'modifiedDate'?: Date;
    'createdDate'?: Date;
    'choiceType'?: SimpleChoiceExportModel.ChoiceTypeEnum;
    'requiresParent'?: boolean;
    'isComplete'?: boolean;
    'simpleChoiceWebhooks'?: Array<SimpleChoiceWebhookModel>;
    'languages'?: Array<LanguageModel>;
    'createdFromId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        },
        {
            "name": "applicationModuleId",
            "baseName": "applicationModuleId",
            "type": "string"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<SimpleChoiceResponseModel>"
        },
        {
            "name": "hits",
            "baseName": "hits",
            "type": "number"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "choiceType",
            "baseName": "choiceType",
            "type": "SimpleChoiceExportModel.ChoiceTypeEnum"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "isComplete",
            "baseName": "isComplete",
            "type": "boolean"
        },
        {
            "name": "simpleChoiceWebhooks",
            "baseName": "simpleChoiceWebhooks",
            "type": "Array<SimpleChoiceWebhookModel>"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SimpleChoiceExportModel.attributeTypeMap;
    }
}

export namespace SimpleChoiceExportModel {
    export enum ChoiceTypeEnum {
        Yes = <any> 'Yes',
        No = <any> 'No',
        Maybe = <any> 'Maybe'
    }
}
export class SimpleChoiceModel {
    'id'?: string;
    'applicationId'?: string;
    'applicationFeatureId'?: string;
    'title'?: string;
    'isLive'?: boolean;
    'applicationModuleId'?: string;
    'responses'?: Array<SimpleChoiceResponseModel>;
    'hits'?: number;
    'modifiedDate'?: Date;
    'createdDate'?: Date;
    'choiceType'?: SimpleChoiceModel.ChoiceTypeEnum;
    'requiresParent'?: boolean;
    'isComplete'?: boolean;
    'simpleChoiceWebhooks'?: Array<SimpleChoiceWebhookModel>;
    'languages'?: Array<LanguageModel>;
    'createdFromId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        },
        {
            "name": "applicationModuleId",
            "baseName": "applicationModuleId",
            "type": "string"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<SimpleChoiceResponseModel>"
        },
        {
            "name": "hits",
            "baseName": "hits",
            "type": "number"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "choiceType",
            "baseName": "choiceType",
            "type": "SimpleChoiceModel.ChoiceTypeEnum"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "isComplete",
            "baseName": "isComplete",
            "type": "boolean"
        },
        {
            "name": "simpleChoiceWebhooks",
            "baseName": "simpleChoiceWebhooks",
            "type": "Array<SimpleChoiceWebhookModel>"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SimpleChoiceModel.attributeTypeMap;
    }
}

export namespace SimpleChoiceModel {
    export enum ChoiceTypeEnum {
        Yes = <any> 'Yes',
        No = <any> 'No',
        Maybe = <any> 'Maybe'
    }
}
export class SimpleChoiceResponseModel {
    'id'?: string;
    'content'?: string;
    'simpleChoiceId'?: string;
    'smallImage'?: MediaItemModel;
    'largeImage'?: MediaItemModel;
    'backgroundImage'?: MediaItemModel;
    'audio'?: MediaItemModel;
    'video'?: MediaItemModel;
    'mediaResponseContainer'?: MediaResponseContainerModel;
    'reprompt'?: RepromptModel;
    'followUp'?: FollowUpModel;
    'createdDate'?: Date;
    'modifiedDate'?: Date;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'followUpId'?: string;
    'repromptId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "simpleChoiceId",
            "baseName": "simpleChoiceId",
            "type": "string"
        },
        {
            "name": "smallImage",
            "baseName": "smallImage",
            "type": "MediaItemModel"
        },
        {
            "name": "largeImage",
            "baseName": "largeImage",
            "type": "MediaItemModel"
        },
        {
            "name": "backgroundImage",
            "baseName": "backgroundImage",
            "type": "MediaItemModel"
        },
        {
            "name": "audio",
            "baseName": "audio",
            "type": "MediaItemModel"
        },
        {
            "name": "video",
            "baseName": "video",
            "type": "MediaItemModel"
        },
        {
            "name": "mediaResponseContainer",
            "baseName": "mediaResponseContainer",
            "type": "MediaResponseContainerModel"
        },
        {
            "name": "reprompt",
            "baseName": "reprompt",
            "type": "RepromptModel"
        },
        {
            "name": "followUp",
            "baseName": "followUp",
            "type": "FollowUpModel"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SimpleChoiceResponseModel.attributeTypeMap;
    }
}

export class SimpleChoiceWebhookModel {
    'id'?: string;
    'simpleChoiceId'?: string;
    'webhook'?: WebhookModel;
    'parameterValues'?: Array<WebhookParameterValueModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "simpleChoiceId",
            "baseName": "simpleChoiceId",
            "type": "string"
        },
        {
            "name": "webhook",
            "baseName": "webhook",
            "type": "WebhookModel"
        },
        {
            "name": "parameterValues",
            "baseName": "parameterValues",
            "type": "Array<WebhookParameterValueModel>"
        }    ];

    static getAttributeTypeMap() {
        return SimpleChoiceWebhookModel.attributeTypeMap;
    }
}

export class SingleSignOnRequest {
    'clientId': string;
    'clientSecret': string;
    'email': string;
    'loginCompleteUrl': string;
    'firstName'?: string;
    'lastName'?: string;
    'agreedToTerms'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "clientId",
            "baseName": "clientId",
            "type": "string"
        },
        {
            "name": "clientSecret",
            "baseName": "clientSecret",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "loginCompleteUrl",
            "baseName": "loginCompleteUrl",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "agreedToTerms",
            "baseName": "agreedToTerms",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return SingleSignOnRequest.attributeTypeMap;
    }
}

export class SingleSignOnResponse {
    'redirectUrl'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "redirectUrl",
            "baseName": "redirectUrl",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SingleSignOnResponse.attributeTypeMap;
    }
}

export class SkillSummary {
    'lastUpdated'?: Date;
    'nameByLocale'?: { [key: string]: string; };
    'stage'?: SkillSummary.StageEnum;
    'apis'?: Array<string>;
    'publicationStatus'?: SkillSummary.PublicationStatusEnum;
    'skillId'?: string;
    'links'?: { [key: string]: SkillSummaryLink; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "lastUpdated",
            "baseName": "lastUpdated",
            "type": "Date"
        },
        {
            "name": "nameByLocale",
            "baseName": "nameByLocale",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "stage",
            "baseName": "stage",
            "type": "SkillSummary.StageEnum"
        },
        {
            "name": "apis",
            "baseName": "apis",
            "type": "Array<string>"
        },
        {
            "name": "publicationStatus",
            "baseName": "publicationStatus",
            "type": "SkillSummary.PublicationStatusEnum"
        },
        {
            "name": "skillId",
            "baseName": "skillId",
            "type": "string"
        },
        {
            "name": "links",
            "baseName": "_links",
            "type": "{ [key: string]: SkillSummaryLink; }"
        }    ];

    static getAttributeTypeMap() {
        return SkillSummary.attributeTypeMap;
    }
}

export namespace SkillSummary {
    export enum StageEnum {
        Development = <any> 'development',
        Live = <any> 'live'
    }
    export enum PublicationStatusEnum {
        DEVELOPMENT = <any> 'DEVELOPMENT',
        CERTIFICATION = <any> 'CERTIFICATION',
        PUBLISHED = <any> 'PUBLISHED',
        SUPPRESSED = <any> 'SUPPRESSED',
        PULLED = <any> 'PULLED',
        HIDDEN = <any> 'HIDDEN',
        REMOVED = <any> 'REMOVED'
    }
}
export class SkillSummaryLink {
    'href'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "href",
            "baseName": "href",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SkillSummaryLink.attributeTypeMap;
    }
}

export class Slot {
    'name'?: string;
    'required'?: boolean;
    'type'?: { [key: string]: string; };
    'isNonIsolatable'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "required",
            "baseName": "required",
            "type": "boolean"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "isNonIsolatable",
            "baseName": "isNonIsolatable",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return Slot.attributeTypeMap;
    }
}

export class SpeechOutput {
    'rootElementType'?: string;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "rootElementType",
            "baseName": "rootElementType",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SpeechOutput.attributeTypeMap;
    }
}

export class SsmlAttribute {
    'name'?: string;
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SsmlAttribute.attributeTypeMap;
    }
}

export class SsmlElement {
    'id'?: string;
    'name'?: string;
    'attributes'?: Array<SsmlAttribute>;
    'children'?: Array<SsmlElement>;
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "Array<SsmlAttribute>"
        },
        {
            "name": "children",
            "baseName": "children",
            "type": "Array<SsmlElement>"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SsmlElement.attributeTypeMap;
    }
}

export class SsmlRequest {
    'ssml': string;
    'locale'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "ssml",
            "baseName": "ssml",
            "type": "string"
        },
        {
            "name": "locale",
            "baseName": "locale",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return SsmlRequest.attributeTypeMap;
    }
}

export class SubscriptionModel {
    'id'?: string;
    'organizationId'?: string;
    'subscriptionTypeId'?: string;
    'startDate'?: Date;
    'expirationDate'?: Date;
    'subscriptionType'?: SubscriptionTypeModel;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "subscriptionTypeId",
            "baseName": "subscriptionTypeId",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "expirationDate",
            "baseName": "expirationDate",
            "type": "Date"
        },
        {
            "name": "subscriptionType",
            "baseName": "subscriptionType",
            "type": "SubscriptionTypeModel"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionModel.attributeTypeMap;
    }
}

export class SubscriptionTypeModel {
    'id'?: string;
    'name'?: string;
    'description'?: string;
    'maxApps'?: number;
    'maxMembers'?: number;
    'maxSandboxes'?: number;
    'maxRequests'?: number;
    'maxFileUploadMegabytes'?: number;
    'length'?: string;
    'isCustom'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "maxApps",
            "baseName": "maxApps",
            "type": "number"
        },
        {
            "name": "maxMembers",
            "baseName": "maxMembers",
            "type": "number"
        },
        {
            "name": "maxSandboxes",
            "baseName": "maxSandboxes",
            "type": "number"
        },
        {
            "name": "maxRequests",
            "baseName": "maxRequests",
            "type": "number"
        },
        {
            "name": "maxFileUploadMegabytes",
            "baseName": "maxFileUploadMegabytes",
            "type": "number"
        },
        {
            "name": "length",
            "baseName": "length",
            "type": "string"
        },
        {
            "name": "isCustom",
            "baseName": "isCustom",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return SubscriptionTypeModel.attributeTypeMap;
    }
}

export class TemplateConfigurationModel {
    'id'?: string;
    'createdDate'?: Date;
    'modifiedDate'?: Date;
    'templateApplicationId'?: string;
    'templateFormId'?: string;
    'isPublic'?: boolean;
    'isDisabled'?: boolean;
    'name': string;
    'description': string;
    'imageUrl'?: string;
    'organizationId': string;
    'templateForm'?: TemplateFormModel;
    'templateApplication'?: ApplicationModel;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "templateApplicationId",
            "baseName": "templateApplicationId",
            "type": "string"
        },
        {
            "name": "templateFormId",
            "baseName": "templateFormId",
            "type": "string"
        },
        {
            "name": "isPublic",
            "baseName": "isPublic",
            "type": "boolean"
        },
        {
            "name": "isDisabled",
            "baseName": "isDisabled",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "templateForm",
            "baseName": "templateForm",
            "type": "TemplateFormModel"
        },
        {
            "name": "templateApplication",
            "baseName": "templateApplication",
            "type": "ApplicationModel"
        }    ];

    static getAttributeTypeMap() {
        return TemplateConfigurationModel.attributeTypeMap;
    }
}

export class TemplateFormFieldModel {
    'id'?: string;
    'templateFormSectionId'?: string;
    'label'?: string;
    'fieldType': string;
    'placeholder'?: string;
    'defaultValue'?: string;
    'tip'?: string;
    'isRequired'?: boolean;
    'instructionsMarkdown'?: string;
    'title': string;
    'priority'?: number;
    'associatedVariable'?: string;
    'options'?: Array<TemplateFormFieldOptionModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "templateFormSectionId",
            "baseName": "templateFormSectionId",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "fieldType",
            "baseName": "fieldType",
            "type": "string"
        },
        {
            "name": "placeholder",
            "baseName": "placeholder",
            "type": "string"
        },
        {
            "name": "defaultValue",
            "baseName": "defaultValue",
            "type": "string"
        },
        {
            "name": "tip",
            "baseName": "tip",
            "type": "string"
        },
        {
            "name": "isRequired",
            "baseName": "isRequired",
            "type": "boolean"
        },
        {
            "name": "instructionsMarkdown",
            "baseName": "instructionsMarkdown",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "associatedVariable",
            "baseName": "associatedVariable",
            "type": "string"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "Array<TemplateFormFieldOptionModel>"
        }    ];

    static getAttributeTypeMap() {
        return TemplateFormFieldModel.attributeTypeMap;
    }
}

export class TemplateFormFieldOptionModel {
    'id'?: string;
    'templateFormFieldId'?: string;
    'label'?: string;
    'value'?: string;
    'priority'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "templateFormFieldId",
            "baseName": "templateFormFieldId",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return TemplateFormFieldOptionModel.attributeTypeMap;
    }
}

export class TemplateFormFieldValueModel {
    'id'?: string;
    'templateFormFieldId'?: string;
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "templateFormFieldId",
            "baseName": "templateFormFieldId",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TemplateFormFieldValueModel.attributeTypeMap;
    }
}

export class TemplateFormModel {
    'id'?: string;
    'templateConfigurationId'?: string;
    'instructionsMarkdown'?: string;
    'templateFormSections'?: Array<TemplateFormSectionModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "templateConfigurationId",
            "baseName": "templateConfigurationId",
            "type": "string"
        },
        {
            "name": "instructionsMarkdown",
            "baseName": "instructionsMarkdown",
            "type": "string"
        },
        {
            "name": "templateFormSections",
            "baseName": "templateFormSections",
            "type": "Array<TemplateFormSectionModel>"
        }    ];

    static getAttributeTypeMap() {
        return TemplateFormModel.attributeTypeMap;
    }
}

export class TemplateFormSectionModel {
    'id'?: string;
    'templateFormId'?: string;
    'instructionsMarkdown'?: string;
    'title': string;
    'priority'?: number;
    'templateFormFields'?: Array<TemplateFormFieldModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "templateFormId",
            "baseName": "templateFormId",
            "type": "string"
        },
        {
            "name": "instructionsMarkdown",
            "baseName": "instructionsMarkdown",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "number"
        },
        {
            "name": "templateFormFields",
            "baseName": "templateFormFields",
            "type": "Array<TemplateFormFieldModel>"
        }    ];

    static getAttributeTypeMap() {
        return TemplateFormSectionModel.attributeTypeMap;
    }
}

export class TemplateFormWithConfigurationModel {
    'id'?: string;
    'templateConfigurationId'?: string;
    'templateConfiguration'?: TemplateConfigurationModel;
    'templateFormSections'?: Array<TemplateFormSectionModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "templateConfigurationId",
            "baseName": "templateConfigurationId",
            "type": "string"
        },
        {
            "name": "templateConfiguration",
            "baseName": "templateConfiguration",
            "type": "TemplateConfigurationModel"
        },
        {
            "name": "templateFormSections",
            "baseName": "templateFormSections",
            "type": "Array<TemplateFormSectionModel>"
        }    ];

    static getAttributeTypeMap() {
        return TemplateFormWithConfigurationModel.attributeTypeMap;
    }
}

export class TermModel {
    'id'?: string;
    'createdDate'?: Date;
    'url'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TermModel.attributeTypeMap;
    }
}

export class ToggleLiveRequest {
    'isLive': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ToggleLiveRequest.attributeTypeMap;
    }
}

export class ToggleTemplateRequest {
    'isTemplate': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isTemplate",
            "baseName": "isTemplate",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ToggleTemplateRequest.attributeTypeMap;
    }
}

export class TokenResponse {
    'id'?: string;
    'userName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "userName",
            "baseName": "userName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TokenResponse.attributeTypeMap;
    }
}

export class UpdateAnswerRequest {
    'answerId'?: string;
    'content': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "answerId",
            "baseName": "answerId",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateAnswerRequest.attributeTypeMap;
    }
}

export class UpdateApplicationFeatureRequest {
    'name': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateApplicationFeatureRequest.attributeTypeMap;
    }
}

export class UpdateApplicationInformationByLanguageRequest {
    'languageId'?: string;
    'name'?: string;
    'shortDescription'?: string;
    'description'?: string;
    'keywords'?: string;
    'invocationPhrase'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "languageId",
            "baseName": "languageId",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "shortDescription",
            "baseName": "shortDescription",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "keywords",
            "baseName": "keywords",
            "type": "string"
        },
        {
            "name": "invocationPhrase",
            "baseName": "invocationPhrase",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateApplicationInformationByLanguageRequest.attributeTypeMap;
    }
}

export class UpdateApplicationModuleRequest {
    'name': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateApplicationModuleRequest.attributeTypeMap;
    }
}

export class UpdateApplicationRequest {
    'name'?: string;
    'shortDescription'?: string;
    'description'?: string;
    'keywords'?: string;
    'invocationPhrase'?: string;
    'imageItemId'?: string;
    'applicationInformationItems'?: Array<UpdateApplicationInformationByLanguageRequest>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "shortDescription",
            "baseName": "shortDescription",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "keywords",
            "baseName": "keywords",
            "type": "string"
        },
        {
            "name": "invocationPhrase",
            "baseName": "invocationPhrase",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "applicationInformationItems",
            "baseName": "applicationInformationItems",
            "type": "Array<UpdateApplicationInformationByLanguageRequest>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateApplicationRequest.attributeTypeMap;
    }
}

export class UpdateAppliedApplicationTemplateFormRequest {
    'templateFormFieldValues'?: Array<TemplateFormFieldValueModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "templateFormFieldValues",
            "baseName": "templateFormFieldValues",
            "type": "Array<TemplateFormFieldValueModel>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateAppliedApplicationTemplateFormRequest.attributeTypeMap;
    }
}

export class UpdateBulkMediaResponseContainerRequest {
    'additionalMediaItemIds': Array<string>;
    'responses': Array<UpdateMediaResponseRequest>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "additionalMediaItemIds",
            "baseName": "additionalMediaItemIds",
            "type": "Array<string>"
        },
        {
            "name": "responses",
            "baseName": "responses",
            "type": "Array<UpdateMediaResponseRequest>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateBulkMediaResponseContainerRequest.attributeTypeMap;
    }
}

export class UpdateChildContentContainerRequest {
    'isLimitedToChildren'?: boolean;
    'applicationId'?: string;
    'questionAnswerIds'?: Array<string>;
    'latestMessageIds'?: Array<string>;
    'eventItemIds'?: Array<string>;
    'recipeIds'?: Array<string>;
    'simpleChoiceIds'?: Array<string>;
    'numberRangeIds'?: Array<string>;
    'customRequestIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isLimitedToChildren",
            "baseName": "isLimitedToChildren",
            "type": "boolean"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "questionAnswerIds",
            "baseName": "questionAnswerIds",
            "type": "Array<string>"
        },
        {
            "name": "latestMessageIds",
            "baseName": "latestMessageIds",
            "type": "Array<string>"
        },
        {
            "name": "eventItemIds",
            "baseName": "eventItemIds",
            "type": "Array<string>"
        },
        {
            "name": "recipeIds",
            "baseName": "recipeIds",
            "type": "Array<string>"
        },
        {
            "name": "simpleChoiceIds",
            "baseName": "simpleChoiceIds",
            "type": "Array<string>"
        },
        {
            "name": "numberRangeIds",
            "baseName": "numberRangeIds",
            "type": "Array<string>"
        },
        {
            "name": "customRequestIds",
            "baseName": "customRequestIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateChildContentContainerRequest.attributeTypeMap;
    }
}

export class UpdateCustomRequestRequest {
    'title'?: string;
    'requestTypes'?: string;
    'requestNames'?: string;
    'platformFilter'?: string;
    'startDate'?: Date;
    'endDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "requestTypes",
            "baseName": "requestTypes",
            "type": "string"
        },
        {
            "name": "requestNames",
            "baseName": "requestNames",
            "type": "string"
        },
        {
            "name": "platformFilter",
            "baseName": "platformFilter",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return UpdateCustomRequestRequest.attributeTypeMap;
    }
}

export class UpdateCustomRequestResponseRequest {
    'content': string;
    'responseId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "responseId",
            "baseName": "responseId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateCustomRequestResponseRequest.attributeTypeMap;
    }
}

export class UpdateEventResponseRequest {
    'id'?: string;
    'content': string;
    'eventQueryType'?: UpdateEventResponseRequest.EventQueryTypeEnum;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "eventQueryType",
            "baseName": "eventQueryType",
            "type": "UpdateEventResponseRequest.EventQueryTypeEnum"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateEventResponseRequest.attributeTypeMap;
    }
}

export namespace UpdateEventResponseRequest {
    export enum EventQueryTypeEnum {
        General = <any> 'General',
        Location = <any> 'Location',
        StartDate = <any> 'StartDate',
        Status = <any> 'Status'
    }
}
export class UpdateExitMessageRequest {
    'content': string;
    'title': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateExitMessageRequest.attributeTypeMap;
    }
}

export class UpdateExitMessageStubRequest {
    'content'?: string;
    'title': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateExitMessageStubRequest.attributeTypeMap;
    }
}

export class UpdateFallbackMessageRequest {
    'content': string;
    'title': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'categoryId': string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "categoryId",
            "baseName": "categoryId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateFallbackMessageRequest.attributeTypeMap;
    }
}

export class UpdateFallbackMessageStubRequest {
    'content'?: string;
    'title': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'categoryId': string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "categoryId",
            "baseName": "categoryId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateFallbackMessageStubRequest.attributeTypeMap;
    }
}

export class UpdateFollowUpHintRequest {
    'id'?: string;
    'content': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateFollowUpHintRequest.attributeTypeMap;
    }
}

export class UpdateFollowUpRequest {
    'id': string;
    'content'?: string;
    'name'?: string;
    'followUpHints'?: Array<UpdateFollowUpHintRequest>;
    'childContentContainer'?: UpdateChildContentContainerRequest;
    'fallbackMessageId'?: string;
    'helpMessageId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "followUpHints",
            "baseName": "followUpHints",
            "type": "Array<UpdateFollowUpHintRequest>"
        },
        {
            "name": "childContentContainer",
            "baseName": "childContentContainer",
            "type": "UpdateChildContentContainerRequest"
        },
        {
            "name": "fallbackMessageId",
            "baseName": "fallbackMessageId",
            "type": "string"
        },
        {
            "name": "helpMessageId",
            "baseName": "helpMessageId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateFollowUpRequest.attributeTypeMap;
    }
}

export class UpdateHelpMessageRequest {
    'content': string;
    'title': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateHelpMessageRequest.attributeTypeMap;
    }
}

export class UpdateHelpMessageStubRequest {
    'content'?: string;
    'title': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateHelpMessageStubRequest.attributeTypeMap;
    }
}

export class UpdateIngredientRequest {
    'id'?: string;
    'content': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateIngredientRequest.attributeTypeMap;
    }
}

export class UpdateLatestMessageRequest {
    'title'?: string;
    'category'?: string;
    'startDate'?: Date;
    'endDate'?: Date;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        }    ];

    static getAttributeTypeMap() {
        return UpdateLatestMessageRequest.attributeTypeMap;
    }
}

export class UpdateLatestMessageResponseRequest {
    'content': string;
    'responseId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "responseId",
            "baseName": "responseId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateLatestMessageResponseRequest.attributeTypeMap;
    }
}

export class UpdateMediaItemRequest {
    'url'?: string;
    'name'?: string;
    'mediaType'?: string;
    'caption'?: string;
    'fileExtension'?: string;
    'isDisabled'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "mediaType",
            "baseName": "mediaType",
            "type": "string"
        },
        {
            "name": "caption",
            "baseName": "caption",
            "type": "string"
        },
        {
            "name": "fileExtension",
            "baseName": "fileExtension",
            "type": "string"
        },
        {
            "name": "isDisabled",
            "baseName": "isDisabled",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return UpdateMediaItemRequest.attributeTypeMap;
    }
}

export class UpdateMediaResponseContainerRequest {
    'defaultResponseId': string;
    'additionalMediaItemIds': Array<string>;
    'responseIds': Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "defaultResponseId",
            "baseName": "defaultResponseId",
            "type": "string"
        },
        {
            "name": "additionalMediaItemIds",
            "baseName": "additionalMediaItemIds",
            "type": "Array<string>"
        },
        {
            "name": "responseIds",
            "baseName": "responseIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateMediaResponseContainerRequest.attributeTypeMap;
    }
}

export class UpdateMediaResponseRequest {
    'id'?: string;
    'responseTemplateTypeId': string;
    'applicationId': string;
    'displayTitle'?: string;
    'displayText'?: string;
    'readoutOverride'?: string;
    'foregroundImageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'deviceTargetId'?: string;
    'customMarkup'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "responseTemplateTypeId",
            "baseName": "responseTemplateTypeId",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "displayTitle",
            "baseName": "displayTitle",
            "type": "string"
        },
        {
            "name": "displayText",
            "baseName": "displayText",
            "type": "string"
        },
        {
            "name": "readoutOverride",
            "baseName": "readoutOverride",
            "type": "string"
        },
        {
            "name": "foregroundImageItemId",
            "baseName": "foregroundImageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "deviceTargetId",
            "baseName": "deviceTargetId",
            "type": "string"
        },
        {
            "name": "customMarkup",
            "baseName": "customMarkup",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateMediaResponseRequest.attributeTypeMap;
    }
}

export class UpdateMicrosoftAppInfoRequest {
    'botServiceName'?: string;
    'microsoftAppId'?: string;
    'microsoftAppPassword'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "botServiceName",
            "baseName": "botServiceName",
            "type": "string"
        },
        {
            "name": "microsoftAppId",
            "baseName": "microsoftAppId",
            "type": "string"
        },
        {
            "name": "microsoftAppPassword",
            "baseName": "microsoftAppPassword",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateMicrosoftAppInfoRequest.attributeTypeMap;
    }
}

export class UpdateNumberRangeRequest {
    'title'?: string;
    'minimumValue'?: number;
    'maximumValue'?: number;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "minimumValue",
            "baseName": "minimumValue",
            "type": "number"
        },
        {
            "name": "maximumValue",
            "baseName": "maximumValue",
            "type": "number"
        }    ];

    static getAttributeTypeMap() {
        return UpdateNumberRangeRequest.attributeTypeMap;
    }
}

export class UpdateNumberRangeResponseRequest {
    'content': string;
    'responseId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "responseId",
            "baseName": "responseId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateNumberRangeResponseRequest.attributeTypeMap;
    }
}

export class UpdateOrganizationRequest {
    'name': string;
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateOrganizationRequest.attributeTypeMap;
    }
}

export class UpdateQuestionRequest {
    'questionId'?: string;
    'content': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "questionId",
            "baseName": "questionId",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateQuestionRequest.attributeTypeMap;
    }
}

export class UpdateRepromptRequest {
    'id': string;
    'content': string;
    'name'?: string;
    'includeFollowUp'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "includeFollowUp",
            "baseName": "includeFollowUp",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return UpdateRepromptRequest.attributeTypeMap;
    }
}

export class UpdateResponseTemplateTypeRequest {
    'name': string;
    'nativeName': string;
    'description': string;
    'assistant': string;
    'iconUrl': string;
    'usesVideo': boolean;
    'usesAudio': boolean;
    'usesBackgroundImage': boolean;
    'usesForegroundImage': boolean;
    'usesDisplayText': boolean;
    'usesDisplayTitle': boolean;
    'usesReadout': boolean;
    'requiresVideo': boolean;
    'requiresAudio': boolean;
    'requiresBackgroundImage': boolean;
    'requiresForegroundImage': boolean;
    'requiresDisplayText': boolean;
    'requiresDisplayTitle': boolean;
    'requiresReadout': boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "nativeName",
            "baseName": "nativeName",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "assistant",
            "baseName": "assistant",
            "type": "string"
        },
        {
            "name": "iconUrl",
            "baseName": "iconUrl",
            "type": "string"
        },
        {
            "name": "usesVideo",
            "baseName": "usesVideo",
            "type": "boolean"
        },
        {
            "name": "usesAudio",
            "baseName": "usesAudio",
            "type": "boolean"
        },
        {
            "name": "usesBackgroundImage",
            "baseName": "usesBackgroundImage",
            "type": "boolean"
        },
        {
            "name": "usesForegroundImage",
            "baseName": "usesForegroundImage",
            "type": "boolean"
        },
        {
            "name": "usesDisplayText",
            "baseName": "usesDisplayText",
            "type": "boolean"
        },
        {
            "name": "usesDisplayTitle",
            "baseName": "usesDisplayTitle",
            "type": "boolean"
        },
        {
            "name": "usesReadout",
            "baseName": "usesReadout",
            "type": "boolean"
        },
        {
            "name": "requiresVideo",
            "baseName": "requiresVideo",
            "type": "boolean"
        },
        {
            "name": "requiresAudio",
            "baseName": "requiresAudio",
            "type": "boolean"
        },
        {
            "name": "requiresBackgroundImage",
            "baseName": "requiresBackgroundImage",
            "type": "boolean"
        },
        {
            "name": "requiresForegroundImage",
            "baseName": "requiresForegroundImage",
            "type": "boolean"
        },
        {
            "name": "requiresDisplayText",
            "baseName": "requiresDisplayText",
            "type": "boolean"
        },
        {
            "name": "requiresDisplayTitle",
            "baseName": "requiresDisplayTitle",
            "type": "boolean"
        },
        {
            "name": "requiresReadout",
            "baseName": "requiresReadout",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return UpdateResponseTemplateTypeRequest.attributeTypeMap;
    }
}

export class UpdateSimpleChoiceRequest {
    'title'?: string;
    'choiceType'?: UpdateSimpleChoiceRequest.ChoiceTypeEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "choiceType",
            "baseName": "choiceType",
            "type": "UpdateSimpleChoiceRequest.ChoiceTypeEnum"
        }    ];

    static getAttributeTypeMap() {
        return UpdateSimpleChoiceRequest.attributeTypeMap;
    }
}

export namespace UpdateSimpleChoiceRequest {
    export enum ChoiceTypeEnum {
        Yes = <any> 'Yes',
        No = <any> 'No',
        Maybe = <any> 'Maybe'
    }
}
export class UpdateSimpleChoiceResponseRequest {
    'content': string;
    'responseId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "responseId",
            "baseName": "responseId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateSimpleChoiceResponseRequest.attributeTypeMap;
    }
}

export class UpdateStepRequest {
    'id'?: string;
    'content': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateStepRequest.attributeTypeMap;
    }
}

export class UpdateUserRequest {
    'firstName': string;
    'lastName': string;
    'changePassword'?: string;
    'confirmPassword'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "changePassword",
            "baseName": "changePassword",
            "type": "string"
        },
        {
            "name": "confirmPassword",
            "baseName": "confirmPassword",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateUserRequest.attributeTypeMap;
    }
}

export class UpdateWebhookRequest {
    'title': string;
    'description': string;
    'url': string;
    'isPublic': boolean;
    'isDisabled': boolean;
    'webhookTypeId': string;
    'accessToken'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "isPublic",
            "baseName": "isPublic",
            "type": "boolean"
        },
        {
            "name": "isDisabled",
            "baseName": "isDisabled",
            "type": "boolean"
        },
        {
            "name": "webhookTypeId",
            "baseName": "webhookTypeId",
            "type": "string"
        },
        {
            "name": "accessToken",
            "baseName": "accessToken",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UpdateWebhookRequest.attributeTypeMap;
    }
}

export class UpdateWelcomeMessageRequest {
    'content': string;
    'title': string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateWelcomeMessageRequest.attributeTypeMap;
    }
}

export class UpdateWelcomeMessageStubRequest {
    'title': string;
    'content'?: string;
    'imageItemId'?: string;
    'backgroundImageItemId'?: string;
    'audioItemId'?: string;
    'videoItemId'?: string;
    'followUpId'?: string;
    'repromptId'?: string;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'languageIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "imageItemId",
            "baseName": "imageItemId",
            "type": "string"
        },
        {
            "name": "backgroundImageItemId",
            "baseName": "backgroundImageItemId",
            "type": "string"
        },
        {
            "name": "audioItemId",
            "baseName": "audioItemId",
            "type": "string"
        },
        {
            "name": "videoItemId",
            "baseName": "videoItemId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "languageIds",
            "baseName": "languageIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return UpdateWelcomeMessageStubRequest.attributeTypeMap;
    }
}

export class UserDefinedWebhookParameterCreateRequest {
    'key': string;
    'value': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserDefinedWebhookParameterCreateRequest.attributeTypeMap;
    }
}

export class UserDefinedWebhookParameterUpdateRequest {
    'key': string;
    'value': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "key",
            "baseName": "key",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return UserDefinedWebhookParameterUpdateRequest.attributeTypeMap;
    }
}

export class UserModel {
    'id'?: string;
    'email'?: string;
    'firstName'?: string;
    'lastName'?: string;
    'isAdmin'?: boolean;
    'imageUrl'?: string;
    'isApiUser'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "email",
            "baseName": "email",
            "type": "string"
        },
        {
            "name": "firstName",
            "baseName": "firstName",
            "type": "string"
        },
        {
            "name": "lastName",
            "baseName": "lastName",
            "type": "string"
        },
        {
            "name": "isAdmin",
            "baseName": "isAdmin",
            "type": "boolean"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "isApiUser",
            "baseName": "isApiUser",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return UserModel.attributeTypeMap;
    }
}

export class UserRoleModel {
    'id'?: string;
    'isAdmin'?: boolean;
    'canEdit'?: boolean;
    'name'?: string;
    'isCustom'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "isAdmin",
            "baseName": "isAdmin",
            "type": "boolean"
        },
        {
            "name": "canEdit",
            "baseName": "canEdit",
            "type": "boolean"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "isCustom",
            "baseName": "isCustom",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return UserRoleModel.attributeTypeMap;
    }
}

export class UserTermAgreementModel {
    'userTerms'?: Array<UserTermModel>;
    'hasAgreedToLatest'?: boolean;
    'latestTerm'?: TermModel;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "userTerms",
            "baseName": "userTerms",
            "type": "Array<UserTermModel>"
        },
        {
            "name": "hasAgreedToLatest",
            "baseName": "hasAgreedToLatest",
            "type": "boolean"
        },
        {
            "name": "latestTerm",
            "baseName": "latestTerm",
            "type": "TermModel"
        }    ];

    static getAttributeTypeMap() {
        return UserTermAgreementModel.attributeTypeMap;
    }
}

export class UserTermModel {
    'term'?: TermModel;
    'id'?: string;
    'agreed'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "term",
            "baseName": "term",
            "type": "TermModel"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "agreed",
            "baseName": "agreed",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return UserTermModel.attributeTypeMap;
    }
}

export class UserVoicifyNotificationModel {
    'isRead'?: boolean;
    'id'?: string;
    'title': string;
    'subtitle': string;
    'markdown': string;
    'notificationType': string;
    'isDisabled'?: boolean;
    'enforceRead'?: boolean;
    'isSystemWide'?: boolean;
    'imageUrl'?: string;
    'expirationDate'?: Date;
    'startDate'?: Date;
    'priority'?: UserVoicifyNotificationModel.PriorityEnum;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "isRead",
            "baseName": "isRead",
            "type": "boolean"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "subtitle",
            "baseName": "subtitle",
            "type": "string"
        },
        {
            "name": "markdown",
            "baseName": "markdown",
            "type": "string"
        },
        {
            "name": "notificationType",
            "baseName": "notificationType",
            "type": "string"
        },
        {
            "name": "isDisabled",
            "baseName": "isDisabled",
            "type": "boolean"
        },
        {
            "name": "enforceRead",
            "baseName": "enforceRead",
            "type": "boolean"
        },
        {
            "name": "isSystemWide",
            "baseName": "isSystemWide",
            "type": "boolean"
        },
        {
            "name": "imageUrl",
            "baseName": "imageUrl",
            "type": "string"
        },
        {
            "name": "expirationDate",
            "baseName": "expirationDate",
            "type": "Date"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "priority",
            "baseName": "priority",
            "type": "UserVoicifyNotificationModel.PriorityEnum"
        }    ];

    static getAttributeTypeMap() {
        return UserVoicifyNotificationModel.attributeTypeMap;
    }
}

export namespace UserVoicifyNotificationModel {
    export enum PriorityEnum {
        Low = <any> 'Low',
        Medium = <any> 'Medium',
        High = <any> 'High',
        Urgent = <any> 'Urgent'
    }
}
export class WebhookModel {
    'id'?: string;
    'title'?: string;
    'description'?: string;
    'url'?: string;
    'webhookType'?: WebhookTypeModel;
    'organizationId'?: string;
    'isPublic'?: boolean;
    'isDisabled'?: boolean;
    'accessToken'?: string;
    'createdFromId'?: string;
    'parameters'?: Array<WebhookParameterModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "webhookType",
            "baseName": "webhookType",
            "type": "WebhookTypeModel"
        },
        {
            "name": "organizationId",
            "baseName": "organizationId",
            "type": "string"
        },
        {
            "name": "isPublic",
            "baseName": "isPublic",
            "type": "boolean"
        },
        {
            "name": "isDisabled",
            "baseName": "isDisabled",
            "type": "boolean"
        },
        {
            "name": "accessToken",
            "baseName": "accessToken",
            "type": "string"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        },
        {
            "name": "parameters",
            "baseName": "parameters",
            "type": "Array<WebhookParameterModel>"
        }    ];

    static getAttributeTypeMap() {
        return WebhookModel.attributeTypeMap;
    }
}

export class WebhookParameterModel {
    'id'?: string;
    'name'?: string;
    'description'?: string;
    'webhookId'?: string;
    'createdFromId'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "webhookId",
            "baseName": "webhookId",
            "type": "string"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookParameterModel.attributeTypeMap;
    }
}

export class WebhookParameterUpdateRequest {
    'webhookParameterInstanceId': string;
    'value': string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "webhookParameterInstanceId",
            "baseName": "webhookParameterInstanceId",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookParameterUpdateRequest.attributeTypeMap;
    }
}

export class WebhookParameterValueModel {
    'id'?: string;
    'value'?: string;
    'userDefinedKey'?: string;
    'webhookParameter'?: WebhookParameterModel;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "userDefinedKey",
            "baseName": "userDefinedKey",
            "type": "string"
        },
        {
            "name": "webhookParameter",
            "baseName": "webhookParameter",
            "type": "WebhookParameterModel"
        }    ];

    static getAttributeTypeMap() {
        return WebhookParameterValueModel.attributeTypeMap;
    }
}

export class WebhookParametersRequest {
    'values'?: { [key: string]: string; };
    'userDefinedParameters'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "values",
            "baseName": "values",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "userDefinedParameters",
            "baseName": "userDefinedParameters",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return WebhookParametersRequest.attributeTypeMap;
    }
}

export class WebhookScopeModel {
    'id'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return WebhookScopeModel.attributeTypeMap;
    }
}

export class WebhookTypeModel {
    'id'?: string;
    'typeName'?: string;
    'title'?: string;
    'description'?: string;
    'webhookScopes'?: Array<WebhookScopeModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "typeName",
            "baseName": "typeName",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "webhookScopes",
            "baseName": "webhookScopes",
            "type": "Array<WebhookScopeModel>"
        }    ];

    static getAttributeTypeMap() {
        return WebhookTypeModel.attributeTypeMap;
    }
}

export class WelcomeMessageExportModel {
    'id'?: string;
    'applicationId'?: string;
    'applicationFeatureId'?: string;
    'title'?: string;
    'isLive'?: boolean;
    'startDate'?: Date;
    'endDate'?: Date;
    'content'?: string;
    'smallImage'?: MediaItemModel;
    'largeImage'?: MediaItemModel;
    'backgroundImage'?: MediaItemModel;
    'audio'?: MediaItemModel;
    'video'?: MediaItemModel;
    'welcomeMessageWebhooks'?: Array<WelcomeMessageWebhookModel>;
    'mediaResponseContainer'?: MediaResponseContainerModel;
    'followUp'?: FollowUpModel;
    'hits'?: number;
    'reprompt'?: RepromptModel;
    'repromptId'?: string;
    'followUpId'?: string;
    'createdDate'?: Date;
    'modifiedDate'?: Date;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'isComplete'?: boolean;
    'createdFromId'?: string;
    'languages'?: Array<LanguageModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "smallImage",
            "baseName": "smallImage",
            "type": "MediaItemModel"
        },
        {
            "name": "largeImage",
            "baseName": "largeImage",
            "type": "MediaItemModel"
        },
        {
            "name": "backgroundImage",
            "baseName": "backgroundImage",
            "type": "MediaItemModel"
        },
        {
            "name": "audio",
            "baseName": "audio",
            "type": "MediaItemModel"
        },
        {
            "name": "video",
            "baseName": "video",
            "type": "MediaItemModel"
        },
        {
            "name": "welcomeMessageWebhooks",
            "baseName": "welcomeMessageWebhooks",
            "type": "Array<WelcomeMessageWebhookModel>"
        },
        {
            "name": "mediaResponseContainer",
            "baseName": "mediaResponseContainer",
            "type": "MediaResponseContainerModel"
        },
        {
            "name": "followUp",
            "baseName": "followUp",
            "type": "FollowUpModel"
        },
        {
            "name": "hits",
            "baseName": "hits",
            "type": "number"
        },
        {
            "name": "reprompt",
            "baseName": "reprompt",
            "type": "RepromptModel"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "isComplete",
            "baseName": "isComplete",
            "type": "boolean"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        }    ];

    static getAttributeTypeMap() {
        return WelcomeMessageExportModel.attributeTypeMap;
    }
}

export class WelcomeMessageModel {
    'id'?: string;
    'applicationId'?: string;
    'applicationFeatureId'?: string;
    'title'?: string;
    'isLive'?: boolean;
    'startDate'?: Date;
    'endDate'?: Date;
    'content'?: string;
    'smallImage'?: MediaItemModel;
    'largeImage'?: MediaItemModel;
    'backgroundImage'?: MediaItemModel;
    'audio'?: MediaItemModel;
    'video'?: MediaItemModel;
    'welcomeMessageWebhooks'?: Array<WelcomeMessageWebhookModel>;
    'mediaResponseContainer'?: MediaResponseContainerModel;
    'followUp'?: FollowUpModel;
    'hits'?: number;
    'reprompt'?: RepromptModel;
    'repromptId'?: string;
    'followUpId'?: string;
    'createdDate'?: Date;
    'modifiedDate'?: Date;
    'mediaResponseContainerId'?: string;
    'displayTextOverride'?: string;
    'displayTitleOverride'?: string;
    'requiresParent'?: boolean;
    'isComplete'?: boolean;
    'createdFromId'?: string;
    'languages'?: Array<LanguageModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "applicationId",
            "baseName": "applicationId",
            "type": "string"
        },
        {
            "name": "applicationFeatureId",
            "baseName": "applicationFeatureId",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "isLive",
            "baseName": "isLive",
            "type": "boolean"
        },
        {
            "name": "startDate",
            "baseName": "startDate",
            "type": "Date"
        },
        {
            "name": "endDate",
            "baseName": "endDate",
            "type": "Date"
        },
        {
            "name": "content",
            "baseName": "content",
            "type": "string"
        },
        {
            "name": "smallImage",
            "baseName": "smallImage",
            "type": "MediaItemModel"
        },
        {
            "name": "largeImage",
            "baseName": "largeImage",
            "type": "MediaItemModel"
        },
        {
            "name": "backgroundImage",
            "baseName": "backgroundImage",
            "type": "MediaItemModel"
        },
        {
            "name": "audio",
            "baseName": "audio",
            "type": "MediaItemModel"
        },
        {
            "name": "video",
            "baseName": "video",
            "type": "MediaItemModel"
        },
        {
            "name": "welcomeMessageWebhooks",
            "baseName": "welcomeMessageWebhooks",
            "type": "Array<WelcomeMessageWebhookModel>"
        },
        {
            "name": "mediaResponseContainer",
            "baseName": "mediaResponseContainer",
            "type": "MediaResponseContainerModel"
        },
        {
            "name": "followUp",
            "baseName": "followUp",
            "type": "FollowUpModel"
        },
        {
            "name": "hits",
            "baseName": "hits",
            "type": "number"
        },
        {
            "name": "reprompt",
            "baseName": "reprompt",
            "type": "RepromptModel"
        },
        {
            "name": "repromptId",
            "baseName": "repromptId",
            "type": "string"
        },
        {
            "name": "followUpId",
            "baseName": "followUpId",
            "type": "string"
        },
        {
            "name": "createdDate",
            "baseName": "createdDate",
            "type": "Date"
        },
        {
            "name": "modifiedDate",
            "baseName": "modifiedDate",
            "type": "Date"
        },
        {
            "name": "mediaResponseContainerId",
            "baseName": "mediaResponseContainerId",
            "type": "string"
        },
        {
            "name": "displayTextOverride",
            "baseName": "displayTextOverride",
            "type": "string"
        },
        {
            "name": "displayTitleOverride",
            "baseName": "displayTitleOverride",
            "type": "string"
        },
        {
            "name": "requiresParent",
            "baseName": "requiresParent",
            "type": "boolean"
        },
        {
            "name": "isComplete",
            "baseName": "isComplete",
            "type": "boolean"
        },
        {
            "name": "createdFromId",
            "baseName": "createdFromId",
            "type": "string"
        },
        {
            "name": "languages",
            "baseName": "languages",
            "type": "Array<LanguageModel>"
        }    ];

    static getAttributeTypeMap() {
        return WelcomeMessageModel.attributeTypeMap;
    }
}

export class WelcomeMessageWebhookModel {
    'id'?: string;
    'welcomeMessageId'?: string;
    'webhook'?: WebhookModel;
    'parameterValues'?: Array<WebhookParameterValueModel>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "welcomeMessageId",
            "baseName": "welcomeMessageId",
            "type": "string"
        },
        {
            "name": "webhook",
            "baseName": "webhook",
            "type": "WebhookModel"
        },
        {
            "name": "parameterValues",
            "baseName": "parameterValues",
            "type": "Array<WebhookParameterValueModel>"
        }    ];

    static getAttributeTypeMap() {
        return WelcomeMessageWebhookModel.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "ApplicationModel.AlexaFallbackSensitivityEnum": ApplicationModel.AlexaFallbackSensitivityEnum,
        "BulkUpdateSimpleChoiceRequest.ChoiceTypeEnum": BulkUpdateSimpleChoiceRequest.ChoiceTypeEnum,
        "BulkUpdateSimpleChoiceStubRequest.ChoiceTypeEnum": BulkUpdateSimpleChoiceStubRequest.ChoiceTypeEnum,
        "CreateEventResponseRequest.EventQueryTypeEnum": CreateEventResponseRequest.EventQueryTypeEnum,
        "EventResponseModel.EventQueryTypeEnum": EventResponseModel.EventQueryTypeEnum,
        "NewSimpleChoiceRequest.ChoiceTypeEnum": NewSimpleChoiceRequest.ChoiceTypeEnum,
        "NewSimpleChoiceStubRequest.ChoiceTypeEnum": NewSimpleChoiceStubRequest.ChoiceTypeEnum,
        "SimpleChoiceExportModel.ChoiceTypeEnum": SimpleChoiceExportModel.ChoiceTypeEnum,
        "SimpleChoiceModel.ChoiceTypeEnum": SimpleChoiceModel.ChoiceTypeEnum,
        "SkillSummary.StageEnum": SkillSummary.StageEnum,
        "SkillSummary.PublicationStatusEnum": SkillSummary.PublicationStatusEnum,
        "UpdateEventResponseRequest.EventQueryTypeEnum": UpdateEventResponseRequest.EventQueryTypeEnum,
        "UpdateSimpleChoiceRequest.ChoiceTypeEnum": UpdateSimpleChoiceRequest.ChoiceTypeEnum,
        "UserVoicifyNotificationModel.PriorityEnum": UserVoicifyNotificationModel.PriorityEnum,
}

let typeMap: {[index: string]: any} = {
    "AddFeatureToModuleRequest": AddFeatureToModuleRequest,
    "AddModuleToApplicationRequest": AddModuleToApplicationRequest,
    "AlexaVendor": AlexaVendor,
    "AlexaVendorResponse": AlexaVendorResponse,
    "AnswerModel": AnswerModel,
    "ApiUserModel": ApiUserModel,
    "ApplicationConversationCountModel": ApplicationConversationCountModel,
    "ApplicationFeatureExportModel": ApplicationFeatureExportModel,
    "ApplicationFeatureModel": ApplicationFeatureModel,
    "ApplicationFeatureRequestItem": ApplicationFeatureRequestItem,
    "ApplicationFeatureWebhookModel": ApplicationFeatureWebhookModel,
    "ApplicationFulfillmentEndpoints": ApplicationFulfillmentEndpoints,
    "ApplicationInformationModel": ApplicationInformationModel,
    "ApplicationMemberModel": ApplicationMemberModel,
    "ApplicationMemberRoleModel": ApplicationMemberRoleModel,
    "ApplicationModel": ApplicationModel,
    "ApplicationWebhookModel": ApplicationWebhookModel,
    "ApplicationWithFeaturesModel": ApplicationWithFeaturesModel,
    "ApplicationsByAmazonAccount": ApplicationsByAmazonAccount,
    "ApplicationsByGoogleAccount": ApplicationsByGoogleAccount,
    "ApplicationsByMicrosoftAccount": ApplicationsByMicrosoftAccount,
    "AppliedApplicationTemplateFormModel": AppliedApplicationTemplateFormModel,
    "AuthenticationResponse": AuthenticationResponse,
    "AzureBotServiceInformation": AzureBotServiceInformation,
    "AzureSubscriptionInformation": AzureSubscriptionInformation,
    "BasicDeviceTargetModel": BasicDeviceTargetModel,
    "BasicInvitationRequest": BasicInvitationRequest,
    "BulkContentRequest": BulkContentRequest,
    "BulkQuestionAnswerUpdateRequest": BulkQuestionAnswerUpdateRequest,
    "BulkQuestionAnswerUpdateStubRequest": BulkQuestionAnswerUpdateStubRequest,
    "BulkUpdateCustomRequestRequest": BulkUpdateCustomRequestRequest,
    "BulkUpdateCustomRequestStubRequest": BulkUpdateCustomRequestStubRequest,
    "BulkUpdateEventRequest": BulkUpdateEventRequest,
    "BulkUpdateEventStubRequest": BulkUpdateEventStubRequest,
    "BulkUpdateLatestMessageRequest": BulkUpdateLatestMessageRequest,
    "BulkUpdateLatestMessageStubRequest": BulkUpdateLatestMessageStubRequest,
    "BulkUpdateNumberRangeRequest": BulkUpdateNumberRangeRequest,
    "BulkUpdateNumberRangeStubRequest": BulkUpdateNumberRangeStubRequest,
    "BulkUpdateRecipeRequest": BulkUpdateRecipeRequest,
    "BulkUpdateRecipeStubRequest": BulkUpdateRecipeStubRequest,
    "BulkUpdateSimpleChoiceRequest": BulkUpdateSimpleChoiceRequest,
    "BulkUpdateSimpleChoiceStubRequest": BulkUpdateSimpleChoiceStubRequest,
    "ChangePasswordRequest": ChangePasswordRequest,
    "ChildContentContainerModel": ChildContentContainerModel,
    "CompleteTemplateFormModel": CompleteTemplateFormModel,
    "ContentRequestItem": ContentRequestItem,
    "ConversationCountModel": ConversationCountModel,
    "CreateAnswerRequest": CreateAnswerRequest,
    "CreateApplicationFeatureRequest": CreateApplicationFeatureRequest,
    "CreateApplicationFromCompletedFormsRequest": CreateApplicationFromCompletedFormsRequest,
    "CreateEventRequest": CreateEventRequest,
    "CreateEventResponseRequest": CreateEventResponseRequest,
    "CreateEventStubRequest": CreateEventStubRequest,
    "CreateFollowUpHintRequest": CreateFollowUpHintRequest,
    "CreateFollowUpRequest": CreateFollowUpRequest,
    "CreateIngredientRequest": CreateIngredientRequest,
    "CreateNewPasswordRequest": CreateNewPasswordRequest,
    "CreateQuestionRequest": CreateQuestionRequest,
    "CreateRecipeRequest": CreateRecipeRequest,
    "CreateRecipeStubRequest": CreateRecipeStubRequest,
    "CreateRepromptRequest": CreateRepromptRequest,
    "CreateStepRequest": CreateStepRequest,
    "CustomRequestExportModel": CustomRequestExportModel,
    "CustomRequestModel": CustomRequestModel,
    "CustomRequestResponseModel": CustomRequestResponseModel,
    "CustomRequestWebhookModel": CustomRequestWebhookModel,
    "DeploymentLink": DeploymentLink,
    "DeviceTargetModel": DeviceTargetModel,
    "DialogflowAgentInformation": DialogflowAgentInformation,
    "DisabledIntent": DisabledIntent,
    "EventCategoryModel": EventCategoryModel,
    "EventItemExportModel": EventItemExportModel,
    "EventItemModel": EventItemModel,
    "EventItemWebhookModel": EventItemWebhookModel,
    "EventResponseModel": EventResponseModel,
    "ExitMessageExportModel": ExitMessageExportModel,
    "ExitMessageModel": ExitMessageModel,
    "ExitMessageWebhookModel": ExitMessageWebhookModel,
    "ExportModel": ExportModel,
    "FallbackMessageCategoryModel": FallbackMessageCategoryModel,
    "FallbackMessageExportModel": FallbackMessageExportModel,
    "FallbackMessageModel": FallbackMessageModel,
    "FallbackMessageWebhookModel": FallbackMessageWebhookModel,
    "FeatureModel": FeatureModel,
    "FeatureTypeModel": FeatureTypeModel,
    "FollowUpHintModel": FollowUpHintModel,
    "FollowUpModel": FollowUpModel,
    "GenericContentModel": GenericContentModel,
    "HelpMessageExportModel": HelpMessageExportModel,
    "HelpMessageModel": HelpMessageModel,
    "HelpMessageWebhookModel": HelpMessageWebhookModel,
    "Intent": Intent,
    "IntentStatusUpdate": IntentStatusUpdate,
    "IntentUpdate": IntentUpdate,
    "InteractionModel": InteractionModel,
    "InteractionModelDeploymentResultModel": InteractionModelDeploymentResultModel,
    "InteractionModelStatus": InteractionModelStatus,
    "InteractionModelUpdate": InteractionModelUpdate,
    "InteractionModelUpdateWithReference": InteractionModelUpdateWithReference,
    "InvitationModel": InvitationModel,
    "LanguageModel": LanguageModel,
    "LatestMessageExportModel": LatestMessageExportModel,
    "LatestMessageModel": LatestMessageModel,
    "LatestMessageResponseModel": LatestMessageResponseModel,
    "LatestMessageWebhookModel": LatestMessageWebhookModel,
    "LuisAppEndpoint": LuisAppEndpoint,
    "LuisAppEndpointsContainer": LuisAppEndpointsContainer,
    "LuisApplicationInformation": LuisApplicationInformation,
    "MediaContentItems": MediaContentItems,
    "MediaItemModel": MediaItemModel,
    "MediaRelatedContentItem": MediaRelatedContentItem,
    "MediaResponseContainerModel": MediaResponseContainerModel,
    "MediaResponseModel": MediaResponseModel,
    "MemberRoleUpdateRequest": MemberRoleUpdateRequest,
    "MembershipModel": MembershipModel,
    "MicrosoftDeploymentLink": MicrosoftDeploymentLink,
    "NewApiUserRequest": NewApiUserRequest,
    "NewApplicationMemberRequest": NewApplicationMemberRequest,
    "NewApplicationRequest": NewApplicationRequest,
    "NewBulkApplicationMemberRequest": NewBulkApplicationMemberRequest,
    "NewBulkMediaResponseContainerRequest": NewBulkMediaResponseContainerRequest,
    "NewCustomRequestRequest": NewCustomRequestRequest,
    "NewCustomRequestResponseRequest": NewCustomRequestResponseRequest,
    "NewCustomRequestStubRequest": NewCustomRequestStubRequest,
    "NewExitMessageRequest": NewExitMessageRequest,
    "NewExitMessageStubRequest": NewExitMessageStubRequest,
    "NewFallbackMessageRequest": NewFallbackMessageRequest,
    "NewFallbackMessageStubRequest": NewFallbackMessageStubRequest,
    "NewHelpMessageRequest": NewHelpMessageRequest,
    "NewHelpMessageStubRequest": NewHelpMessageStubRequest,
    "NewInvitationRequest": NewInvitationRequest,
    "NewLatestMessageRequest": NewLatestMessageRequest,
    "NewLatestMessageResponseRequest": NewLatestMessageResponseRequest,
    "NewLatestMessageStubRequest": NewLatestMessageStubRequest,
    "NewLuisAppResponse": NewLuisAppResponse,
    "NewMediaItemRequest": NewMediaItemRequest,
    "NewMediaResponseContainerRequest": NewMediaResponseContainerRequest,
    "NewMediaResponseRequest": NewMediaResponseRequest,
    "NewModuleRequest": NewModuleRequest,
    "NewNumberRangeRequest": NewNumberRangeRequest,
    "NewNumberRangeResponseRequest": NewNumberRangeResponseRequest,
    "NewNumberRangeStubRequest": NewNumberRangeStubRequest,
    "NewOrganizationRequest": NewOrganizationRequest,
    "NewQuestionAnswerRequest": NewQuestionAnswerRequest,
    "NewQuestionAnswerStubRequest": NewQuestionAnswerStubRequest,
    "NewResponseTemplateTypeRequest": NewResponseTemplateTypeRequest,
    "NewSimpleChoiceRequest": NewSimpleChoiceRequest,
    "NewSimpleChoiceResponseRequest": NewSimpleChoiceResponseRequest,
    "NewSimpleChoiceStubRequest": NewSimpleChoiceStubRequest,
    "NewSkillResponse": NewSkillResponse,
    "NewUserRequest": NewUserRequest,
    "NewUserTermRequestModel": NewUserTermRequestModel,
    "NewWebhookParameterRequest": NewWebhookParameterRequest,
    "NewWebhookRequest": NewWebhookRequest,
    "NewWelcomeMessageRequest": NewWelcomeMessageRequest,
    "NewWelcomeMessageStubRequest": NewWelcomeMessageStubRequest,
    "NumberRangeExportModel": NumberRangeExportModel,
    "NumberRangeModel": NumberRangeModel,
    "NumberRangeResponseModel": NumberRangeResponseModel,
    "NumberRangeWebhookModel": NumberRangeWebhookModel,
    "OrganizationMemberModel": OrganizationMemberModel,
    "OrganizationModel": OrganizationModel,
    "ParentContentContainerModel": ParentContentContainerModel,
    "PasswordResetModel": PasswordResetModel,
    "ProcessedLanguage": ProcessedLanguage,
    "QuestionAnswerExportModel": QuestionAnswerExportModel,
    "QuestionAnswerModel": QuestionAnswerModel,
    "QuestionAnswerWebhookModel": QuestionAnswerWebhookModel,
    "QuestionModel": QuestionModel,
    "QueuedInteractionModelUpdate": QueuedInteractionModelUpdate,
    "RecipeExportModel": RecipeExportModel,
    "RecipeIngredientModel": RecipeIngredientModel,
    "RecipeModel": RecipeModel,
    "RecipeStepModel": RecipeStepModel,
    "RecipeWebhookModel": RecipeWebhookModel,
    "RepromptModel": RepromptModel,
    "RequiredPhrasesRequest": RequiredPhrasesRequest,
    "ResetRequest": ResetRequest,
    "ResponseTemplateTypeModel": ResponseTemplateTypeModel,
    "SharedReferencesExportModel": SharedReferencesExportModel,
    "SimpleChoiceExportModel": SimpleChoiceExportModel,
    "SimpleChoiceModel": SimpleChoiceModel,
    "SimpleChoiceResponseModel": SimpleChoiceResponseModel,
    "SimpleChoiceWebhookModel": SimpleChoiceWebhookModel,
    "SingleSignOnRequest": SingleSignOnRequest,
    "SingleSignOnResponse": SingleSignOnResponse,
    "SkillSummary": SkillSummary,
    "SkillSummaryLink": SkillSummaryLink,
    "Slot": Slot,
    "SpeechOutput": SpeechOutput,
    "SsmlAttribute": SsmlAttribute,
    "SsmlElement": SsmlElement,
    "SsmlRequest": SsmlRequest,
    "SubscriptionModel": SubscriptionModel,
    "SubscriptionTypeModel": SubscriptionTypeModel,
    "TemplateConfigurationModel": TemplateConfigurationModel,
    "TemplateFormFieldModel": TemplateFormFieldModel,
    "TemplateFormFieldOptionModel": TemplateFormFieldOptionModel,
    "TemplateFormFieldValueModel": TemplateFormFieldValueModel,
    "TemplateFormModel": TemplateFormModel,
    "TemplateFormSectionModel": TemplateFormSectionModel,
    "TemplateFormWithConfigurationModel": TemplateFormWithConfigurationModel,
    "TermModel": TermModel,
    "ToggleLiveRequest": ToggleLiveRequest,
    "ToggleTemplateRequest": ToggleTemplateRequest,
    "TokenResponse": TokenResponse,
    "UpdateAnswerRequest": UpdateAnswerRequest,
    "UpdateApplicationFeatureRequest": UpdateApplicationFeatureRequest,
    "UpdateApplicationInformationByLanguageRequest": UpdateApplicationInformationByLanguageRequest,
    "UpdateApplicationModuleRequest": UpdateApplicationModuleRequest,
    "UpdateApplicationRequest": UpdateApplicationRequest,
    "UpdateAppliedApplicationTemplateFormRequest": UpdateAppliedApplicationTemplateFormRequest,
    "UpdateBulkMediaResponseContainerRequest": UpdateBulkMediaResponseContainerRequest,
    "UpdateChildContentContainerRequest": UpdateChildContentContainerRequest,
    "UpdateCustomRequestRequest": UpdateCustomRequestRequest,
    "UpdateCustomRequestResponseRequest": UpdateCustomRequestResponseRequest,
    "UpdateEventResponseRequest": UpdateEventResponseRequest,
    "UpdateExitMessageRequest": UpdateExitMessageRequest,
    "UpdateExitMessageStubRequest": UpdateExitMessageStubRequest,
    "UpdateFallbackMessageRequest": UpdateFallbackMessageRequest,
    "UpdateFallbackMessageStubRequest": UpdateFallbackMessageStubRequest,
    "UpdateFollowUpHintRequest": UpdateFollowUpHintRequest,
    "UpdateFollowUpRequest": UpdateFollowUpRequest,
    "UpdateHelpMessageRequest": UpdateHelpMessageRequest,
    "UpdateHelpMessageStubRequest": UpdateHelpMessageStubRequest,
    "UpdateIngredientRequest": UpdateIngredientRequest,
    "UpdateLatestMessageRequest": UpdateLatestMessageRequest,
    "UpdateLatestMessageResponseRequest": UpdateLatestMessageResponseRequest,
    "UpdateMediaItemRequest": UpdateMediaItemRequest,
    "UpdateMediaResponseContainerRequest": UpdateMediaResponseContainerRequest,
    "UpdateMediaResponseRequest": UpdateMediaResponseRequest,
    "UpdateMicrosoftAppInfoRequest": UpdateMicrosoftAppInfoRequest,
    "UpdateNumberRangeRequest": UpdateNumberRangeRequest,
    "UpdateNumberRangeResponseRequest": UpdateNumberRangeResponseRequest,
    "UpdateOrganizationRequest": UpdateOrganizationRequest,
    "UpdateQuestionRequest": UpdateQuestionRequest,
    "UpdateRepromptRequest": UpdateRepromptRequest,
    "UpdateResponseTemplateTypeRequest": UpdateResponseTemplateTypeRequest,
    "UpdateSimpleChoiceRequest": UpdateSimpleChoiceRequest,
    "UpdateSimpleChoiceResponseRequest": UpdateSimpleChoiceResponseRequest,
    "UpdateStepRequest": UpdateStepRequest,
    "UpdateUserRequest": UpdateUserRequest,
    "UpdateWebhookRequest": UpdateWebhookRequest,
    "UpdateWelcomeMessageRequest": UpdateWelcomeMessageRequest,
    "UpdateWelcomeMessageStubRequest": UpdateWelcomeMessageStubRequest,
    "UserDefinedWebhookParameterCreateRequest": UserDefinedWebhookParameterCreateRequest,
    "UserDefinedWebhookParameterUpdateRequest": UserDefinedWebhookParameterUpdateRequest,
    "UserModel": UserModel,
    "UserRoleModel": UserRoleModel,
    "UserTermAgreementModel": UserTermAgreementModel,
    "UserTermModel": UserTermModel,
    "UserVoicifyNotificationModel": UserVoicifyNotificationModel,
    "WebhookModel": WebhookModel,
    "WebhookParameterModel": WebhookParameterModel,
    "WebhookParameterUpdateRequest": WebhookParameterUpdateRequest,
    "WebhookParameterValueModel": WebhookParameterValueModel,
    "WebhookParametersRequest": WebhookParametersRequest,
    "WebhookScopeModel": WebhookScopeModel,
    "WebhookTypeModel": WebhookTypeModel,
    "WelcomeMessageExportModel": WelcomeMessageExportModel,
    "WelcomeMessageModel": WelcomeMessageModel,
    "WelcomeMessageWebhookModel": WelcomeMessageWebhookModel,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AlexaSkillApiApiKeys {
    Bearer,
}

export class AlexaSkillApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AlexaSkillApiApiKeys, value: string) {
        (this.authentications as any)[AlexaSkillApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Gets the list of alexa skills for the given vendor
     * @param tokenId 
     * @param vendorId 
     * @param {*} [options] Override http request options.
     */
    public listAlexaSkills (tokenId: string, vendorId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<SkillSummary>;  }> {
        const localVarPath = this.basePath + '/api/AlexaSkill/Skills/{vendorId}/{tokenId}'
            .replace('{' + 'tokenId' + '}', encodeURIComponent(String(tokenId)))
            .replace('{' + 'vendorId' + '}', encodeURIComponent(String(vendorId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tokenId' is not null or undefined
        if (tokenId === null || tokenId === undefined) {
            throw new Error('Required parameter tokenId was null or undefined when calling listAlexaSkills.');
        }

        // verify required parameter 'vendorId' is not null or undefined
        if (vendorId === null || vendorId === undefined) {
            throw new Error('Required parameter vendorId was null or undefined when calling listAlexaSkills.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<SkillSummary>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<SkillSummary>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AmazonAuthorizationApiApiKeys {
    Bearer,
}

export class AmazonAuthorizationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AmazonAuthorizationApiApiKeys, value: string) {
        (this.authentications as any)[AmazonAuthorizationApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Handles the callback for amazon OAuth
     * @param code 
     * @param state 
     * @param error 
     * @param {*} [options] Override http request options.
     */
    public amazonAuthCallbackAsync (code?: string, state?: string, error?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/AmazonAuthorization/Callback';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (code !== undefined) {
            localVarQueryParameters['code'] = ObjectSerializer.serialize(code, "string");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "string");
        }

        if (error !== undefined) {
            localVarQueryParameters['error'] = ObjectSerializer.serialize(error, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the available amazon credential information for a given organization
     * @param organizationId 
     * @param {*} [options] Override http request options.
     */
    public getAvailableCredentials (organizationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<TokenResponse>;  }> {
        const localVarPath = this.basePath + '/api/AmazonAuthorization/Credentials/{organizationId}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getAvailableCredentials.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<TokenResponse>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TokenResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Removes an amazon credential
     * @param tokenId 
     * @param {*} [options] Override http request options.
     */
    public removeCredential (tokenId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/AmazonAuthorization/Credentials/{tokenId}'
            .replace('{' + 'tokenId' + '}', encodeURIComponent(String(tokenId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tokenId' is not null or undefined
        if (tokenId === null || tokenId === undefined) {
            throw new Error('Required parameter tokenId was null or undefined when calling removeCredential.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the authentication url for amazon authorization
     * @param organizationId 
     * @param applicationId 
     * @param salt 
     * @param {*} [options] Override http request options.
     */
    public requestAuthenticationUrl (organizationId?: string, applicationId?: string, salt?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/AmazonAuthorization/AuthorizationUrl';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (salt !== undefined) {
            localVarQueryParameters['salt'] = ObjectSerializer.serialize(salt, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ApplicationApiApiKeys {
    Bearer,
}

export class ApplicationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ApplicationApiApiKeys, value: string) {
        (this.authentications as any)[ApplicationApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a member to the given application
     * @param applicationId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public addMemberAsync (applicationId: string, model?: NewApplicationMemberRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationMemberModel;  }> {
        const localVarPath = this.basePath + '/api/Application/{applicationId}/members'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling addMemberAsync.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewApplicationMemberRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationMemberModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationMemberModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param webhookId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public addWebhook (applicationId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/Application/{applicationId}/webhooks/{webhookId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)))
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling addWebhook.');
        }

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling addWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a member to the given application
     * @param applicationId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public bulkAddMemberAsync (applicationId: string, model?: NewBulkApplicationMemberRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ApplicationMemberModel>;  }> {
        const localVarPath = this.basePath + '/api/Application/{applicationId}/members/bulkAdd'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling bulkAddMemberAsync.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewBulkApplicationMemberRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ApplicationMemberModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ApplicationMemberModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new Application with some sample content for the given organization
     * @param organizationId Organization ID
     * @param model request model
     * @param {*} [options] Override http request options.
     */
    public createApplicationWithSampleContent (organizationId: string, model?: NewApplicationRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationModel;  }> {
        const localVarPath = this.basePath + '/api/Application/{organizationId}/withSamples'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling createApplicationWithSampleContent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewApplicationRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new Application for the given organization
     * @param organizationId Organization ID
     * @param model request model
     * @param {*} [options] Override http request options.
     */
    public createEmptyApplication (organizationId: string, model?: NewApplicationRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationModel;  }> {
        const localVarPath = this.basePath + '/api/Application/{organizationId}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling createEmptyApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewApplicationRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public createUserDefinedParameter (instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/Application/webhook/{instanceWebhookId}/userParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling createUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UserDefinedWebhookParameterCreateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public deleteApplication (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationModel;  }> {
        const localVarPath = this.basePath + '/api/Application/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling deleteApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public disableApplication (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationModel;  }> {
        const localVarPath = this.basePath + '/api/Application/{applicationId}/disable'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling disableApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public enableApplication (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationModel;  }> {
        const localVarPath = this.basePath + '/api/Application/{applicationId}/enable'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling enableApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets a single application by id
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public findApplication (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationModel;  }> {
        const localVarPath = this.basePath + '/api/Application/find/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling findApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets a single application with all its features by id
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public findApplicationWithFeatures (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationWithFeaturesModel;  }> {
        const localVarPath = this.basePath + '/api/Application/find/{applicationId}/withFeatures'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling findApplicationWithFeatures.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationWithFeaturesModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationWithFeaturesModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getAppConversationCount (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationConversationCountModel;  }> {
        const localVarPath = this.basePath + '/api/Application/{applicationId}/conversationCount'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getAppConversationCount.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationConversationCountModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationConversationCountModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param organizationId 
     * @param {*} [options] Override http request options.
     */
    public getAppConversationCounts (organizationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ApplicationConversationCountModel>;  }> {
        const localVarPath = this.basePath + '/api/Application/{organizationId}/apps/conversationCounts'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getAppConversationCounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ApplicationConversationCountModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ApplicationConversationCountModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the members of the application
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getAppMembers (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ApplicationMemberModel>;  }> {
        const localVarPath = this.basePath + '/api/Application/{applicationId}/members'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getAppMembers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ApplicationMemberModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ApplicationMemberModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the applications from the given organization
     * @param organizationId The organization Id
     * @param {*} [options] Override http request options.
     */
    public getApplicationsForOrganization (organizationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ApplicationModel>;  }> {
        const localVarPath = this.basePath + '/api/Application/{organizationId}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getApplicationsForOrganization.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ApplicationModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ApplicationModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the applications from the given organization
     * @param organizationId The organization Id
     * @param {*} [options] Override http request options.
     */
    public getApplicationsWithFeaturesForOrganization (organizationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ApplicationWithFeaturesModel>;  }> {
        const localVarPath = this.basePath + '/api/Application/{organizationId}/withFeatures'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getApplicationsWithFeaturesForOrganization.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ApplicationWithFeaturesModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ApplicationWithFeaturesModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getFulfillmentEndpoints (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationFulfillmentEndpoints;  }> {
        const localVarPath = this.basePath + '/api/Application/{applicationId}/fulfillmentEndpoints'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getFulfillmentEndpoints.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationFulfillmentEndpoints;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationFulfillmentEndpoints");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getWebhooks (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ApplicationWebhookModel>;  }> {
        const localVarPath = this.basePath + '/api/Application/{applicationId}/webhooks'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getWebhooks.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ApplicationWebhookModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ApplicationWebhookModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Removes the given user from the app
     * @param applicationMemberId 
     * @param {*} [options] Override http request options.
     */
    public removeMember (applicationMemberId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationMemberModel;  }> {
        const localVarPath = this.basePath + '/api/Application/members/{applicationMemberId}'
            .replace('{' + 'applicationMemberId' + '}', encodeURIComponent(String(applicationMemberId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationMemberId' is not null or undefined
        if (applicationMemberId === null || applicationMemberId === undefined) {
            throw new Error('Required parameter applicationMemberId was null or undefined when calling removeMember.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationMemberModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationMemberModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param parameterName 
     * @param {*} [options] Override http request options.
     */
    public removeUserDefinedParameter (instanceWebhookId: string, parameterName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/Application/webhook/{instanceWebhookId}/userParameters/{parameterName}'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)))
            .replace('{' + 'parameterName' + '}', encodeURIComponent(String(parameterName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling removeUserDefinedParameter.');
        }

        // verify required parameter 'parameterName' is not null or undefined
        if (parameterName === null || parameterName === undefined) {
            throw new Error('Required parameter parameterName was null or undefined when calling removeUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationWebhookId 
     * @param {*} [options] Override http request options.
     */
    public removeWebhook (applicationWebhookId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/Application/webhook/{applicationWebhookId}'
            .replace('{' + 'applicationWebhookId' + '}', encodeURIComponent(String(applicationWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationWebhookId' is not null or undefined
        if (applicationWebhookId === null || applicationWebhookId === undefined) {
            throw new Error('Required parameter applicationWebhookId was null or undefined when calling removeWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param imageItemId 
     * @param {*} [options] Override http request options.
     */
    public setImage (applicationId: string, imageItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationModel;  }> {
        const localVarPath = this.basePath + '/api/Application/{applicationId}/setImage/{imageItemId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)))
            .replace('{' + 'imageItemId' + '}', encodeURIComponent(String(imageItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling setImage.');
        }

        // verify required parameter 'imageItemId' is not null or undefined
        if (imageItemId === null || imageItemId === undefined) {
            throw new Error('Required parameter imageItemId was null or undefined when calling setImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public setInitialPriority (options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/Application/setInitialPriority';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Toggles the template status of an application
     * @param applicationId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public toggleAllowsTemplate (applicationId: string, request?: ToggleTemplateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationModel;  }> {
        const localVarPath = this.basePath + '/api/Application/{applicationId}/toggleAllowsTemplate'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling toggleAllowsTemplate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "ToggleTemplateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param sensitivityLevel 
     * @param {*} [options] Override http request options.
     */
    public updateAlexaFallbackSensitivity (applicationId: string, sensitivityLevel: 'LOW' | 'MEDIUM' | 'HIGH', options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/Application/{applicationId}/alexaFallbackSensitivity/{sensitivityLevel}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)))
            .replace('{' + 'sensitivityLevel' + '}', encodeURIComponent(String(sensitivityLevel)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling updateAlexaFallbackSensitivity.');
        }

        // verify required parameter 'sensitivityLevel' is not null or undefined
        if (sensitivityLevel === null || sensitivityLevel === undefined) {
            throw new Error('Required parameter sensitivityLevel was null or undefined when calling updateAlexaFallbackSensitivity.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates an application's information
     * @param applicationId The application id
     * @param model Information to update
     * @param {*} [options] Override http request options.
     */
    public updateApplicationInformation (applicationId: string, model?: UpdateApplicationRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationModel;  }> {
        const localVarPath = this.basePath + '/api/Application/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling updateApplicationInformation.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateApplicationRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param webhookInstanceId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public updateAttachedWebhook (applicationId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/Application/{applicationId}/webhooks/{webhookInstanceId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)))
            .replace('{' + 'webhookInstanceId' + '}', encodeURIComponent(String(webhookInstanceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling updateAttachedWebhook.');
        }

        // verify required parameter 'webhookInstanceId' is not null or undefined
        if (webhookInstanceId === null || webhookInstanceId === undefined) {
            throw new Error('Required parameter webhookInstanceId was null or undefined when calling updateAttachedWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param languageId 
     * @param {*} [options] Override http request options.
     */
    public updateDefaultLangauge (applicationId: string, languageId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationModel;  }> {
        const localVarPath = this.basePath + '/api/Application/{applicationId}/defaultLanguage/{languageId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)))
            .replace('{' + 'languageId' + '}', encodeURIComponent(String(languageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling updateDefaultLangauge.');
        }

        // verify required parameter 'languageId' is not null or undefined
        if (languageId === null || languageId === undefined) {
            throw new Error('Required parameter languageId was null or undefined when calling updateDefaultLangauge.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param languageIds 
     * @param {*} [options] Override http request options.
     */
    public updateLangauges (applicationId: string, languageIds?: Array<string>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationModel;  }> {
        const localVarPath = this.basePath + '/api/Application/{applicationId}/languages'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling updateLangauges.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(languageIds, "Array<string>")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the given member's role
     * @param applicationMemberId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateMemberRole (applicationMemberId: string, model?: MemberRoleUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationMemberModel;  }> {
        const localVarPath = this.basePath + '/api/Application/members/{applicationMemberId}'
            .replace('{' + 'applicationMemberId' + '}', encodeURIComponent(String(applicationMemberId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationMemberId' is not null or undefined
        if (applicationMemberId === null || applicationMemberId === undefined) {
            throw new Error('Required parameter applicationMemberId was null or undefined when calling updateMemberRole.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "MemberRoleUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationMemberModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationMemberModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateUserDefinedParameter (instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/Application/webhook/{instanceWebhookId}/userParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UserDefinedWebhookParameterUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateWebhookParameter (instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/Application/webhook/{instanceWebhookId}/webhookParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateWebhookParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "WebhookParameterUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ApplicationDeploymentApiApiKeys {
    Bearer,
}

export class ApplicationDeploymentApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ApplicationDeploymentApiApiKeys, value: string) {
        (this.authentications as any)[ApplicationDeploymentApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param applicationId 
     * @param luisRegion 
     * @param {*} [options] Override http request options.
     */
    public deployNewLuisApp (applicationId: string, luisRegion?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NewLuisAppResponse;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/{applicationId}/luisApp/CreateAndDeploy'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling deployNewLuisApp.');
        }

        if (luisRegion !== undefined) {
            localVarQueryParameters['luisRegion'] = ObjectSerializer.serialize(luisRegion, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NewLuisAppResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NewLuisAppResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public deployNewSkill (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NewSkillResponse;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/{applicationId}/alexaSkill/CreateAndDeploy'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling deployNewSkill.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NewSkillResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NewSkillResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getAlexaVendors (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AlexaVendorResponse;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/{applicationId}/alexaVendors'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getAlexaVendors.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AlexaVendorResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AlexaVendorResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getApplicationLinkToAmazon (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DeploymentLink;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/{applicationId}/linkToAmazon'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getApplicationLinkToAmazon.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DeploymentLink;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeploymentLink");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getApplicationLinkToGoogle (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DeploymentLink;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/{applicationId}/linkToGoogle'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getApplicationLinkToGoogle.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DeploymentLink;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeploymentLink");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getApplicationLinkToMicrosoft (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MicrosoftDeploymentLink;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/{applicationId}/linkToMicrosoft'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getApplicationLinkToMicrosoft.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MicrosoftDeploymentLink;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MicrosoftDeploymentLink");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param organizationId 
     * @param {*} [options] Override http request options.
     */
    public getApplicationsLinkedToAmazon (organizationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ApplicationsByAmazonAccount>;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/organizationLinksToAmazon/{organizationId}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getApplicationsLinkedToAmazon.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ApplicationsByAmazonAccount>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ApplicationsByAmazonAccount>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param organizationId 
     * @param {*} [options] Override http request options.
     */
    public getApplicationsLinkedToGoogle (organizationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ApplicationsByGoogleAccount>;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/organizationLinksToGoogle/{organizationId}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getApplicationsLinkedToGoogle.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ApplicationsByGoogleAccount>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ApplicationsByGoogleAccount>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param organizationId 
     * @param {*} [options] Override http request options.
     */
    public getApplicationsLinkedToMicrosoft (organizationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ApplicationsByMicrosoftAccount>;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/organizationLinksToMicrosoft/{organizationId}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getApplicationsLinkedToMicrosoft.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ApplicationsByMicrosoftAccount>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ApplicationsByMicrosoftAccount>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param alexaSkillId 
     * @param {*} [options] Override http request options.
     */
    public linkAlexaSkillId (applicationId: string, alexaSkillId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/{applicationId}/alexaSkill/{alexaSkillId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)))
            .replace('{' + 'alexaSkillId' + '}', encodeURIComponent(String(alexaSkillId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling linkAlexaSkillId.');
        }

        // verify required parameter 'alexaSkillId' is not null or undefined
        if (alexaSkillId === null || alexaSkillId === undefined) {
            throw new Error('Required parameter alexaSkillId was null or undefined when calling linkAlexaSkillId.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param vendorId 
     * @param {*} [options] Override http request options.
     */
    public linkAlexaVendor (applicationId: string, vendorId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/{applicationId}/alexaVendor/{vendorId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)))
            .replace('{' + 'vendorId' + '}', encodeURIComponent(String(vendorId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling linkAlexaVendor.');
        }

        // verify required parameter 'vendorId' is not null or undefined
        if (vendorId === null || vendorId === undefined) {
            throw new Error('Required parameter vendorId was null or undefined when calling linkAlexaVendor.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param amazonTokenId 
     * @param {*} [options] Override http request options.
     */
    public linkAmazonAuthToken (applicationId: string, amazonTokenId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/{applicationId}/amazonAuthToken/{amazonTokenId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)))
            .replace('{' + 'amazonTokenId' + '}', encodeURIComponent(String(amazonTokenId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling linkAmazonAuthToken.');
        }

        // verify required parameter 'amazonTokenId' is not null or undefined
        if (amazonTokenId === null || amazonTokenId === undefined) {
            throw new Error('Required parameter amazonTokenId was null or undefined when calling linkAmazonAuthToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param subscriptionId 
     * @param {*} [options] Override http request options.
     */
    public linkAzureSubscription (applicationId: string, subscriptionId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/{applicationId}/azureSubscriptions/{subscriptionId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)))
            .replace('{' + 'subscriptionId' + '}', encodeURIComponent(String(subscriptionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling linkAzureSubscription.');
        }

        // verify required parameter 'subscriptionId' is not null or undefined
        if (subscriptionId === null || subscriptionId === undefined) {
            throw new Error('Required parameter subscriptionId was null or undefined when calling linkAzureSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param dialogflowAgentId 
     * @param {*} [options] Override http request options.
     */
    public linkDialogflowAgentId (applicationId: string, dialogflowAgentId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/{applicationId}/dialogflowAgent'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling linkDialogflowAgentId.');
        }

        if (dialogflowAgentId !== undefined) {
            localVarQueryParameters['dialogflowAgentId'] = ObjectSerializer.serialize(dialogflowAgentId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param googleTokenId 
     * @param {*} [options] Override http request options.
     */
    public linkGoogleAuthToken (applicationId: string, googleTokenId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/{applicationId}/googleAuthToken/{googleTokenId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)))
            .replace('{' + 'googleTokenId' + '}', encodeURIComponent(String(googleTokenId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling linkGoogleAuthToken.');
        }

        // verify required parameter 'googleTokenId' is not null or undefined
        if (googleTokenId === null || googleTokenId === undefined) {
            throw new Error('Required parameter googleTokenId was null or undefined when calling linkGoogleAuthToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param luisAppId 
     * @param luisRegion 
     * @param locale 
     * @param {*} [options] Override http request options.
     */
    public linkLuisApp (applicationId: string, luisAppId: string, luisRegion?: string, locale?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/{applicationId}/luisApp/{luisAppId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)))
            .replace('{' + 'luisAppId' + '}', encodeURIComponent(String(luisAppId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling linkLuisApp.');
        }

        // verify required parameter 'luisAppId' is not null or undefined
        if (luisAppId === null || luisAppId === undefined) {
            throw new Error('Required parameter luisAppId was null or undefined when calling linkLuisApp.');
        }

        if (luisRegion !== undefined) {
            localVarQueryParameters['luisRegion'] = ObjectSerializer.serialize(luisRegion, "string");
        }

        if (locale !== undefined) {
            localVarQueryParameters['locale'] = ObjectSerializer.serialize(locale, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param luisKey 
     * @param {*} [options] Override http request options.
     */
    public linkLuisAuthoringKey (applicationId: string, luisKey: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/{applicationId}/luisKey/{luisKey}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)))
            .replace('{' + 'luisKey' + '}', encodeURIComponent(String(luisKey)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling linkLuisAuthoringKey.');
        }

        // verify required parameter 'luisKey' is not null or undefined
        if (luisKey === null || luisKey === undefined) {
            throw new Error('Required parameter luisKey was null or undefined when calling linkLuisAuthoringKey.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public linkMicrosoftApp (applicationId: string, model?: UpdateMicrosoftAppInfoRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/{applicationId}/microsoftProject'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling linkMicrosoftApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateMicrosoftAppInfoRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param microsoftTokenId 
     * @param {*} [options] Override http request options.
     */
    public linkMicrosoftAuthToken (applicationId: string, microsoftTokenId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/{applicationId}/microsoftAuthToken/{microsoftTokenId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)))
            .replace('{' + 'microsoftTokenId' + '}', encodeURIComponent(String(microsoftTokenId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling linkMicrosoftAuthToken.');
        }

        // verify required parameter 'microsoftTokenId' is not null or undefined
        if (microsoftTokenId === null || microsoftTokenId === undefined) {
            throw new Error('Required parameter microsoftTokenId was null or undefined when calling linkMicrosoftAuthToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public removeAlexaVendor (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/{applicationId}/alexaVendor'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling removeAlexaVendor.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public removeAmazonAuthToken (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/{applicationId}/amazonAuthToken'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling removeAmazonAuthToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public removeAzureSubscription (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/{applicationId}/azureSubscription'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling removeAzureSubscription.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public removeGoogleAuthToken (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/{applicationId}/googleAuthToken'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling removeGoogleAuthToken.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public unlinkAlexaSkill (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/{applicationId}/alexaSkill'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling unlinkAlexaSkill.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public unlinkDialogflowAgent (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/{applicationId}/dialogflowAgent'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling unlinkDialogflowAgent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public unlinkLuisApp (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/{applicationId}/luisApp'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling unlinkLuisApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public unlinkMicrosoftProject (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/ApplicationDeployment/{applicationId}/microsoftProject'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling unlinkMicrosoftProject.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ApplicationTemplatingApiApiKeys {
    Bearer,
}

export class ApplicationTemplatingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ApplicationTemplatingApiApiKeys, value: string) {
        (this.authentications as any)[ApplicationTemplatingApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param applicationId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public addAppliedApplicationTemplateForm (applicationId: string, request?: CompleteTemplateFormModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AppliedApplicationTemplateFormModel;  }> {
        const localVarPath = this.basePath + '/api/ApplicationTemplating/{applicationId}/addAppliedApplicationTemplateForm'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling addAppliedApplicationTemplateForm.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "CompleteTemplateFormModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AppliedApplicationTemplateFormModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AppliedApplicationTemplateFormModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public createApplicationFromForms (request?: CreateApplicationFromCompletedFormsRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationModel;  }> {
        const localVarPath = this.basePath + '/api/ApplicationTemplating/CreateFromForm';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "CreateApplicationFromCompletedFormsRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationTemplateFormId 
     * @param {*} [options] Override http request options.
     */
    public removeAppliedApplicationTemplateForm (applicationId: string, applicationTemplateFormId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AppliedApplicationTemplateFormModel;  }> {
        const localVarPath = this.basePath + '/api/ApplicationTemplating/{applicationId}/RemoveAppliedApplicationTemplateForm/{applicationTemplateFormId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)))
            .replace('{' + 'applicationTemplateFormId' + '}', encodeURIComponent(String(applicationTemplateFormId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling removeAppliedApplicationTemplateForm.');
        }

        // verify required parameter 'applicationTemplateFormId' is not null or undefined
        if (applicationTemplateFormId === null || applicationTemplateFormId === undefined) {
            throw new Error('Required parameter applicationTemplateFormId was null or undefined when calling removeAppliedApplicationTemplateForm.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AppliedApplicationTemplateFormModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AppliedApplicationTemplateFormModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationTemplateFormId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateAppliedApplicationTemplateForm (applicationId: string, applicationTemplateFormId: string, request?: UpdateAppliedApplicationTemplateFormRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AppliedApplicationTemplateFormModel;  }> {
        const localVarPath = this.basePath + '/api/ApplicationTemplating/{applicationId}/UpdateAppliedApplicationTemplateForm/{applicationTemplateFormId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)))
            .replace('{' + 'applicationTemplateFormId' + '}', encodeURIComponent(String(applicationTemplateFormId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling updateAppliedApplicationTemplateForm.');
        }

        // verify required parameter 'applicationTemplateFormId' is not null or undefined
        if (applicationTemplateFormId === null || applicationTemplateFormId === undefined) {
            throw new Error('Required parameter applicationTemplateFormId was null or undefined when calling updateAppliedApplicationTemplateForm.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UpdateAppliedApplicationTemplateFormRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AppliedApplicationTemplateFormModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AppliedApplicationTemplateFormModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AppliedApplicationTemplateApiApiKeys {
    Bearer,
}

export class AppliedApplicationTemplateApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AppliedApplicationTemplateApiApiKeys, value: string) {
        (this.authentications as any)[AppliedApplicationTemplateApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param applicationId 
     * @param templateConfigurationId 
     * @param {*} [options] Override http request options.
     */
    public addAppliedTemplateToApp (applicationId: string, templateConfigurationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AppliedApplicationTemplateFormModel;  }> {
        const localVarPath = this.basePath + '/api/AppliedApplicationTemplate/{applicationId}/add/{templateConfigurationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)))
            .replace('{' + 'templateConfigurationId' + '}', encodeURIComponent(String(templateConfigurationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling addAppliedTemplateToApp.');
        }

        // verify required parameter 'templateConfigurationId' is not null or undefined
        if (templateConfigurationId === null || templateConfigurationId === undefined) {
            throw new Error('Required parameter templateConfigurationId was null or undefined when calling addAppliedTemplateToApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AppliedApplicationTemplateFormModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AppliedApplicationTemplateFormModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appliedApplicationTemplateFormId 
     * @param {*} [options] Override http request options.
     */
    public deleteAppliedTemplate (appliedApplicationTemplateFormId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AppliedApplicationTemplateFormModel;  }> {
        const localVarPath = this.basePath + '/api/AppliedApplicationTemplate/{appliedApplicationTemplateFormId}'
            .replace('{' + 'appliedApplicationTemplateFormId' + '}', encodeURIComponent(String(appliedApplicationTemplateFormId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appliedApplicationTemplateFormId' is not null or undefined
        if (appliedApplicationTemplateFormId === null || appliedApplicationTemplateFormId === undefined) {
            throw new Error('Required parameter appliedApplicationTemplateFormId was null or undefined when calling deleteAppliedTemplate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AppliedApplicationTemplateFormModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AppliedApplicationTemplateFormModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appliedApplicationTemplateFormId 
     * @param {*} [options] Override http request options.
     */
    public findAppliedTemplateById (appliedApplicationTemplateFormId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AppliedApplicationTemplateFormModel;  }> {
        const localVarPath = this.basePath + '/api/AppliedApplicationTemplate/{appliedApplicationTemplateFormId}'
            .replace('{' + 'appliedApplicationTemplateFormId' + '}', encodeURIComponent(String(appliedApplicationTemplateFormId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appliedApplicationTemplateFormId' is not null or undefined
        if (appliedApplicationTemplateFormId === null || appliedApplicationTemplateFormId === undefined) {
            throw new Error('Required parameter appliedApplicationTemplateFormId was null or undefined when calling findAppliedTemplateById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AppliedApplicationTemplateFormModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AppliedApplicationTemplateFormModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getAppliedTemplatesForApplication (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<AppliedApplicationTemplateFormModel>;  }> {
        const localVarPath = this.basePath + '/api/AppliedApplicationTemplate/forApp/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getAppliedTemplatesForApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<AppliedApplicationTemplateFormModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<AppliedApplicationTemplateFormModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param appliedApplicationTemplateFormId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateAppliedTemplate (appliedApplicationTemplateFormId: string, model?: UpdateAppliedApplicationTemplateFormRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AppliedApplicationTemplateFormModel;  }> {
        const localVarPath = this.basePath + '/api/AppliedApplicationTemplate/{appliedApplicationTemplateFormId}'
            .replace('{' + 'appliedApplicationTemplateFormId' + '}', encodeURIComponent(String(appliedApplicationTemplateFormId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'appliedApplicationTemplateFormId' is not null or undefined
        if (appliedApplicationTemplateFormId === null || appliedApplicationTemplateFormId === undefined) {
            throw new Error('Required parameter appliedApplicationTemplateFormId was null or undefined when calling updateAppliedTemplate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateAppliedApplicationTemplateFormRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AppliedApplicationTemplateFormModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AppliedApplicationTemplateFormModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AuthenticationApiApiKeys {
    Bearer,
}

export class AuthenticationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AuthenticationApiApiKeys, value: string) {
        (this.authentications as any)[AuthenticationApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Authenticate the specified model.  Model is from query string to ensure oauth standards
     * @param clientId 
     * @param clientSecret 
     * @param grantType 
     * @param username 
     * @param password 
     * @param refreshToken 
     * @param {*} [options] Override http request options.
     */
    public authenticate (clientId: string, clientSecret: string, grantType: string, username: string, password?: string, refreshToken?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AuthenticationResponse;  }> {
        const localVarPath = this.basePath + '/api/Authentication';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'clientId' is not null or undefined
        if (clientId === null || clientId === undefined) {
            throw new Error('Required parameter clientId was null or undefined when calling authenticate.');
        }

        // verify required parameter 'clientSecret' is not null or undefined
        if (clientSecret === null || clientSecret === undefined) {
            throw new Error('Required parameter clientSecret was null or undefined when calling authenticate.');
        }

        // verify required parameter 'grantType' is not null or undefined
        if (grantType === null || grantType === undefined) {
            throw new Error('Required parameter grantType was null or undefined when calling authenticate.');
        }

        // verify required parameter 'username' is not null or undefined
        if (username === null || username === undefined) {
            throw new Error('Required parameter username was null or undefined when calling authenticate.');
        }

        if (clientId !== undefined) {
            localVarQueryParameters['ClientId'] = ObjectSerializer.serialize(clientId, "string");
        }

        if (clientSecret !== undefined) {
            localVarQueryParameters['ClientSecret'] = ObjectSerializer.serialize(clientSecret, "string");
        }

        if (grantType !== undefined) {
            localVarQueryParameters['GrantType'] = ObjectSerializer.serialize(grantType, "string");
        }

        if (username !== undefined) {
            localVarQueryParameters['Username'] = ObjectSerializer.serialize(username, "string");
        }

        if (password !== undefined) {
            localVarQueryParameters['Password'] = ObjectSerializer.serialize(password, "string");
        }

        if (refreshToken !== undefined) {
            localVarQueryParameters['RefreshToken'] = ObjectSerializer.serialize(refreshToken, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AuthenticationResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AuthenticationResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Endpoint for testing if the user is authenticated and an admin
     * @param {*} [options] Override http request options.
     */
    public testAdminAuth (options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/Authentication/test/admin';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Endpoint for testing if a user is authenticated
     * @param {*} [options] Override http request options.
     */
    public testAuth (options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/Authentication/test';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum AzureApplicationApiApiKeys {
    Bearer,
}

export class AzureApplicationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AzureApplicationApiApiKeys, value: string) {
        (this.authentications as any)[AzureApplicationApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getAzureSubscriptions (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<AzureSubscriptionInformation>;  }> {
        const localVarPath = this.basePath + '/api/AzureApplication/{applicationId}/azureSubscriptions'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getAzureSubscriptions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<AzureSubscriptionInformation>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<AzureSubscriptionInformation>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getBotServiceApps (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<AzureBotServiceInformation>;  }> {
        const localVarPath = this.basePath + '/api/AzureApplication/{applicationId}/botServiceApps'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getBotServiceApps.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<AzureBotServiceInformation>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<AzureBotServiceInformation>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getLuisApps (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<LuisApplicationInformation>;  }> {
        const localVarPath = this.basePath + '/api/AzureApplication/{applicationId}/luisApps'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getLuisApps.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<LuisApplicationInformation>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<LuisApplicationInformation>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BixbyCapsuleApiApiKeys {
    Bearer,
}

export class BixbyCapsuleApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BixbyCapsuleApiApiKeys, value: string) {
        (this.authentications as any)[BixbyCapsuleApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getApplicationBixbyProperties (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/BixbyCapsule/capsuleProperties/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getApplicationBixbyProperties.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getBaseBixbyCapsuleTemplate (options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/BixbyCapsule/baseCapsuleTemplate';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BulkContentApiApiKeys {
    Bearer,
}

export class BulkContentApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BulkContentApiApiKeys, value: string) {
        (this.authentications as any)[BulkContentApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param applicationFeatureId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public bulkCopyContentToApplicationFeature (applicationFeatureId: string, request?: BulkContentRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/BulkContent/CopyToFeature/{applicationFeatureId}'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling bulkCopyContentToApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "BulkContentRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationFeatureId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public bulkMoveContentToApplicationFeature (applicationFeatureId: string, request?: BulkContentRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/BulkContent/MoveToFeature/{applicationFeatureId}'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling bulkMoveContentToApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "BulkContentRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public deleteContentInBulk (request?: BulkContentRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/BulkContent/Delete';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "BulkContentRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ContentLanguageApiApiKeys {
    Bearer,
}

export class ContentLanguageApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ContentLanguageApiApiKeys, value: string) {
        (this.authentications as any)[ContentLanguageApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getAllLanguages (options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<LanguageModel>;  }> {
        const localVarPath = this.basePath + '/api/ContentLanguage/All';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<LanguageModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<LanguageModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum CustomRequestApiApiKeys {
    Bearer,
}

export class CustomRequestApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: CustomRequestApiApiKeys, value: string) {
        (this.authentications as any)[CustomRequestApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds an audio file to the given response
     * @param customRequestResponseId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addAudioFile (customRequestResponseId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CustomRequestResponseModel;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/{customRequestResponseId}/addAudioFile/{mediaItemId}'
            .replace('{' + 'customRequestResponseId' + '}', encodeURIComponent(String(customRequestResponseId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRequestResponseId' is not null or undefined
        if (customRequestResponseId === null || customRequestResponseId === undefined) {
            throw new Error('Required parameter customRequestResponseId was null or undefined when calling addAudioFile.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addAudioFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CustomRequestResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRequestResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a large image to the given response
     * @param customRequestResponseId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addLargeImage (customRequestResponseId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CustomRequestResponseModel;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/{customRequestResponseId}/addLargeImage/{mediaItemId}'
            .replace('{' + 'customRequestResponseId' + '}', encodeURIComponent(String(customRequestResponseId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRequestResponseId' is not null or undefined
        if (customRequestResponseId === null || customRequestResponseId === undefined) {
            throw new Error('Required parameter customRequestResponseId was null or undefined when calling addLargeImage.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addLargeImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CustomRequestResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRequestResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a small image item to the given response
     * @param customRequestResponseId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addSmallImage (customRequestResponseId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CustomRequestResponseModel;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/{customRequestResponseId}/addSmallImage/{mediaItemId}'
            .replace('{' + 'customRequestResponseId' + '}', encodeURIComponent(String(customRequestResponseId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRequestResponseId' is not null or undefined
        if (customRequestResponseId === null || customRequestResponseId === undefined) {
            throw new Error('Required parameter customRequestResponseId was null or undefined when calling addSmallImage.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addSmallImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CustomRequestResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRequestResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a video file to the given response
     * @param customRequestResponseId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addVideoFile (customRequestResponseId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CustomRequestResponseModel;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/{customRequestResponseId}/addVideoFile/{mediaItemId}'
            .replace('{' + 'customRequestResponseId' + '}', encodeURIComponent(String(customRequestResponseId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRequestResponseId' is not null or undefined
        if (customRequestResponseId === null || customRequestResponseId === undefined) {
            throw new Error('Required parameter customRequestResponseId was null or undefined when calling addVideoFile.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addVideoFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CustomRequestResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRequestResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param customRequestId 
     * @param webhookId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public addWebhook (customRequestId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CustomRequestWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/{customRequestId}/webhooks/{webhookId}'
            .replace('{' + 'customRequestId' + '}', encodeURIComponent(String(customRequestId)))
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRequestId' is not null or undefined
        if (customRequestId === null || customRequestId === undefined) {
            throw new Error('Required parameter customRequestId was null or undefined when calling addWebhook.');
        }

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling addWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CustomRequestWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRequestWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param customRequestId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public bulkUpdateCustomRequest (customRequestId: string, model?: BulkUpdateCustomRequestRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CustomRequestModel;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/{customRequestId}/bulkUpdate'
            .replace('{' + 'customRequestId' + '}', encodeURIComponent(String(customRequestId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRequestId' is not null or undefined
        if (customRequestId === null || customRequestId === undefined) {
            throw new Error('Required parameter customRequestId was null or undefined when calling bulkUpdateCustomRequest.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BulkUpdateCustomRequestRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CustomRequestModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRequestModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param customRequestId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public bulkUpdateCustomRequestStub (customRequestId: string, model?: BulkUpdateCustomRequestStubRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CustomRequestModel;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/{customRequestId}/bulkUpdate/stub'
            .replace('{' + 'customRequestId' + '}', encodeURIComponent(String(customRequestId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRequestId' is not null or undefined
        if (customRequestId === null || customRequestId === undefined) {
            throw new Error('Required parameter customRequestId was null or undefined when calling bulkUpdateCustomRequestStub.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BulkUpdateCustomRequestStubRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CustomRequestModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRequestModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param customRequestId 
     * @param {*} [options] Override http request options.
     */
    public copyContentItem (customRequestId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CustomRequestModel;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/{customRequestId}/copy'
            .replace('{' + 'customRequestId' + '}', encodeURIComponent(String(customRequestId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRequestId' is not null or undefined
        if (customRequestId === null || customRequestId === undefined) {
            throw new Error('Required parameter customRequestId was null or undefined when calling copyContentItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CustomRequestModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRequestModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new custom request entity
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createCustomRequest (model?: NewCustomRequestRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CustomRequestModel;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewCustomRequestRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CustomRequestModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRequestModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new custom request entity
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createCustomRequestStub (model?: NewCustomRequestStubRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CustomRequestModel;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/stub';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewCustomRequestStubRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CustomRequestModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRequestModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createFullContentItem (model?: CustomRequestModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CustomRequestModel;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/full';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "CustomRequestModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CustomRequestModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRequestModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new response varation for the given message
     * @param customRequestId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createResponse (customRequestId: string, model?: NewCustomRequestResponseRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CustomRequestResponseModel;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/{customRequestId}/response'
            .replace('{' + 'customRequestId' + '}', encodeURIComponent(String(customRequestId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRequestId' is not null or undefined
        if (customRequestId === null || customRequestId === undefined) {
            throw new Error('Required parameter customRequestId was null or undefined when calling createResponse.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewCustomRequestResponseRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CustomRequestResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRequestResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete the given custom request
     * @param customRequestId 
     * @param {*} [options] Override http request options.
     */
    public deleteCustomRequest (customRequestId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CustomRequestModel;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/{customRequestId}'
            .replace('{' + 'customRequestId' + '}', encodeURIComponent(String(customRequestId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRequestId' is not null or undefined
        if (customRequestId === null || customRequestId === undefined) {
            throw new Error('Required parameter customRequestId was null or undefined when calling deleteCustomRequest.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CustomRequestModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRequestModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes the given response
     * @param customRequestResponseId 
     * @param {*} [options] Override http request options.
     */
    public deleteResponse (customRequestResponseId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CustomRequestResponseModel;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/response/{customRequestResponseId}'
            .replace('{' + 'customRequestResponseId' + '}', encodeURIComponent(String(customRequestResponseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRequestResponseId' is not null or undefined
        if (customRequestResponseId === null || customRequestResponseId === undefined) {
            throw new Error('Required parameter customRequestResponseId was null or undefined when calling deleteResponse.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CustomRequestResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRequestResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Finds the full content item by id
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public findFullById (id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CustomRequestModel;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/full/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findFullById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CustomRequestModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRequestModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the content for the given application feature
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public getByApplicationFeature (applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<CustomRequestModel>;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/byFeature/{applicationFeatureId}'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling getByApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<CustomRequestModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<CustomRequestModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param customRequestResponseId 
     * @param {*} [options] Override http request options.
     */
    public getMediaItemsForCustomRequest (customRequestResponseId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<MediaItemModel>;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/response/{customRequestResponseId}/media'
            .replace('{' + 'customRequestResponseId' + '}', encodeURIComponent(String(customRequestResponseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRequestResponseId' is not null or undefined
        if (customRequestResponseId === null || customRequestResponseId === undefined) {
            throw new Error('Required parameter customRequestResponseId was null or undefined when calling getMediaItemsForCustomRequest.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<MediaItemModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<MediaItemModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the custom requests content for the given application  regardless of module
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getMessagesForApplication (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<CustomRequestModel>;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getMessagesForApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<CustomRequestModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<CustomRequestModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the custom requests for the given application module
     * @param applicationModuleId 
     * @param {*} [options] Override http request options.
     */
    public getMessagesForModule (applicationModuleId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<CustomRequestModel>;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/module/{applicationModuleId}'
            .replace('{' + 'applicationModuleId' + '}', encodeURIComponent(String(applicationModuleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationModuleId' is not null or undefined
        if (applicationModuleId === null || applicationModuleId === undefined) {
            throw new Error('Required parameter applicationModuleId was null or undefined when calling getMessagesForModule.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<CustomRequestModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<CustomRequestModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param customRequestId 
     * @param {*} [options] Override http request options.
     */
    public getWebhooks (customRequestId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<CustomRequestWebhookModel>;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/{customRequestId}/webhooks'
            .replace('{' + 'customRequestId' + '}', encodeURIComponent(String(customRequestId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRequestId' is not null or undefined
        if (customRequestId === null || customRequestId === undefined) {
            throw new Error('Required parameter customRequestId was null or undefined when calling getWebhooks.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<CustomRequestWebhookModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<CustomRequestWebhookModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param contentItemId 
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public moveContentItemToApplicationFeature (contentItemId: string, applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CustomRequestModel;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/{contentItemId}/MoveToFeature/{applicationFeatureId}'
            .replace('{' + 'contentItemId' + '}', encodeURIComponent(String(contentItemId)))
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentItemId' is not null or undefined
        if (contentItemId === null || contentItemId === undefined) {
            throw new Error('Required parameter contentItemId was null or undefined when calling moveContentItemToApplicationFeature.');
        }

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling moveContentItemToApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CustomRequestModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRequestModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param customRequestWebhookId 
     * @param {*} [options] Override http request options.
     */
    public removeWebhook (customRequestWebhookId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CustomRequestWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/webhook/{customRequestWebhookId}'
            .replace('{' + 'customRequestWebhookId' + '}', encodeURIComponent(String(customRequestWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRequestWebhookId' is not null or undefined
        if (customRequestWebhookId === null || customRequestWebhookId === undefined) {
            throw new Error('Required parameter customRequestWebhookId was null or undefined when calling removeWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CustomRequestWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRequestWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Toggles the given message as live or not
     * @param customRequestId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public toggleLive (customRequestId: string, model?: ToggleLiveRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CustomRequestModel;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/{customRequestId}/isLive'
            .replace('{' + 'customRequestId' + '}', encodeURIComponent(String(customRequestId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRequestId' is not null or undefined
        if (customRequestId === null || customRequestId === undefined) {
            throw new Error('Required parameter customRequestId was null or undefined when calling toggleLive.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "ToggleLiveRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CustomRequestModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRequestModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param customRequestId 
     * @param webhookInstanceId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public updateAttachedWebhook (customRequestId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CustomRequestWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/{customRequestId}/webhooks/{webhookInstanceId}'
            .replace('{' + 'customRequestId' + '}', encodeURIComponent(String(customRequestId)))
            .replace('{' + 'webhookInstanceId' + '}', encodeURIComponent(String(webhookInstanceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRequestId' is not null or undefined
        if (customRequestId === null || customRequestId === undefined) {
            throw new Error('Required parameter customRequestId was null or undefined when calling updateAttachedWebhook.');
        }

        // verify required parameter 'webhookInstanceId' is not null or undefined
        if (webhookInstanceId === null || webhookInstanceId === undefined) {
            throw new Error('Required parameter webhookInstanceId was null or undefined when calling updateAttachedWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CustomRequestWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRequestWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param contentItemId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateFullContentItem (contentItemId: string, model?: CustomRequestModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CustomRequestModel;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/{contentItemId}/full'
            .replace('{' + 'contentItemId' + '}', encodeURIComponent(String(contentItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentItemId' is not null or undefined
        if (contentItemId === null || contentItemId === undefined) {
            throw new Error('Required parameter contentItemId was null or undefined when calling updateFullContentItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "CustomRequestModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CustomRequestModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRequestModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the custom request with the given fields  If you send null or no value for fields, they won't be updated
     * @param customRequestId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateMessage (customRequestId: string, model?: UpdateCustomRequestRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CustomRequestModel;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/{customRequestId}'
            .replace('{' + 'customRequestId' + '}', encodeURIComponent(String(customRequestId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRequestId' is not null or undefined
        if (customRequestId === null || customRequestId === undefined) {
            throw new Error('Required parameter customRequestId was null or undefined when calling updateMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateCustomRequestRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CustomRequestModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRequestModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the given response
     * @param customRequestResponseId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateResponse (customRequestResponseId: string, model?: UpdateCustomRequestResponseRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: CustomRequestResponseModel;  }> {
        const localVarPath = this.basePath + '/api/CustomRequest/response/{customRequestResponseId}'
            .replace('{' + 'customRequestResponseId' + '}', encodeURIComponent(String(customRequestResponseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'customRequestResponseId' is not null or undefined
        if (customRequestResponseId === null || customRequestResponseId === undefined) {
            throw new Error('Required parameter customRequestResponseId was null or undefined when calling updateResponse.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateCustomRequestResponseRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: CustomRequestResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "CustomRequestResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DeviceTargetApiApiKeys {
    Bearer,
}

export class DeviceTargetApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DeviceTargetApiApiKeys, value: string) {
        (this.authentications as any)[DeviceTargetApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Returns all the supported device types
     * @param {*} [options] Override http request options.
     */
    public getAllTargets (options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<DeviceTargetModel>;  }> {
        const localVarPath = this.basePath + '/api/DeviceTarget';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<DeviceTargetModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<DeviceTargetModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param deviceTargetId 
     * @param {*} [options] Override http request options.
     */
    public getTarget (deviceTargetId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: DeviceTargetModel;  }> {
        const localVarPath = this.basePath + '/api/DeviceTarget/{deviceTargetId}'
            .replace('{' + 'deviceTargetId' + '}', encodeURIComponent(String(deviceTargetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'deviceTargetId' is not null or undefined
        if (deviceTargetId === null || deviceTargetId === undefined) {
            throw new Error('Required parameter deviceTargetId was null or undefined when calling getTarget.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DeviceTargetModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DeviceTargetModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DialogflowAgentApiApiKeys {
    Bearer,
}

export class DialogflowAgentApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DialogflowAgentApiApiKeys, value: string) {
        (this.authentications as any)[DialogflowAgentApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param tokenId 
     * @param {*} [options] Override http request options.
     */
    public listDialogflowAgentsAsync (tokenId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<DialogflowAgentInformation>;  }> {
        const localVarPath = this.basePath + '/api/DialogflowAgent/Agents/{tokenId}'
            .replace('{' + 'tokenId' + '}', encodeURIComponent(String(tokenId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tokenId' is not null or undefined
        if (tokenId === null || tokenId === undefined) {
            throw new Error('Required parameter tokenId was null or undefined when calling listDialogflowAgentsAsync.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<DialogflowAgentInformation>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<DialogflowAgentInformation>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum EventsApiApiKeys {
    Bearer,
}

export class EventsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: EventsApiApiKeys, value: string) {
        (this.authentications as any)[EventsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Add a webhook to an event content item
     * @param eventId 
     * @param webhookId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public addWebhook (eventId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EventItemWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/Events/{eventId}/webhooks/{webhookId}'
            .replace('{' + 'eventId' + '}', encodeURIComponent(String(eventId)))
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling addWebhook.');
        }

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling addWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EventItemWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EventItemWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Bulk updates an event and it's categories and responses
     * @param eventId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public bulkUpdate (eventId: string, model?: BulkUpdateEventRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EventItemModel;  }> {
        const localVarPath = this.basePath + '/api/Events/{eventId}/bulkUpdate'
            .replace('{' + 'eventId' + '}', encodeURIComponent(String(eventId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling bulkUpdate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BulkUpdateEventRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EventItemModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EventItemModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Bulk updates an event and it's categories and responses
     * @param eventId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public bulkUpdateStub (eventId: string, model?: BulkUpdateEventStubRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EventItemModel;  }> {
        const localVarPath = this.basePath + '/api/Events/{eventId}/bulkUpdate/stub'
            .replace('{' + 'eventId' + '}', encodeURIComponent(String(eventId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling bulkUpdateStub.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BulkUpdateEventStubRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EventItemModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EventItemModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param eventId 
     * @param {*} [options] Override http request options.
     */
    public copyContentItem (eventId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EventItemModel;  }> {
        const localVarPath = this.basePath + '/api/Events/{eventId}/copy'
            .replace('{' + 'eventId' + '}', encodeURIComponent(String(eventId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling copyContentItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EventItemModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EventItemModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new event item
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createEvent (model?: CreateEventRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EventItemModel;  }> {
        const localVarPath = this.basePath + '/api/Events';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "CreateEventRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EventItemModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EventItemModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new event item
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createEventStub (model?: CreateEventStubRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EventItemModel;  }> {
        const localVarPath = this.basePath + '/api/Events/stub';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "CreateEventStubRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EventItemModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EventItemModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createFullContentItem (model?: EventItemModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EventItemModel;  }> {
        const localVarPath = this.basePath + '/api/Events/full';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "EventItemModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EventItemModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EventItemModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public createUserDefinedParameter (instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/Events/webhook/{instanceWebhookId}/userParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling createUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UserDefinedWebhookParameterCreateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes the given event
     * @param eventId 
     * @param {*} [options] Override http request options.
     */
    public deleteEvent (eventId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EventItemModel;  }> {
        const localVarPath = this.basePath + '/api/Events/{eventId}'
            .replace('{' + 'eventId' + '}', encodeURIComponent(String(eventId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling deleteEvent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EventItemModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EventItemModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Finds the full content item by id
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public findFullById (id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EventItemModel;  }> {
        const localVarPath = this.basePath + '/api/Events/full/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findFullById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EventItemModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EventItemModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the content for the given application feature
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public getByApplicationFeature (applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<EventItemModel>;  }> {
        const localVarPath = this.basePath + '/api/Events/byFeature/{applicationFeatureId}'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling getByApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<EventItemModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<EventItemModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all the event content items for the given module
     * @param applicationModuleId 
     * @param {*} [options] Override http request options.
     */
    public getEventsForModule (applicationModuleId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<EventItemModel>;  }> {
        const localVarPath = this.basePath + '/api/Events/{applicationModuleId}'
            .replace('{' + 'applicationModuleId' + '}', encodeURIComponent(String(applicationModuleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationModuleId' is not null or undefined
        if (applicationModuleId === null || applicationModuleId === undefined) {
            throw new Error('Required parameter applicationModuleId was null or undefined when calling getEventsForModule.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<EventItemModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<EventItemModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get webhooks attached to an event content item
     * @param eventId 
     * @param {*} [options] Override http request options.
     */
    public getWebhooks (eventId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<EventItemWebhookModel>;  }> {
        const localVarPath = this.basePath + '/api/Events/{eventId}/webhooks'
            .replace('{' + 'eventId' + '}', encodeURIComponent(String(eventId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling getWebhooks.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<EventItemWebhookModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<EventItemWebhookModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param contentItemId 
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public moveContentItemToApplicationFeature (contentItemId: string, applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EventItemModel;  }> {
        const localVarPath = this.basePath + '/api/Events/{contentItemId}/MoveToFeature/{applicationFeatureId}'
            .replace('{' + 'contentItemId' + '}', encodeURIComponent(String(contentItemId)))
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentItemId' is not null or undefined
        if (contentItemId === null || contentItemId === undefined) {
            throw new Error('Required parameter contentItemId was null or undefined when calling moveContentItemToApplicationFeature.');
        }

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling moveContentItemToApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EventItemModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EventItemModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param parameterName 
     * @param {*} [options] Override http request options.
     */
    public removeUserDefinedParameter (instanceWebhookId: string, parameterName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/Events/webhook/{instanceWebhookId}/userParameters/{parameterName}'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)))
            .replace('{' + 'parameterName' + '}', encodeURIComponent(String(parameterName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling removeUserDefinedParameter.');
        }

        // verify required parameter 'parameterName' is not null or undefined
        if (parameterName === null || parameterName === undefined) {
            throw new Error('Required parameter parameterName was null or undefined when calling removeUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Remove webhook from an event content item
     * @param eventWebhookId 
     * @param {*} [options] Override http request options.
     */
    public removeWebhook (eventWebhookId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EventItemWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/Events/webhook/{eventWebhookId}'
            .replace('{' + 'eventWebhookId' + '}', encodeURIComponent(String(eventWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'eventWebhookId' is not null or undefined
        if (eventWebhookId === null || eventWebhookId === undefined) {
            throw new Error('Required parameter eventWebhookId was null or undefined when calling removeWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EventItemWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EventItemWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Toggles whether the given event item is live or not
     * @param eventId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public toggleIsLive (eventId: string, model?: ToggleLiveRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EventItemModel;  }> {
        const localVarPath = this.basePath + '/api/Events/{eventId}/isLive'
            .replace('{' + 'eventId' + '}', encodeURIComponent(String(eventId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling toggleIsLive.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "ToggleLiveRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EventItemModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EventItemModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param eventId 
     * @param instanceWebhookId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public updateAttachedWebhook (eventId: string, instanceWebhookId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EventItemWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/Events/{eventId}/webhooks/{instanceWebhookId}'
            .replace('{' + 'eventId' + '}', encodeURIComponent(String(eventId)))
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error('Required parameter eventId was null or undefined when calling updateAttachedWebhook.');
        }

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateAttachedWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EventItemWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EventItemWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param contentItemId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateFullContentItem (contentItemId: string, model?: EventItemModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EventItemModel;  }> {
        const localVarPath = this.basePath + '/api/Events/{contentItemId}/full'
            .replace('{' + 'contentItemId' + '}', encodeURIComponent(String(contentItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentItemId' is not null or undefined
        if (contentItemId === null || contentItemId === undefined) {
            throw new Error('Required parameter contentItemId was null or undefined when calling updateFullContentItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "EventItemModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EventItemModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EventItemModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateUserDefinedParameter (instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/Events/webhook/{instanceWebhookId}/userParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UserDefinedWebhookParameterUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateWebhookParameter (instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/Events/webhook/{instanceWebhookId}/webhookParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateWebhookParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "WebhookParameterUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ExitMessageApiApiKeys {
    Bearer,
}

export class ExitMessageApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ExitMessageApiApiKeys, value: string) {
        (this.authentications as any)[ExitMessageApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds an audio file to the exit message
     * @param exitMessageId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addAudioFileImage (exitMessageId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/{exitMessageId}/addAudioFile/{mediaItemId}'
            .replace('{' + 'exitMessageId' + '}', encodeURIComponent(String(exitMessageId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'exitMessageId' is not null or undefined
        if (exitMessageId === null || exitMessageId === undefined) {
            throw new Error('Required parameter exitMessageId was null or undefined when calling addAudioFileImage.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addAudioFileImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExitMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a new exit message to the given application
     * @param applicationId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public addExitMessage (applicationId: string, model?: NewExitMessageRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling addExitMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewExitMessageRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExitMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a new exit message to the given application
     * @param applicationId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public addExitMessageStub (applicationId: string, model?: NewExitMessageStubRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/{applicationId}/stub'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling addExitMessageStub.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewExitMessageStubRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExitMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a large image to the exit message
     * @param exitMessageId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addLargeImage (exitMessageId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/{exitMessageId}/addLargeImage/{mediaItemId}'
            .replace('{' + 'exitMessageId' + '}', encodeURIComponent(String(exitMessageId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'exitMessageId' is not null or undefined
        if (exitMessageId === null || exitMessageId === undefined) {
            throw new Error('Required parameter exitMessageId was null or undefined when calling addLargeImage.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addLargeImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExitMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a small image to the exit message
     * @param exitMessageId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addSmallImage (exitMessageId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/{exitMessageId}/addSmallImage/{mediaItemId}'
            .replace('{' + 'exitMessageId' + '}', encodeURIComponent(String(exitMessageId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'exitMessageId' is not null or undefined
        if (exitMessageId === null || exitMessageId === undefined) {
            throw new Error('Required parameter exitMessageId was null or undefined when calling addSmallImage.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addSmallImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExitMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a video file to the exit message
     * @param exitMessageId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addVideoFile (exitMessageId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/{exitMessageId}/addVideoFile/{mediaItemId}'
            .replace('{' + 'exitMessageId' + '}', encodeURIComponent(String(exitMessageId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'exitMessageId' is not null or undefined
        if (exitMessageId === null || exitMessageId === undefined) {
            throw new Error('Required parameter exitMessageId was null or undefined when calling addVideoFile.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addVideoFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExitMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param exitMessageId 
     * @param webhookId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public addWebhook (exitMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ExitMessageWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/{exitMessageId}/webhooks/{webhookId}'
            .replace('{' + 'exitMessageId' + '}', encodeURIComponent(String(exitMessageId)))
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'exitMessageId' is not null or undefined
        if (exitMessageId === null || exitMessageId === undefined) {
            throw new Error('Required parameter exitMessageId was null or undefined when calling addWebhook.');
        }

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling addWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ExitMessageWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExitMessageWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param exitMessageId 
     * @param {*} [options] Override http request options.
     */
    public copyContentItem (exitMessageId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/{exitMessageId}/copy'
            .replace('{' + 'exitMessageId' + '}', encodeURIComponent(String(exitMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'exitMessageId' is not null or undefined
        if (exitMessageId === null || exitMessageId === undefined) {
            throw new Error('Required parameter exitMessageId was null or undefined when calling copyContentItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExitMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new custom request entity from a dto
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createFullCustomRequest (model?: ExitMessageModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/full';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "ExitMessageModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExitMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public createUserDefinedParameter (instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/webhook/{instanceWebhookId}/userParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling createUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UserDefinedWebhookParameterCreateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes the given message
     * @param exitMessageId 
     * @param {*} [options] Override http request options.
     */
    public deleteExitMessage (exitMessageId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/{exitMessageId}'
            .replace('{' + 'exitMessageId' + '}', encodeURIComponent(String(exitMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'exitMessageId' is not null or undefined
        if (exitMessageId === null || exitMessageId === undefined) {
            throw new Error('Required parameter exitMessageId was null or undefined when calling deleteExitMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExitMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Finds the full content item by id
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public findFullById (id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/full/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findFullById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExitMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the content for the given application feature
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public getByApplicationFeature (applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ExitMessageModel>;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/byFeature/{applicationFeatureId}'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling getByApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ExitMessageModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ExitMessageModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the exit messages for the given application
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getExitMessagesForApplication (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ExitMessageModel>;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getExitMessagesForApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ExitMessageModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ExitMessageModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param exitMessageId 
     * @param {*} [options] Override http request options.
     */
    public getWebhooks (exitMessageId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ExitMessageWebhookModel>;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/{exitMessageId}/webhooks'
            .replace('{' + 'exitMessageId' + '}', encodeURIComponent(String(exitMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'exitMessageId' is not null or undefined
        if (exitMessageId === null || exitMessageId === undefined) {
            throw new Error('Required parameter exitMessageId was null or undefined when calling getWebhooks.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ExitMessageWebhookModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ExitMessageWebhookModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param contentItemId 
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public moveContentItemToApplicationFeature (contentItemId: string, applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/{contentItemId}/MoveToFeature/{applicationFeatureId}'
            .replace('{' + 'contentItemId' + '}', encodeURIComponent(String(contentItemId)))
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentItemId' is not null or undefined
        if (contentItemId === null || contentItemId === undefined) {
            throw new Error('Required parameter contentItemId was null or undefined when calling moveContentItemToApplicationFeature.');
        }

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling moveContentItemToApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExitMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param parameterName 
     * @param {*} [options] Override http request options.
     */
    public removeUserDefinedParameter (instanceWebhookId: string, parameterName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/webhook/{instanceWebhookId}/userParameters/{parameterName}'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)))
            .replace('{' + 'parameterName' + '}', encodeURIComponent(String(parameterName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling removeUserDefinedParameter.');
        }

        // verify required parameter 'parameterName' is not null or undefined
        if (parameterName === null || parameterName === undefined) {
            throw new Error('Required parameter parameterName was null or undefined when calling removeUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param exitMessageWebhookId 
     * @param {*} [options] Override http request options.
     */
    public removeWebhook (exitMessageWebhookId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ExitMessageWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/webhook/{exitMessageWebhookId}'
            .replace('{' + 'exitMessageWebhookId' + '}', encodeURIComponent(String(exitMessageWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'exitMessageWebhookId' is not null or undefined
        if (exitMessageWebhookId === null || exitMessageWebhookId === undefined) {
            throw new Error('Required parameter exitMessageWebhookId was null or undefined when calling removeWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ExitMessageWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExitMessageWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Toggles whether the given exit message is live or not
     * @param exitMessageId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public toggleIsLive (exitMessageId: string, model?: ToggleLiveRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/{exitMessageId}/isLive'
            .replace('{' + 'exitMessageId' + '}', encodeURIComponent(String(exitMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'exitMessageId' is not null or undefined
        if (exitMessageId === null || exitMessageId === undefined) {
            throw new Error('Required parameter exitMessageId was null or undefined when calling toggleIsLive.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "ToggleLiveRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExitMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param exitMessageId 
     * @param instanceWebhookId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public updateAttachedWebhook (exitMessageId: string, instanceWebhookId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ExitMessageWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/{exitMessageId}/webhooks/{instanceWebhookId}'
            .replace('{' + 'exitMessageId' + '}', encodeURIComponent(String(exitMessageId)))
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'exitMessageId' is not null or undefined
        if (exitMessageId === null || exitMessageId === undefined) {
            throw new Error('Required parameter exitMessageId was null or undefined when calling updateAttachedWebhook.');
        }

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateAttachedWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ExitMessageWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExitMessageWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the content of the given exit message id
     * @param exitMessageId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateExitMessage (exitMessageId: string, model?: UpdateExitMessageRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/{exitMessageId}/update'
            .replace('{' + 'exitMessageId' + '}', encodeURIComponent(String(exitMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'exitMessageId' is not null or undefined
        if (exitMessageId === null || exitMessageId === undefined) {
            throw new Error('Required parameter exitMessageId was null or undefined when calling updateExitMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateExitMessageRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExitMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the content of the given exit message id
     * @param exitMessageId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateExitMessageStub (exitMessageId: string, model?: UpdateExitMessageStubRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/{exitMessageId}/update/stub'
            .replace('{' + 'exitMessageId' + '}', encodeURIComponent(String(exitMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'exitMessageId' is not null or undefined
        if (exitMessageId === null || exitMessageId === undefined) {
            throw new Error('Required parameter exitMessageId was null or undefined when calling updateExitMessageStub.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateExitMessageStubRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExitMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param contentItemId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateFullContentItem (contentItemId: string, model?: ExitMessageModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/{contentItemId}/full'
            .replace('{' + 'contentItemId' + '}', encodeURIComponent(String(contentItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentItemId' is not null or undefined
        if (contentItemId === null || contentItemId === undefined) {
            throw new Error('Required parameter contentItemId was null or undefined when calling updateFullContentItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "ExitMessageModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ExitMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExitMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateUserDefinedParameter (instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/webhook/{instanceWebhookId}/userParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UserDefinedWebhookParameterUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateWebhookParameter (instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/ExitMessage/webhook/{instanceWebhookId}/webhookParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateWebhookParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "WebhookParameterUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FallbackMessageApiApiKeys {
    Bearer,
}

export class FallbackMessageApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FallbackMessageApiApiKeys, value: string) {
        (this.authentications as any)[FallbackMessageApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds an audio file to the fallback message
     * @param fallbackMessageId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addAudioFileImage (fallbackMessageId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/{fallbackMessageId}/addAudioFile/{mediaItemId}'
            .replace('{' + 'fallbackMessageId' + '}', encodeURIComponent(String(fallbackMessageId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fallbackMessageId' is not null or undefined
        if (fallbackMessageId === null || fallbackMessageId === undefined) {
            throw new Error('Required parameter fallbackMessageId was null or undefined when calling addAudioFileImage.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addAudioFileImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FallbackMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a new fallback message to the given application
     * @param applicationId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public addFallbackMessage (applicationId: string, model?: NewFallbackMessageRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling addFallbackMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewFallbackMessageRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FallbackMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a new fallback message to the given application
     * @param applicationId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public addFallbackMessageStub (applicationId: string, model?: NewFallbackMessageStubRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/{applicationId}/stub'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling addFallbackMessageStub.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewFallbackMessageStubRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FallbackMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a large image to the fallback message
     * @param fallbackMessageId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addLargeImage (fallbackMessageId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/{fallbackMessageId}/addLargeImage/{mediaItemId}'
            .replace('{' + 'fallbackMessageId' + '}', encodeURIComponent(String(fallbackMessageId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fallbackMessageId' is not null or undefined
        if (fallbackMessageId === null || fallbackMessageId === undefined) {
            throw new Error('Required parameter fallbackMessageId was null or undefined when calling addLargeImage.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addLargeImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FallbackMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a small image to the fallback message
     * @param fallbackMessageId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addSmallImage (fallbackMessageId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/{fallbackMessageId}/addSmallImage/{mediaItemId}'
            .replace('{' + 'fallbackMessageId' + '}', encodeURIComponent(String(fallbackMessageId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fallbackMessageId' is not null or undefined
        if (fallbackMessageId === null || fallbackMessageId === undefined) {
            throw new Error('Required parameter fallbackMessageId was null or undefined when calling addSmallImage.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addSmallImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FallbackMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a video file to the fallback message
     * @param fallbackMessageId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addVideoFile (fallbackMessageId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/{fallbackMessageId}/addVideoFile/{mediaItemId}'
            .replace('{' + 'fallbackMessageId' + '}', encodeURIComponent(String(fallbackMessageId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fallbackMessageId' is not null or undefined
        if (fallbackMessageId === null || fallbackMessageId === undefined) {
            throw new Error('Required parameter fallbackMessageId was null or undefined when calling addVideoFile.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addVideoFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FallbackMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param fallbackMessageId 
     * @param webhookId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public addWebhook (fallbackMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FallbackMessageWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/{fallbackMessageId}/webhooks/{webhookId}'
            .replace('{' + 'fallbackMessageId' + '}', encodeURIComponent(String(fallbackMessageId)))
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fallbackMessageId' is not null or undefined
        if (fallbackMessageId === null || fallbackMessageId === undefined) {
            throw new Error('Required parameter fallbackMessageId was null or undefined when calling addWebhook.');
        }

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling addWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FallbackMessageWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FallbackMessageWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param fallbackMessageId 
     * @param {*} [options] Override http request options.
     */
    public copyContentItem (fallbackMessageId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/{fallbackMessageId}/copy'
            .replace('{' + 'fallbackMessageId' + '}', encodeURIComponent(String(fallbackMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fallbackMessageId' is not null or undefined
        if (fallbackMessageId === null || fallbackMessageId === undefined) {
            throw new Error('Required parameter fallbackMessageId was null or undefined when calling copyContentItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FallbackMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createFullContentItem (model?: FallbackMessageModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/full';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "FallbackMessageModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FallbackMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public createUserDefinedParameter (instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/webhook/{instanceWebhookId}/userParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling createUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UserDefinedWebhookParameterCreateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes the given message
     * @param fallbackMessageId 
     * @param {*} [options] Override http request options.
     */
    public deleteFallbackMessage (fallbackMessageId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/{fallbackMessageId}'
            .replace('{' + 'fallbackMessageId' + '}', encodeURIComponent(String(fallbackMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fallbackMessageId' is not null or undefined
        if (fallbackMessageId === null || fallbackMessageId === undefined) {
            throw new Error('Required parameter fallbackMessageId was null or undefined when calling deleteFallbackMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FallbackMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Finds the full content item by id
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public findFullById (id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/full/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findFullById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FallbackMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the content for the given application feature
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public getByApplicationFeature (applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<FallbackMessageModel>;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/byFeature/{applicationFeatureId}'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling getByApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<FallbackMessageModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<FallbackMessageModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getCategories (options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<FallbackMessageCategoryModel>;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/categories';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<FallbackMessageCategoryModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<FallbackMessageCategoryModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the fallback messages for the given application
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getFallbackMessagesForApplication (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<FallbackMessageModel>;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getFallbackMessagesForApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<FallbackMessageModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<FallbackMessageModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param fallbackMessageId 
     * @param {*} [options] Override http request options.
     */
    public getWebhooks (fallbackMessageId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<FallbackMessageWebhookModel>;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/{fallbackMessageId}/webhooks'
            .replace('{' + 'fallbackMessageId' + '}', encodeURIComponent(String(fallbackMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fallbackMessageId' is not null or undefined
        if (fallbackMessageId === null || fallbackMessageId === undefined) {
            throw new Error('Required parameter fallbackMessageId was null or undefined when calling getWebhooks.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<FallbackMessageWebhookModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<FallbackMessageWebhookModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param contentItemId 
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public moveContentItemToApplicationFeature (contentItemId: string, applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/{contentItemId}/MoveToFeature/{applicationFeatureId}'
            .replace('{' + 'contentItemId' + '}', encodeURIComponent(String(contentItemId)))
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentItemId' is not null or undefined
        if (contentItemId === null || contentItemId === undefined) {
            throw new Error('Required parameter contentItemId was null or undefined when calling moveContentItemToApplicationFeature.');
        }

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling moveContentItemToApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FallbackMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param parameterName 
     * @param {*} [options] Override http request options.
     */
    public removeUserDefinedParameter (instanceWebhookId: string, parameterName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/webhook/{instanceWebhookId}/userParameters/{parameterName}'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)))
            .replace('{' + 'parameterName' + '}', encodeURIComponent(String(parameterName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling removeUserDefinedParameter.');
        }

        // verify required parameter 'parameterName' is not null or undefined
        if (parameterName === null || parameterName === undefined) {
            throw new Error('Required parameter parameterName was null or undefined when calling removeUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param fallbackMessageWebhookId 
     * @param {*} [options] Override http request options.
     */
    public removeWebhook (fallbackMessageWebhookId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FallbackMessageWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/webhook/{fallbackMessageWebhookId}'
            .replace('{' + 'fallbackMessageWebhookId' + '}', encodeURIComponent(String(fallbackMessageWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fallbackMessageWebhookId' is not null or undefined
        if (fallbackMessageWebhookId === null || fallbackMessageWebhookId === undefined) {
            throw new Error('Required parameter fallbackMessageWebhookId was null or undefined when calling removeWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FallbackMessageWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FallbackMessageWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Toggles whether the given fallback Message is live or not
     * @param fallbackMessageId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public toggleIsLive (fallbackMessageId: string, model?: ToggleLiveRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/{fallbackMessageId}/isLive'
            .replace('{' + 'fallbackMessageId' + '}', encodeURIComponent(String(fallbackMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fallbackMessageId' is not null or undefined
        if (fallbackMessageId === null || fallbackMessageId === undefined) {
            throw new Error('Required parameter fallbackMessageId was null or undefined when calling toggleIsLive.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "ToggleLiveRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FallbackMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param fallbackMessageId 
     * @param instanceWebhookId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public updateAttachedWebhook (fallbackMessageId: string, instanceWebhookId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FallbackMessageWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/{fallbackMessageId}/webhooks/{instanceWebhookId}'
            .replace('{' + 'fallbackMessageId' + '}', encodeURIComponent(String(fallbackMessageId)))
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fallbackMessageId' is not null or undefined
        if (fallbackMessageId === null || fallbackMessageId === undefined) {
            throw new Error('Required parameter fallbackMessageId was null or undefined when calling updateAttachedWebhook.');
        }

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateAttachedWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FallbackMessageWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FallbackMessageWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the content of the given fallback message id
     * @param fallbackMessageId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateFallbackMessage (fallbackMessageId: string, model?: UpdateFallbackMessageRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/{fallbackMessageId}/update'
            .replace('{' + 'fallbackMessageId' + '}', encodeURIComponent(String(fallbackMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fallbackMessageId' is not null or undefined
        if (fallbackMessageId === null || fallbackMessageId === undefined) {
            throw new Error('Required parameter fallbackMessageId was null or undefined when calling updateFallbackMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateFallbackMessageRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FallbackMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the content of the given fallback message id
     * @param fallbackMessageId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateFallbackMessageStub (fallbackMessageId: string, model?: UpdateFallbackMessageStubRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/{fallbackMessageId}/update/stub'
            .replace('{' + 'fallbackMessageId' + '}', encodeURIComponent(String(fallbackMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'fallbackMessageId' is not null or undefined
        if (fallbackMessageId === null || fallbackMessageId === undefined) {
            throw new Error('Required parameter fallbackMessageId was null or undefined when calling updateFallbackMessageStub.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateFallbackMessageStubRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FallbackMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param contentItemId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateFullContentItem (contentItemId: string, model?: FallbackMessageModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/{contentItemId}/full'
            .replace('{' + 'contentItemId' + '}', encodeURIComponent(String(contentItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentItemId' is not null or undefined
        if (contentItemId === null || contentItemId === undefined) {
            throw new Error('Required parameter contentItemId was null or undefined when calling updateFullContentItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "FallbackMessageModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FallbackMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FallbackMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateUserDefinedParameter (instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/webhook/{instanceWebhookId}/userParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UserDefinedWebhookParameterUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateWebhookParameter (instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/FallbackMessage/webhook/{instanceWebhookId}/webhookParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateWebhookParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "WebhookParameterUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FeatureApiApiKeys {
    Bearer,
}

export class FeatureApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FeatureApiApiKeys, value: string) {
        (this.authentications as any)[FeatureApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Create a top level application feature
     * @param applicationId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public addFeatureAsync (applicationId: string, request?: CreateApplicationFeatureRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationFeatureModel;  }> {
        const localVarPath = this.basePath + '/api/Feature/{applicationId}/AddFeature'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling addFeatureAsync.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "CreateApplicationFeatureRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationFeatureModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationFeatureModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationFeatureId 
     * @param webhookId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public addWebhook (applicationFeatureId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationFeatureWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/Feature/{applicationFeatureId}/webhooks/{webhookId}'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)))
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling addWebhook.');
        }

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling addWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationFeatureWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationFeatureWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationFeatureId 
     * @param applicationModuleId 
     * @param {*} [options] Override http request options.
     */
    public changeModule (applicationFeatureId: string, applicationModuleId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationFeatureModel;  }> {
        const localVarPath = this.basePath + '/api/Feature/{applicationFeatureId}/changeModule/{applicationModuleId}'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)))
            .replace('{' + 'applicationModuleId' + '}', encodeURIComponent(String(applicationModuleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling changeModule.');
        }

        // verify required parameter 'applicationModuleId' is not null or undefined
        if (applicationModuleId === null || applicationModuleId === undefined) {
            throw new Error('Required parameter applicationModuleId was null or undefined when calling changeModule.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationFeatureModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationFeatureModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public createUserDefinedParameter (instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/Feature/webhook/{instanceWebhookId}/userParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling createUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UserDefinedWebhookParameterCreateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes the given feature
     * @param applicationFeatureId The id of the application feature
     * @param {*} [options] Override http request options.
     */
    public deleteFeature (applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationFeatureModel;  }> {
        const localVarPath = this.basePath + '/api/Feature/{applicationFeatureId}'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling deleteFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationFeatureModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationFeatureModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Disables the given feature
     * @param applicationFeatureId The id of the application feature
     * @param {*} [options] Override http request options.
     */
    public disableFeature (applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationFeatureModel;  }> {
        const localVarPath = this.basePath + '/api/Feature/{applicationFeatureId}/disable'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling disableFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationFeatureModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationFeatureModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Enables the given feature
     * @param applicationFeatureId The id of the application feature
     * @param {*} [options] Override http request options.
     */
    public enableFeature (applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationFeatureModel;  }> {
        const localVarPath = this.basePath + '/api/Feature/{applicationFeatureId}/enable'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling enableFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationFeatureModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationFeatureModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getAppFeaturesWithCounts (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ConversationCountModel>;  }> {
        const localVarPath = this.basePath + '/api/Feature/{applicationId}/features/conversationCounts'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getAppFeaturesWithCounts.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ConversationCountModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ConversationCountModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the list of available features for an application
     * @param applicationId The Id of an application
     * @param {*} [options] Override http request options.
     */
    public getAvailableApplicationFeatures (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<FeatureModel>;  }> {
        const localVarPath = this.basePath + '/api/Feature/{applicationId}/Available'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getAvailableApplicationFeatures.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<FeatureModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<FeatureModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the built in features supported by Voicify
     * @param {*} [options] Override http request options.
     */
    public getBuiltInFeatures (options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<FeatureModel>;  }> {
        const localVarPath = this.basePath + '/api/Feature/BuiltIn';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<FeatureModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<FeatureModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public getContentItemsForApplicationFeature (applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<GenericContentModel>;  }> {
        const localVarPath = this.basePath + '/api/Feature/{applicationFeatureId}/content'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling getContentItemsForApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<GenericContentModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<GenericContentModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets all the available feature types
     * @param {*} [options] Override http request options.
     */
    public getFeatureTypes (options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<FeatureTypeModel>;  }> {
        const localVarPath = this.basePath + '/api/Feature/Types';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<FeatureTypeModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<FeatureTypeModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the features for the given application
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getFeaturesForApplication (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ApplicationFeatureModel>;  }> {
        const localVarPath = this.basePath + '/api/Feature/{applicationId}/features'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getFeaturesForApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ApplicationFeatureModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ApplicationFeatureModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public getWebhooks (applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ApplicationFeatureWebhookModel>;  }> {
        const localVarPath = this.basePath + '/api/Feature/{applicationFeatureId}/webhooks'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling getWebhooks.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ApplicationFeatureWebhookModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ApplicationFeatureWebhookModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param parameterName 
     * @param {*} [options] Override http request options.
     */
    public removeUserDefinedParameter (instanceWebhookId: string, parameterName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/Feature/webhook/{instanceWebhookId}/userParameters/{parameterName}'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)))
            .replace('{' + 'parameterName' + '}', encodeURIComponent(String(parameterName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling removeUserDefinedParameter.');
        }

        // verify required parameter 'parameterName' is not null or undefined
        if (parameterName === null || parameterName === undefined) {
            throw new Error('Required parameter parameterName was null or undefined when calling removeUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationFeatureWebhookId 
     * @param {*} [options] Override http request options.
     */
    public removeWebhook (applicationFeatureWebhookId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationFeatureWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/Feature/webhook/{applicationFeatureWebhookId}'
            .replace('{' + 'applicationFeatureWebhookId' + '}', encodeURIComponent(String(applicationFeatureWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureWebhookId' is not null or undefined
        if (applicationFeatureWebhookId === null || applicationFeatureWebhookId === undefined) {
            throw new Error('Required parameter applicationFeatureWebhookId was null or undefined when calling removeWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationFeatureWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationFeatureWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param parentApplicationFeatureId 
     * @param applicationFeatureIds 
     * @param {*} [options] Override http request options.
     */
    public setApplicationFeatureOrder (applicationId: string, parentApplicationFeatureId?: string, applicationFeatureIds?: Array<string>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ApplicationFeatureModel>;  }> {
        const localVarPath = this.basePath + '/api/Feature/{applicationId}/reorderFeatures'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling setApplicationFeatureOrder.');
        }

        if (parentApplicationFeatureId !== undefined) {
            localVarQueryParameters['parentApplicationFeatureId'] = ObjectSerializer.serialize(parentApplicationFeatureId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(applicationFeatureIds, "Array<string>")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ApplicationFeatureModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ApplicationFeatureModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationFeatureId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateApplicationFeature (applicationFeatureId: string, model?: UpdateApplicationFeatureRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationFeatureModel;  }> {
        const localVarPath = this.basePath + '/api/Feature/{applicationFeatureId}/update'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling updateApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateApplicationFeatureRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationFeatureModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationFeatureModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationFeatureId 
     * @param webhookInstanceId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public updateAttachedWebhook (applicationFeatureId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationFeatureWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/Feature/{applicationFeatureId}/webhooks/{webhookInstanceId}'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)))
            .replace('{' + 'webhookInstanceId' + '}', encodeURIComponent(String(webhookInstanceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling updateAttachedWebhook.');
        }

        // verify required parameter 'webhookInstanceId' is not null or undefined
        if (webhookInstanceId === null || webhookInstanceId === undefined) {
            throw new Error('Required parameter webhookInstanceId was null or undefined when calling updateAttachedWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationFeatureWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationFeatureWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationFeatureId 
     * @param parentApplicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public updateParentForApplicationFeature (applicationFeatureId: string, parentApplicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApplicationFeatureModel;  }> {
        const localVarPath = this.basePath + '/api/Feature/{applicationFeatureId}/updateParent/{parentApplicationFeatureId}'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)))
            .replace('{' + 'parentApplicationFeatureId' + '}', encodeURIComponent(String(parentApplicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling updateParentForApplicationFeature.');
        }

        // verify required parameter 'parentApplicationFeatureId' is not null or undefined
        if (parentApplicationFeatureId === null || parentApplicationFeatureId === undefined) {
            throw new Error('Required parameter parentApplicationFeatureId was null or undefined when calling updateParentForApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApplicationFeatureModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApplicationFeatureModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateUserDefinedParameter (instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/Feature/webhook/{instanceWebhookId}/userParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UserDefinedWebhookParameterUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateWebhookParameter (instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/Feature/webhook/{instanceWebhookId}/webhookParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateWebhookParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "WebhookParameterUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum FollowUpApiApiKeys {
    Bearer,
}

export class FollowUpApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: FollowUpApiApiKeys, value: string) {
        (this.authentications as any)[FollowUpApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param applicationId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createFollowUp (applicationId: string, model?: CreateFollowUpRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FollowUpModel;  }> {
        const localVarPath = this.basePath + '/api/FollowUp/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling createFollowUp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "CreateFollowUpRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FollowUpModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FollowUpModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param followUpId 
     * @param {*} [options] Override http request options.
     */
    public deleteFollowUp (followUpId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FollowUpModel;  }> {
        const localVarPath = this.basePath + '/api/FollowUp/{followUpId}'
            .replace('{' + 'followUpId' + '}', encodeURIComponent(String(followUpId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'followUpId' is not null or undefined
        if (followUpId === null || followUpId === undefined) {
            throw new Error('Required parameter followUpId was null or undefined when calling deleteFollowUp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FollowUpModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FollowUpModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param followUpId 
     * @param {*} [options] Override http request options.
     */
    public findChildContentContainer (followUpId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ChildContentContainerModel;  }> {
        const localVarPath = this.basePath + '/api/FollowUp/find/{followUpId}/children'
            .replace('{' + 'followUpId' + '}', encodeURIComponent(String(followUpId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'followUpId' is not null or undefined
        if (followUpId === null || followUpId === undefined) {
            throw new Error('Required parameter followUpId was null or undefined when calling findChildContentContainer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ChildContentContainerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ChildContentContainerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param followUpId 
     * @param {*} [options] Override http request options.
     */
    public findFollowUp (followUpId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FollowUpModel;  }> {
        const localVarPath = this.basePath + '/api/FollowUp/find/{followUpId}'
            .replace('{' + 'followUpId' + '}', encodeURIComponent(String(followUpId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'followUpId' is not null or undefined
        if (followUpId === null || followUpId === undefined) {
            throw new Error('Required parameter followUpId was null or undefined when calling findFollowUp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FollowUpModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FollowUpModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getForApplication (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<FollowUpModel>;  }> {
        const localVarPath = this.basePath + '/api/FollowUp/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getForApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<FollowUpModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<FollowUpModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param featureTypeId 
     * @param contentId 
     * @param {*} [options] Override http request options.
     */
    public getParentContentItems (featureTypeId: string, contentId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ParentContentContainerModel;  }> {
        const localVarPath = this.basePath + '/api/FollowUp/parents/{featureTypeId}/{contentId}/content'
            .replace('{' + 'featureTypeId' + '}', encodeURIComponent(String(featureTypeId)))
            .replace('{' + 'contentId' + '}', encodeURIComponent(String(contentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'featureTypeId' is not null or undefined
        if (featureTypeId === null || featureTypeId === undefined) {
            throw new Error('Required parameter featureTypeId was null or undefined when calling getParentContentItems.');
        }

        // verify required parameter 'contentId' is not null or undefined
        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling getParentContentItems.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ParentContentContainerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ParentContentContainerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param featureTypeId 
     * @param contentId 
     * @param {*} [options] Override http request options.
     */
    public getParentsOfContent (featureTypeId: string, contentId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<FollowUpModel>;  }> {
        const localVarPath = this.basePath + '/api/FollowUp/parents/{featureTypeId}/{contentId}'
            .replace('{' + 'featureTypeId' + '}', encodeURIComponent(String(featureTypeId)))
            .replace('{' + 'contentId' + '}', encodeURIComponent(String(contentId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'featureTypeId' is not null or undefined
        if (featureTypeId === null || featureTypeId === undefined) {
            throw new Error('Required parameter featureTypeId was null or undefined when calling getParentsOfContent.');
        }

        // verify required parameter 'contentId' is not null or undefined
        if (contentId === null || contentId === undefined) {
            throw new Error('Required parameter contentId was null or undefined when calling getParentsOfContent.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<FollowUpModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<FollowUpModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateFollowUp (model?: UpdateFollowUpRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: FollowUpModel;  }> {
        const localVarPath = this.basePath + '/api/FollowUp';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateFollowUpRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: FollowUpModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "FollowUpModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum GoogleAuthorizationApiApiKeys {
    Bearer,
}

export class GoogleAuthorizationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: GoogleAuthorizationApiApiKeys, value: string) {
        (this.authentications as any)[GoogleAuthorizationApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param organizationId 
     * @param {*} [options] Override http request options.
     */
    public getAvailableGoogleCredentialsAsync (organizationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<TokenResponse>;  }> {
        const localVarPath = this.basePath + '/api/GoogleAuthorization/Credentials/{organizationId}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getAvailableGoogleCredentialsAsync.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<TokenResponse>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TokenResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param code 
     * @param state 
     * @param error 
     * @param {*} [options] Override http request options.
     */
    public googleAuthCallbackAsync (code?: string, state?: string, error?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/GoogleAuthorization/Callback';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (code !== undefined) {
            localVarQueryParameters['code'] = ObjectSerializer.serialize(code, "string");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "string");
        }

        if (error !== undefined) {
            localVarQueryParameters['error'] = ObjectSerializer.serialize(error, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param tokenId 
     * @param {*} [options] Override http request options.
     */
    public removeCredential (tokenId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/GoogleAuthorization/Credentials/{tokenId}'
            .replace('{' + 'tokenId' + '}', encodeURIComponent(String(tokenId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tokenId' is not null or undefined
        if (tokenId === null || tokenId === undefined) {
            throw new Error('Required parameter tokenId was null or undefined when calling removeCredential.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param organizationId 
     * @param applicationId 
     * @param salt 
     * @param {*} [options] Override http request options.
     */
    public requestAuthenticationUrl (organizationId?: string, applicationId?: string, salt?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/GoogleAuthorization/AuthorizationUrl';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (salt !== undefined) {
            localVarQueryParameters['salt'] = ObjectSerializer.serialize(salt, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HealthCheckApiApiKeys {
    Bearer,
}

export class HealthCheckApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HealthCheckApiApiKeys, value: string) {
        (this.authentications as any)[HealthCheckApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public healthCheck (options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/HealthCheck';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HelpMessageApiApiKeys {
    Bearer,
}

export class HelpMessageApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HelpMessageApiApiKeys, value: string) {
        (this.authentications as any)[HelpMessageApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds an audio file to the help message
     * @param helpMessageId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addAudioFileImage (helpMessageId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/{helpMessageId}/addAudioFile/{mediaItemId}'
            .replace('{' + 'helpMessageId' + '}', encodeURIComponent(String(helpMessageId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'helpMessageId' is not null or undefined
        if (helpMessageId === null || helpMessageId === undefined) {
            throw new Error('Required parameter helpMessageId was null or undefined when calling addAudioFileImage.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addAudioFileImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "HelpMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a new help message to the given application
     * @param applicationId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public addHelpMessage (applicationId: string, model?: NewHelpMessageRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling addHelpMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewHelpMessageRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "HelpMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a new help message to the given application
     * @param applicationId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public addHelpMessageStub (applicationId: string, model?: NewHelpMessageStubRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/{applicationId}/stub'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling addHelpMessageStub.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewHelpMessageStubRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "HelpMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a large image to the help message
     * @param helpMessageId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addLargeImage (helpMessageId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/{helpMessageId}/addLargeImage/{mediaItemId}'
            .replace('{' + 'helpMessageId' + '}', encodeURIComponent(String(helpMessageId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'helpMessageId' is not null or undefined
        if (helpMessageId === null || helpMessageId === undefined) {
            throw new Error('Required parameter helpMessageId was null or undefined when calling addLargeImage.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addLargeImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "HelpMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a small image to the help message
     * @param helpMessageId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addSmallImage (helpMessageId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/{helpMessageId}/addSmallImage/{mediaItemId}'
            .replace('{' + 'helpMessageId' + '}', encodeURIComponent(String(helpMessageId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'helpMessageId' is not null or undefined
        if (helpMessageId === null || helpMessageId === undefined) {
            throw new Error('Required parameter helpMessageId was null or undefined when calling addSmallImage.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addSmallImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "HelpMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a video file to the help message
     * @param helpMessageId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addVideoFile (helpMessageId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/{helpMessageId}/addVideoFile/{mediaItemId}'
            .replace('{' + 'helpMessageId' + '}', encodeURIComponent(String(helpMessageId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'helpMessageId' is not null or undefined
        if (helpMessageId === null || helpMessageId === undefined) {
            throw new Error('Required parameter helpMessageId was null or undefined when calling addVideoFile.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addVideoFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "HelpMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param helpMessageId 
     * @param webhookId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public addWebhook (helpMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: HelpMessageWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/{helpMessageId}/webhooks/{webhookId}'
            .replace('{' + 'helpMessageId' + '}', encodeURIComponent(String(helpMessageId)))
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'helpMessageId' is not null or undefined
        if (helpMessageId === null || helpMessageId === undefined) {
            throw new Error('Required parameter helpMessageId was null or undefined when calling addWebhook.');
        }

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling addWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: HelpMessageWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "HelpMessageWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param helpMessageId 
     * @param {*} [options] Override http request options.
     */
    public copyContentItem (helpMessageId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/{helpMessageId}/copy'
            .replace('{' + 'helpMessageId' + '}', encodeURIComponent(String(helpMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'helpMessageId' is not null or undefined
        if (helpMessageId === null || helpMessageId === undefined) {
            throw new Error('Required parameter helpMessageId was null or undefined when calling copyContentItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "HelpMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createFullContentItem (model?: HelpMessageModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/full';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "HelpMessageModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "HelpMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public createUserDefinedParameter (instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/webhook/{instanceWebhookId}/userParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling createUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UserDefinedWebhookParameterCreateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes the given message
     * @param helpMessageId 
     * @param {*} [options] Override http request options.
     */
    public deleteHelpMessage (helpMessageId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/{helpMessageId}'
            .replace('{' + 'helpMessageId' + '}', encodeURIComponent(String(helpMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'helpMessageId' is not null or undefined
        if (helpMessageId === null || helpMessageId === undefined) {
            throw new Error('Required parameter helpMessageId was null or undefined when calling deleteHelpMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "HelpMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Finds the full content item by id
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public findFullById (id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/full/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findFullById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "HelpMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the content for the given application feature
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public getByApplicationFeature (applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<HelpMessageModel>;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/byFeature/{applicationFeatureId}'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling getByApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<HelpMessageModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<HelpMessageModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the help messages for the given application
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getHelpMessagesForApplication (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<HelpMessageModel>;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getHelpMessagesForApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<HelpMessageModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<HelpMessageModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param helpMessageId 
     * @param {*} [options] Override http request options.
     */
    public getWebhooks (helpMessageId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<HelpMessageWebhookModel>;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/{helpMessageId}/webhooks'
            .replace('{' + 'helpMessageId' + '}', encodeURIComponent(String(helpMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'helpMessageId' is not null or undefined
        if (helpMessageId === null || helpMessageId === undefined) {
            throw new Error('Required parameter helpMessageId was null or undefined when calling getWebhooks.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<HelpMessageWebhookModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<HelpMessageWebhookModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param contentItemId 
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public moveContentItemToApplicationFeature (contentItemId: string, applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/{contentItemId}/MoveToFeature/{applicationFeatureId}'
            .replace('{' + 'contentItemId' + '}', encodeURIComponent(String(contentItemId)))
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentItemId' is not null or undefined
        if (contentItemId === null || contentItemId === undefined) {
            throw new Error('Required parameter contentItemId was null or undefined when calling moveContentItemToApplicationFeature.');
        }

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling moveContentItemToApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "HelpMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param parameterName 
     * @param {*} [options] Override http request options.
     */
    public removeUserDefinedParameter (instanceWebhookId: string, parameterName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/webhook/{instanceWebhookId}/userParameters/{parameterName}'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)))
            .replace('{' + 'parameterName' + '}', encodeURIComponent(String(parameterName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling removeUserDefinedParameter.');
        }

        // verify required parameter 'parameterName' is not null or undefined
        if (parameterName === null || parameterName === undefined) {
            throw new Error('Required parameter parameterName was null or undefined when calling removeUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param helpMessageWebhookId 
     * @param {*} [options] Override http request options.
     */
    public removeWebhook (helpMessageWebhookId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: HelpMessageWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/webhook/{helpMessageWebhookId}'
            .replace('{' + 'helpMessageWebhookId' + '}', encodeURIComponent(String(helpMessageWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'helpMessageWebhookId' is not null or undefined
        if (helpMessageWebhookId === null || helpMessageWebhookId === undefined) {
            throw new Error('Required parameter helpMessageWebhookId was null or undefined when calling removeWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: HelpMessageWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "HelpMessageWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Toggles whether the given help Message is live or not
     * @param helpMessageId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public toggleIsLive (helpMessageId: string, model?: ToggleLiveRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/{helpMessageId}/isLive'
            .replace('{' + 'helpMessageId' + '}', encodeURIComponent(String(helpMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'helpMessageId' is not null or undefined
        if (helpMessageId === null || helpMessageId === undefined) {
            throw new Error('Required parameter helpMessageId was null or undefined when calling toggleIsLive.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "ToggleLiveRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "HelpMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param helpMessageId 
     * @param webhookInstanceId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public updateAttachedWebhook (helpMessageId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: HelpMessageWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/{helpMessageId}/webhooks/{webhookInstanceId}'
            .replace('{' + 'helpMessageId' + '}', encodeURIComponent(String(helpMessageId)))
            .replace('{' + 'webhookInstanceId' + '}', encodeURIComponent(String(webhookInstanceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'helpMessageId' is not null or undefined
        if (helpMessageId === null || helpMessageId === undefined) {
            throw new Error('Required parameter helpMessageId was null or undefined when calling updateAttachedWebhook.');
        }

        // verify required parameter 'webhookInstanceId' is not null or undefined
        if (webhookInstanceId === null || webhookInstanceId === undefined) {
            throw new Error('Required parameter webhookInstanceId was null or undefined when calling updateAttachedWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: HelpMessageWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "HelpMessageWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param contentItemId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateFullContentItem (contentItemId: string, model?: HelpMessageModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/{contentItemId}/full'
            .replace('{' + 'contentItemId' + '}', encodeURIComponent(String(contentItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentItemId' is not null or undefined
        if (contentItemId === null || contentItemId === undefined) {
            throw new Error('Required parameter contentItemId was null or undefined when calling updateFullContentItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "HelpMessageModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "HelpMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the content of the given help message id
     * @param helpMessageId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateHelpMessage (helpMessageId: string, model?: UpdateHelpMessageRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/{helpMessageId}/update'
            .replace('{' + 'helpMessageId' + '}', encodeURIComponent(String(helpMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'helpMessageId' is not null or undefined
        if (helpMessageId === null || helpMessageId === undefined) {
            throw new Error('Required parameter helpMessageId was null or undefined when calling updateHelpMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateHelpMessageRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "HelpMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the content of the given help message id
     * @param helpMessageId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateHelpMessageStub (helpMessageId: string, model?: UpdateHelpMessageStubRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/{helpMessageId}/update/stub'
            .replace('{' + 'helpMessageId' + '}', encodeURIComponent(String(helpMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'helpMessageId' is not null or undefined
        if (helpMessageId === null || helpMessageId === undefined) {
            throw new Error('Required parameter helpMessageId was null or undefined when calling updateHelpMessageStub.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateHelpMessageStubRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: HelpMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "HelpMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateUserDefinedParameter (instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/webhook/{instanceWebhookId}/userParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UserDefinedWebhookParameterUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateWebhookParameter (instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/HelpMessage/webhook/{instanceWebhookId}/webhookParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateWebhookParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "WebhookParameterUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ImportExportApiApiKeys {
    Bearer,
}

export class ImportExportApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ImportExportApiApiKeys, value: string) {
        (this.authentications as any)[ImportExportApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Exports the application
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public exportApplication (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ExportModel;  }> {
        const localVarPath = this.basePath + '/api/ImportExport/export/application/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling exportApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ExportModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExportModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Exports the application
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public exportApplicationFile (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/ImportExport/export/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling exportApplicationFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Exports the application's interaction model only
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public exportApplicationInteractionModel (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ExportModel;  }> {
        const localVarPath = this.basePath + '/api/ImportExport/export/interactionModel/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling exportApplicationInteractionModel.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ExportModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExportModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Exports the application's interaction model to file
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public exportApplicationInteractionModelFile (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/ImportExport/export/interactionModel/{applicationId}/file'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling exportApplicationInteractionModelFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Exports custom content based off of request
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public exportContent (request?: BulkContentRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ExportModel;  }> {
        const localVarPath = this.basePath + '/api/ImportExport/export/content';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "BulkContentRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ExportModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ExportModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Exports custom content based off of request
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public exportContentToFile (request?: BulkContentRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/ImportExport/export/contentToFile';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "BulkContentRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Imports the application
     * @param applicationId 
     * @param exportModel 
     * @param {*} [options] Override http request options.
     */
    public importIntoApplication (applicationId: string, exportModel?: ExportModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/ImportExport/import/intoApplication/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling importIntoApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(exportModel, "ExportModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Import content to a feature with an export model
     * @param applicationFeatureId 
     * @param exportModel 
     * @param {*} [options] Override http request options.
     */
    public importIntoApplicationFeature (applicationFeatureId: string, exportModel?: ExportModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/ImportExport/import/intoApplicationFeature/{applicationFeatureId}'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling importIntoApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(exportModel, "ExportModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Import content to a feature by file
     * @param applicationFeatureId 
     * @param file 
     * @param {*} [options] Override http request options.
     */
    public importIntoApplicationFeatureFromFile (applicationFeatureId: string, file?: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/ImportExport/import/intoApplicationFeatureFromFile/{applicationFeatureId}'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling importIntoApplicationFeatureFromFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (file !== undefined) {
            localVarFormParams['file'] = file;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Uploads the file and saves the media item to the application
     * @param applicationId 
     * @param file 
     * @param {*} [options] Override http request options.
     */
    public importIntoApplicationFromFile (applicationId: string, file?: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/ImportExport/import/intoApplicationFromFile/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling importIntoApplicationFromFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (file !== undefined) {
            localVarFormParams['file'] = file;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InteractionModelApiApiKeys {
    Bearer,
}

export class InteractionModelApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: InteractionModelApiApiKeys, value: string) {
        (this.authentications as any)[InteractionModelApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getBaseInteractionModel (options: any = {}) : Promise<{ response: http.IncomingMessage; body: InteractionModel;  }> {
        const localVarPath = this.basePath + '/api/InteractionModel';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: InteractionModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InteractionModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param locale 
     * @param {*} [options] Override http request options.
     */
    public getInteractionModelForApplication (applicationId: string, locale?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: InteractionModel;  }> {
        const localVarPath = this.basePath + '/api/InteractionModel/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getInteractionModelForApplication.');
        }

        if (locale !== undefined) {
            localVarQueryParameters['locale'] = ObjectSerializer.serialize(locale, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: InteractionModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InteractionModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getInteractionModelStatus (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: InteractionModelStatus;  }> {
        const localVarPath = this.basePath + '/api/InteractionModel/{applicationId}/status'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getInteractionModelStatus.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: InteractionModelStatus;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InteractionModelStatus");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param locale 
     * @param update 
     * @param {*} [options] Override http request options.
     */
    public updateInteractionModelForApplication (applicationId: string, locale: string, update?: InteractionModelUpdate, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/InteractionModel/{applicationId}/{locale}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)))
            .replace('{' + 'locale' + '}', encodeURIComponent(String(locale)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling updateInteractionModelForApplication.');
        }

        // verify required parameter 'locale' is not null or undefined
        if (locale === null || locale === undefined) {
            throw new Error('Required parameter locale was null or undefined when calling updateInteractionModelForApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(update, "InteractionModelUpdate")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InvitationApiApiKeys {
    Bearer,
}

export class InvitationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: InvitationApiApiKeys, value: string) {
        (this.authentications as any)[InvitationApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Accepts the given invitation
     * @param invitationId 
     * @param {*} [options] Override http request options.
     */
    public acceptInvite (invitationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: OrganizationMemberModel;  }> {
        const localVarPath = this.basePath + '/api/Invitation/accept/{invitationId}'
            .replace('{' + 'invitationId' + '}', encodeURIComponent(String(invitationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'invitationId' is not null or undefined
        if (invitationId === null || invitationId === undefined) {
            throw new Error('Required parameter invitationId was null or undefined when calling acceptInvite.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: OrganizationMemberModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OrganizationMemberModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Accepts the given invitation
     * @param invitationId 
     * @param {*} [options] Override http request options.
     */
    public declineInvite (invitationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: InvitationModel;  }> {
        const localVarPath = this.basePath + '/api/Invitation/decline/{invitationId}'
            .replace('{' + 'invitationId' + '}', encodeURIComponent(String(invitationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'invitationId' is not null or undefined
        if (invitationId === null || invitationId === undefined) {
            throw new Error('Required parameter invitationId was null or undefined when calling declineInvite.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: InvitationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InvitationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets all the user's pending invitations
     * @param {*} [options] Override http request options.
     */
    public getInvitations (options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<InvitationModel>;  }> {
        const localVarPath = this.basePath + '/api/Invitation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<InvitationModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<InvitationModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Revokes an invite that was already created
     * @param invitationId The id of the invitation
     * @param {*} [options] Override http request options.
     */
    public revokeInvite (invitationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: InvitationModel;  }> {
        const localVarPath = this.basePath + '/api/Invitation/{invitationId}'
            .replace('{' + 'invitationId' + '}', encodeURIComponent(String(invitationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'invitationId' is not null or undefined
        if (invitationId === null || invitationId === undefined) {
            throw new Error('Required parameter invitationId was null or undefined when calling revokeInvite.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: InvitationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InvitationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sends an invitation for the given organization
     * @param organizationId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public sendInvite (organizationId: string, model?: NewInvitationRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: InvitationModel;  }> {
        const localVarPath = this.basePath + '/api/Invitation/{organizationId}/withRole'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling sendInvite.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewInvitationRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: InvitationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InvitationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param organizationId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public sendInvite_1 (organizationId: string, model?: BasicInvitationRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: InvitationModel;  }> {
        const localVarPath = this.basePath + '/api/Invitation/{organizationId}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling sendInvite_1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BasicInvitationRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: InvitationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "InvitationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LanguageValidationApiApiKeys {
    Bearer,
}

export class LanguageValidationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LanguageValidationApiApiKeys, value: string) {
        (this.authentications as any)[LanguageValidationApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param applicationId 
     * @param inputText 
     * @param locale 
     * @param {*} [options] Override http request options.
     */
    public findBestMatch (applicationId: string, inputText?: string, locale?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ProcessedLanguage;  }> {
        const localVarPath = this.basePath + '/api/LanguageValidation/{applicationId}/BestMatch'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling findBestMatch.');
        }

        if (locale !== undefined) {
            localVarQueryParameters['locale'] = ObjectSerializer.serialize(locale, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(inputText, "string")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ProcessedLanguage;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ProcessedLanguage");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param inputText 
     * @param locale 
     * @param {*} [options] Override http request options.
     */
    public getMatches (applicationId: string, inputText?: string, locale?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ProcessedLanguage>;  }> {
        const localVarPath = this.basePath + '/api/LanguageValidation/{applicationId}/Matches'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getMatches.');
        }

        if (locale !== undefined) {
            localVarQueryParameters['locale'] = ObjectSerializer.serialize(locale, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(inputText, "string")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ProcessedLanguage>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ProcessedLanguage>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LatestMessageApiApiKeys {
    Bearer,
}

export class LatestMessageApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LatestMessageApiApiKeys, value: string) {
        (this.authentications as any)[LatestMessageApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds an audio file to the given response
     * @param latestMessageResponseId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addAudioFile (latestMessageResponseId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LatestMessageResponseModel;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/{latestMessageResponseId}/addAudioFile/{mediaItemId}'
            .replace('{' + 'latestMessageResponseId' + '}', encodeURIComponent(String(latestMessageResponseId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'latestMessageResponseId' is not null or undefined
        if (latestMessageResponseId === null || latestMessageResponseId === undefined) {
            throw new Error('Required parameter latestMessageResponseId was null or undefined when calling addAudioFile.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addAudioFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LatestMessageResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LatestMessageResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a large image to the given response
     * @param latestMessageResponseId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addLargeImage (latestMessageResponseId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LatestMessageResponseModel;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/{latestMessageResponseId}/addLargeImage/{mediaItemId}'
            .replace('{' + 'latestMessageResponseId' + '}', encodeURIComponent(String(latestMessageResponseId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'latestMessageResponseId' is not null or undefined
        if (latestMessageResponseId === null || latestMessageResponseId === undefined) {
            throw new Error('Required parameter latestMessageResponseId was null or undefined when calling addLargeImage.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addLargeImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LatestMessageResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LatestMessageResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a small image item to the given response
     * @param latestMessageResponseId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addSmallImage (latestMessageResponseId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LatestMessageResponseModel;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/{latestMessageResponseId}/addSmallImage/{mediaItemId}'
            .replace('{' + 'latestMessageResponseId' + '}', encodeURIComponent(String(latestMessageResponseId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'latestMessageResponseId' is not null or undefined
        if (latestMessageResponseId === null || latestMessageResponseId === undefined) {
            throw new Error('Required parameter latestMessageResponseId was null or undefined when calling addSmallImage.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addSmallImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LatestMessageResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LatestMessageResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a video file to the given response
     * @param latestMessageResponseId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addVideoFile (latestMessageResponseId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LatestMessageResponseModel;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/{latestMessageResponseId}/addVideoFile/{mediaItemId}'
            .replace('{' + 'latestMessageResponseId' + '}', encodeURIComponent(String(latestMessageResponseId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'latestMessageResponseId' is not null or undefined
        if (latestMessageResponseId === null || latestMessageResponseId === undefined) {
            throw new Error('Required parameter latestMessageResponseId was null or undefined when calling addVideoFile.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addVideoFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LatestMessageResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LatestMessageResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param latestMessageId 
     * @param webhookId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public addWebhook (latestMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LatestMessageWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/{latestMessageId}/webhooks/{webhookId}'
            .replace('{' + 'latestMessageId' + '}', encodeURIComponent(String(latestMessageId)))
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'latestMessageId' is not null or undefined
        if (latestMessageId === null || latestMessageId === undefined) {
            throw new Error('Required parameter latestMessageId was null or undefined when calling addWebhook.');
        }

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling addWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LatestMessageWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LatestMessageWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param latestMessageId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public bulkUpdateLatestMessage (latestMessageId: string, model?: BulkUpdateLatestMessageRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LatestMessageModel;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/{latestMessageId}/bulkUpdate'
            .replace('{' + 'latestMessageId' + '}', encodeURIComponent(String(latestMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'latestMessageId' is not null or undefined
        if (latestMessageId === null || latestMessageId === undefined) {
            throw new Error('Required parameter latestMessageId was null or undefined when calling bulkUpdateLatestMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BulkUpdateLatestMessageRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LatestMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LatestMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param latestMessageId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public bulkUpdateLatestMessageStub (latestMessageId: string, model?: BulkUpdateLatestMessageStubRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LatestMessageModel;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/{latestMessageId}/bulkUpdate/stub'
            .replace('{' + 'latestMessageId' + '}', encodeURIComponent(String(latestMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'latestMessageId' is not null or undefined
        if (latestMessageId === null || latestMessageId === undefined) {
            throw new Error('Required parameter latestMessageId was null or undefined when calling bulkUpdateLatestMessageStub.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BulkUpdateLatestMessageStubRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LatestMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LatestMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param latestMessageId 
     * @param {*} [options] Override http request options.
     */
    public copyContentItem (latestMessageId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LatestMessageModel;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/{latestMessageId}/copy'
            .replace('{' + 'latestMessageId' + '}', encodeURIComponent(String(latestMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'latestMessageId' is not null or undefined
        if (latestMessageId === null || latestMessageId === undefined) {
            throw new Error('Required parameter latestMessageId was null or undefined when calling copyContentItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LatestMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LatestMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createFullContentItem (model?: LatestMessageModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LatestMessageModel;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/full';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "LatestMessageModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LatestMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LatestMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new latest message entity
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createLatestMessage (model?: NewLatestMessageRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LatestMessageModel;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewLatestMessageRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LatestMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LatestMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new latest message entity
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createLatestMessageStub (model?: NewLatestMessageStubRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LatestMessageModel;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/stub';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewLatestMessageStubRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LatestMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LatestMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new response varation for the given message
     * @param latestMessageId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createResponse (latestMessageId: string, model?: NewLatestMessageResponseRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LatestMessageResponseModel;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/{latestMessageId}/response'
            .replace('{' + 'latestMessageId' + '}', encodeURIComponent(String(latestMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'latestMessageId' is not null or undefined
        if (latestMessageId === null || latestMessageId === undefined) {
            throw new Error('Required parameter latestMessageId was null or undefined when calling createResponse.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewLatestMessageResponseRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LatestMessageResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LatestMessageResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public createUserDefinedParameter (instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/webhook/{instanceWebhookId}/userParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling createUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UserDefinedWebhookParameterCreateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete the given latest message
     * @param latestMessageId 
     * @param {*} [options] Override http request options.
     */
    public deleteLatestMessage (latestMessageId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LatestMessageModel;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/{latestMessageId}'
            .replace('{' + 'latestMessageId' + '}', encodeURIComponent(String(latestMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'latestMessageId' is not null or undefined
        if (latestMessageId === null || latestMessageId === undefined) {
            throw new Error('Required parameter latestMessageId was null or undefined when calling deleteLatestMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LatestMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LatestMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes the given response
     * @param latestMessageResponseId 
     * @param {*} [options] Override http request options.
     */
    public deleteResponse (latestMessageResponseId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LatestMessageResponseModel;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/response/{latestMessageResponseId}'
            .replace('{' + 'latestMessageResponseId' + '}', encodeURIComponent(String(latestMessageResponseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'latestMessageResponseId' is not null or undefined
        if (latestMessageResponseId === null || latestMessageResponseId === undefined) {
            throw new Error('Required parameter latestMessageResponseId was null or undefined when calling deleteResponse.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LatestMessageResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LatestMessageResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Finds the full content item by id
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public findFullById (id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LatestMessageModel;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/full/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findFullById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LatestMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LatestMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the content for the given application feature
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public getByApplicationFeature (applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<LatestMessageModel>;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/byFeature/{applicationFeatureId}'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling getByApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<LatestMessageModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<LatestMessageModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param latestMessageResponseId 
     * @param {*} [options] Override http request options.
     */
    public getMediaItemsForLatestMessage (latestMessageResponseId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<MediaItemModel>;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/response/{latestMessageResponseId}/media'
            .replace('{' + 'latestMessageResponseId' + '}', encodeURIComponent(String(latestMessageResponseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'latestMessageResponseId' is not null or undefined
        if (latestMessageResponseId === null || latestMessageResponseId === undefined) {
            throw new Error('Required parameter latestMessageResponseId was null or undefined when calling getMediaItemsForLatestMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<MediaItemModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<MediaItemModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the latest messages content for the given application  regardless of module
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getMessagesForApplication (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<LatestMessageModel>;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getMessagesForApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<LatestMessageModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<LatestMessageModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the latest messages for the given application module
     * @param applicationModuleId 
     * @param {*} [options] Override http request options.
     */
    public getMessagesForModule (applicationModuleId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<LatestMessageModel>;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/module/{applicationModuleId}'
            .replace('{' + 'applicationModuleId' + '}', encodeURIComponent(String(applicationModuleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationModuleId' is not null or undefined
        if (applicationModuleId === null || applicationModuleId === undefined) {
            throw new Error('Required parameter applicationModuleId was null or undefined when calling getMessagesForModule.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<LatestMessageModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<LatestMessageModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param latestMessageId 
     * @param {*} [options] Override http request options.
     */
    public getWebhooks (latestMessageId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<LatestMessageWebhookModel>;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/{latestMessageId}/webhooks'
            .replace('{' + 'latestMessageId' + '}', encodeURIComponent(String(latestMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'latestMessageId' is not null or undefined
        if (latestMessageId === null || latestMessageId === undefined) {
            throw new Error('Required parameter latestMessageId was null or undefined when calling getWebhooks.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<LatestMessageWebhookModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<LatestMessageWebhookModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param contentItemId 
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public moveContentItemToApplicationFeature (contentItemId: string, applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LatestMessageModel;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/{contentItemId}/MoveToFeature/{applicationFeatureId}'
            .replace('{' + 'contentItemId' + '}', encodeURIComponent(String(contentItemId)))
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentItemId' is not null or undefined
        if (contentItemId === null || contentItemId === undefined) {
            throw new Error('Required parameter contentItemId was null or undefined when calling moveContentItemToApplicationFeature.');
        }

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling moveContentItemToApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LatestMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LatestMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param parameterName 
     * @param {*} [options] Override http request options.
     */
    public removeUserDefinedParameter (instanceWebhookId: string, parameterName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/webhook/{instanceWebhookId}/userParameters/{parameterName}'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)))
            .replace('{' + 'parameterName' + '}', encodeURIComponent(String(parameterName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling removeUserDefinedParameter.');
        }

        // verify required parameter 'parameterName' is not null or undefined
        if (parameterName === null || parameterName === undefined) {
            throw new Error('Required parameter parameterName was null or undefined when calling removeUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param latestMessageWebhookId 
     * @param {*} [options] Override http request options.
     */
    public removeWebhook (latestMessageWebhookId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LatestMessageWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/webhook/{latestMessageWebhookId}'
            .replace('{' + 'latestMessageWebhookId' + '}', encodeURIComponent(String(latestMessageWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'latestMessageWebhookId' is not null or undefined
        if (latestMessageWebhookId === null || latestMessageWebhookId === undefined) {
            throw new Error('Required parameter latestMessageWebhookId was null or undefined when calling removeWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LatestMessageWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LatestMessageWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Toggles the given message as live or not
     * @param latestMessageId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public toggleLive (latestMessageId: string, model?: ToggleLiveRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LatestMessageModel;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/{latestMessageId}/isLive'
            .replace('{' + 'latestMessageId' + '}', encodeURIComponent(String(latestMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'latestMessageId' is not null or undefined
        if (latestMessageId === null || latestMessageId === undefined) {
            throw new Error('Required parameter latestMessageId was null or undefined when calling toggleLive.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "ToggleLiveRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LatestMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LatestMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param latestMessageId 
     * @param webhookInstanceId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public updateAttachedWebhook (latestMessageId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LatestMessageWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/{latestMessageId}/webhooks/{webhookInstanceId}'
            .replace('{' + 'latestMessageId' + '}', encodeURIComponent(String(latestMessageId)))
            .replace('{' + 'webhookInstanceId' + '}', encodeURIComponent(String(webhookInstanceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'latestMessageId' is not null or undefined
        if (latestMessageId === null || latestMessageId === undefined) {
            throw new Error('Required parameter latestMessageId was null or undefined when calling updateAttachedWebhook.');
        }

        // verify required parameter 'webhookInstanceId' is not null or undefined
        if (webhookInstanceId === null || webhookInstanceId === undefined) {
            throw new Error('Required parameter webhookInstanceId was null or undefined when calling updateAttachedWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LatestMessageWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LatestMessageWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param contentItemId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateFullContentItem (contentItemId: string, model?: LatestMessageModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LatestMessageModel;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/{contentItemId}/full'
            .replace('{' + 'contentItemId' + '}', encodeURIComponent(String(contentItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentItemId' is not null or undefined
        if (contentItemId === null || contentItemId === undefined) {
            throw new Error('Required parameter contentItemId was null or undefined when calling updateFullContentItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "LatestMessageModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LatestMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LatestMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the latest message with the given fields  If you send null or no value for fields, they won't be updated
     * @param latestMessageId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateMessage (latestMessageId: string, model?: UpdateLatestMessageRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LatestMessageModel;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/{latestMessageId}'
            .replace('{' + 'latestMessageId' + '}', encodeURIComponent(String(latestMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'latestMessageId' is not null or undefined
        if (latestMessageId === null || latestMessageId === undefined) {
            throw new Error('Required parameter latestMessageId was null or undefined when calling updateMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateLatestMessageRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LatestMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LatestMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the given response
     * @param latestMessageResponseId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateResponse (latestMessageResponseId: string, model?: UpdateLatestMessageResponseRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: LatestMessageResponseModel;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/response/{latestMessageResponseId}'
            .replace('{' + 'latestMessageResponseId' + '}', encodeURIComponent(String(latestMessageResponseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'latestMessageResponseId' is not null or undefined
        if (latestMessageResponseId === null || latestMessageResponseId === undefined) {
            throw new Error('Required parameter latestMessageResponseId was null or undefined when calling updateResponse.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateLatestMessageResponseRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: LatestMessageResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "LatestMessageResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateUserDefinedParameter (instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/webhook/{instanceWebhookId}/userParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UserDefinedWebhookParameterUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateWebhookParameter (instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/LatestMessage/webhook/{instanceWebhookId}/webhookParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateWebhookParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "WebhookParameterUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MediaItemApiApiKeys {
    Bearer,
}

export class MediaItemApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MediaItemApiApiKeys, value: string) {
        (this.authentications as any)[MediaItemApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public convertToSsml (mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediaItemModel;  }> {
        const localVarPath = this.basePath + '/api/MediaItem/convert/ssml/{mediaItemId}'
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling convertToSsml.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediaItemModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediaItemModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Uploads the file and saves the media item to the application
     * @param applicationId 
     * @param name 
     * @param file 
     * @param {*} [options] Override http request options.
     */
    public createMediaItem (applicationId: string, name?: string, file?: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediaItemModel;  }> {
        const localVarPath = this.basePath + '/api/MediaItem/{applicationId}/upload'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling createMediaItem.');
        }

        if (name !== undefined) {
            localVarQueryParameters['name'] = ObjectSerializer.serialize(name, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (file !== undefined) {
            localVarFormParams['file'] = file;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediaItemModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediaItemModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createMediaItem_1 (applicationId: string, model?: NewMediaItemRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediaItemModel;  }> {
        const localVarPath = this.basePath + '/api/MediaItem/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling createMediaItem_1.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewMediaItemRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediaItemModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediaItemModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes the given media item
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public deleteMediaItem (mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediaItemModel;  }> {
        const localVarPath = this.basePath + '/api/MediaItem/{mediaItemId}'
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling deleteMediaItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediaItemModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediaItemModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes the given media item
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public disableMediaItem (mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediaItemModel;  }> {
        const localVarPath = this.basePath + '/api/MediaItem/{mediaItemId}/disable'
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling disableMediaItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediaItemModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediaItemModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets deleted media items for the given application
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getDisabledMediaItemsForApplication (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<MediaItemModel>;  }> {
        const localVarPath = this.basePath + '/api/MediaItem/{applicationId}/disabled'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getDisabledMediaItemsForApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<MediaItemModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<MediaItemModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the media items for the given application
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getMediaItemsForApplication (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<MediaItemModel>;  }> {
        const localVarPath = this.basePath + '/api/MediaItem/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getMediaItemsForApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<MediaItemModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<MediaItemModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param organizationId 
     * @param name 
     * @param fileName 
     * @param {*} [options] Override http request options.
     */
    public getOrganizationUploadUrl (organizationId: string, name?: string, fileName?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/MediaItem/{organizationId}/orgUploadUrl'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getOrganizationUploadUrl.');
        }

        if (name !== undefined) {
            localVarQueryParameters['Name'] = ObjectSerializer.serialize(name, "string");
        }

        if (fileName !== undefined) {
            localVarQueryParameters['FileName'] = ObjectSerializer.serialize(fileName, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param name 
     * @param fileName 
     * @param {*} [options] Override http request options.
     */
    public getUploadUrl (applicationId: string, name?: string, fileName?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/MediaItem/{applicationId}/uploadUrl'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getUploadUrl.');
        }

        if (name !== undefined) {
            localVarQueryParameters['Name'] = ObjectSerializer.serialize(name, "string");
        }

        if (fileName !== undefined) {
            localVarQueryParameters['FileName'] = ObjectSerializer.serialize(fileName, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param mediaItemId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateMediaItem (mediaItemId: string, request?: UpdateMediaItemRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediaItemModel;  }> {
        const localVarPath = this.basePath + '/api/MediaItem/{mediaItemId}'
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling updateMediaItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UpdateMediaItemRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediaItemModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediaItemModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MediaResponseApiApiKeys {
    Bearer,
}

export class MediaResponseApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MediaResponseApiApiKeys, value: string) {
        (this.authentications as any)[MediaResponseApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createMediaResponse (model?: NewMediaResponseRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediaResponseModel;  }> {
        const localVarPath = this.basePath + '/api/MediaResponse';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewMediaResponseRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediaResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediaResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createMediaResponseContainer (model?: NewMediaResponseContainerRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediaResponseContainerModel;  }> {
        const localVarPath = this.basePath + '/api/MediaResponse/containers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewMediaResponseContainerRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediaResponseContainerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediaResponseContainerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createMediaResponseContainer_1 (model?: NewBulkMediaResponseContainerRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediaResponseContainerModel;  }> {
        const localVarPath = this.basePath + '/api/MediaResponse/containers/bulk';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewBulkMediaResponseContainerRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediaResponseContainerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediaResponseContainerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createResponseTemplateType (model?: NewResponseTemplateTypeRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ResponseTemplateTypeModel;  }> {
        const localVarPath = this.basePath + '/api/MediaResponse/templateType';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewResponseTemplateTypeRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ResponseTemplateTypeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseTemplateTypeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param mediaResponseId 
     * @param {*} [options] Override http request options.
     */
    public deleteMediaResponse (mediaResponseId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediaResponseModel;  }> {
        const localVarPath = this.basePath + '/api/MediaResponse/{mediaResponseId}'
            .replace('{' + 'mediaResponseId' + '}', encodeURIComponent(String(mediaResponseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mediaResponseId' is not null or undefined
        if (mediaResponseId === null || mediaResponseId === undefined) {
            throw new Error('Required parameter mediaResponseId was null or undefined when calling deleteMediaResponse.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediaResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediaResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param containerId 
     * @param {*} [options] Override http request options.
     */
    public deleteMediaResponseContainer (containerId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediaResponseContainerModel;  }> {
        const localVarPath = this.basePath + '/api/MediaResponse/containers/{containerId}'
            .replace('{' + 'containerId' + '}', encodeURIComponent(String(containerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'containerId' is not null or undefined
        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling deleteMediaResponseContainer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediaResponseContainerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediaResponseContainerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param templateId 
     * @param responseTemplateId 
     * @param {*} [options] Override http request options.
     */
    public deleteResponseTemplate (templateId: string, responseTemplateId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ResponseTemplateTypeModel;  }> {
        const localVarPath = this.basePath + '/api/MediaResponse/templateType/{templateId}'
            .replace('{' + 'templateId' + '}', encodeURIComponent(String(templateId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling deleteResponseTemplate.');
        }

        if (responseTemplateId !== undefined) {
            localVarQueryParameters['responseTemplateId'] = ObjectSerializer.serialize(responseTemplateId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ResponseTemplateTypeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseTemplateTypeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getAllResponseTemplates (options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ResponseTemplateTypeModel>;  }> {
        const localVarPath = this.basePath + '/api/MediaResponse/templateType';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ResponseTemplateTypeModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ResponseTemplateTypeModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getEnabledResponseTemplates (options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ResponseTemplateTypeModel>;  }> {
        const localVarPath = this.basePath + '/api/MediaResponse/templateType/enabled';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ResponseTemplateTypeModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ResponseTemplateTypeModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param containerId 
     * @param {*} [options] Override http request options.
     */
    public getResponseContainerById (containerId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediaResponseContainerModel;  }> {
        const localVarPath = this.basePath + '/api/MediaResponse/containers/{containerId}'
            .replace('{' + 'containerId' + '}', encodeURIComponent(String(containerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'containerId' is not null or undefined
        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling getResponseContainerById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediaResponseContainerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediaResponseContainerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getResponseContainersForApp (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<MediaResponseContainerModel>;  }> {
        const localVarPath = this.basePath + '/api/MediaResponse/containers/forApp/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getResponseContainersForApp.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<MediaResponseContainerModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<MediaResponseContainerModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param responseTemplateId 
     * @param {*} [options] Override http request options.
     */
    public getResponseTemplateById (responseTemplateId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ResponseTemplateTypeModel;  }> {
        const localVarPath = this.basePath + '/api/MediaResponse/templateType/{responseTemplateId}'
            .replace('{' + 'responseTemplateId' + '}', encodeURIComponent(String(responseTemplateId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'responseTemplateId' is not null or undefined
        if (responseTemplateId === null || responseTemplateId === undefined) {
            throw new Error('Required parameter responseTemplateId was null or undefined when calling getResponseTemplateById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ResponseTemplateTypeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseTemplateTypeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param assistant 
     * @param {*} [options] Override http request options.
     */
    public getResponseTemplatesByAssistant (assistant: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ResponseTemplateTypeModel>;  }> {
        const localVarPath = this.basePath + '/api/MediaResponse/templateType/assistant/{assistant}'
            .replace('{' + 'assistant' + '}', encodeURIComponent(String(assistant)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'assistant' is not null or undefined
        if (assistant === null || assistant === undefined) {
            throw new Error('Required parameter assistant was null or undefined when calling getResponseTemplatesByAssistant.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ResponseTemplateTypeModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ResponseTemplateTypeModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param deviceTargetId 
     * @param {*} [options] Override http request options.
     */
    public getResponseTemplatesByDeviceTarget (deviceTargetId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ResponseTemplateTypeModel>;  }> {
        const localVarPath = this.basePath + '/api/MediaResponse/templateType/deviceTarget/{deviceTargetId}'
            .replace('{' + 'deviceTargetId' + '}', encodeURIComponent(String(deviceTargetId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'deviceTargetId' is not null or undefined
        if (deviceTargetId === null || deviceTargetId === undefined) {
            throw new Error('Required parameter deviceTargetId was null or undefined when calling getResponseTemplatesByDeviceTarget.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ResponseTemplateTypeModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ResponseTemplateTypeModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param responseId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateMediaResponse (responseId: string, model?: UpdateMediaResponseRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediaResponseModel;  }> {
        const localVarPath = this.basePath + '/api/MediaResponse/{responseId}'
            .replace('{' + 'responseId' + '}', encodeURIComponent(String(responseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'responseId' is not null or undefined
        if (responseId === null || responseId === undefined) {
            throw new Error('Required parameter responseId was null or undefined when calling updateMediaResponse.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateMediaResponseRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediaResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediaResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param containerId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateMediaResponseContainer (containerId: string, model?: UpdateMediaResponseContainerRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediaResponseContainerModel;  }> {
        const localVarPath = this.basePath + '/api/MediaResponse/containers/{containerId}'
            .replace('{' + 'containerId' + '}', encodeURIComponent(String(containerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'containerId' is not null or undefined
        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling updateMediaResponseContainer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateMediaResponseContainerRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediaResponseContainerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediaResponseContainerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param containerId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateMediaResponseContainer_2 (containerId: string, model?: UpdateBulkMediaResponseContainerRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediaResponseContainerModel;  }> {
        const localVarPath = this.basePath + '/api/MediaResponse/containers/{containerId}/bulk'
            .replace('{' + 'containerId' + '}', encodeURIComponent(String(containerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'containerId' is not null or undefined
        if (containerId === null || containerId === undefined) {
            throw new Error('Required parameter containerId was null or undefined when calling updateMediaResponseContainer_2.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateBulkMediaResponseContainerRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediaResponseContainerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediaResponseContainerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param templateId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateResponseTemplateType (templateId: string, model?: UpdateResponseTemplateTypeRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ResponseTemplateTypeModel;  }> {
        const localVarPath = this.basePath + '/api/MediaResponse/templateType/{templateId}'
            .replace('{' + 'templateId' + '}', encodeURIComponent(String(templateId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'templateId' is not null or undefined
        if (templateId === null || templateId === undefined) {
            throw new Error('Required parameter templateId was null or undefined when calling updateResponseTemplateType.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateResponseTemplateTypeRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ResponseTemplateTypeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ResponseTemplateTypeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MediaVerificationApiApiKeys {
    Bearer,
}

export class MediaVerificationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MediaVerificationApiApiKeys, value: string) {
        (this.authentications as any)[MediaVerificationApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public getContentItemsForMediaItem (mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: MediaContentItems;  }> {
        const localVarPath = this.basePath + '/api/MediaVerification/contentItems/{mediaItemId}'
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling getContentItemsForMediaItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: MediaContentItems;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "MediaContentItems");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum MicrosoftAuthorizationApiApiKeys {
    Bearer,
}

export class MicrosoftAuthorizationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: MicrosoftAuthorizationApiApiKeys, value: string) {
        (this.authentications as any)[MicrosoftAuthorizationApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param organizationId 
     * @param {*} [options] Override http request options.
     */
    public getAvailableCredentials (organizationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<TokenResponse>;  }> {
        const localVarPath = this.basePath + '/api/MicrosoftAuthorization/Credentials/{organizationId}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getAvailableCredentials.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<TokenResponse>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TokenResponse>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param code 
     * @param state 
     * @param error 
     * @param {*} [options] Override http request options.
     */
    public microsoftAuthCallbackAsync (code?: string, state?: string, error?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/MicrosoftAuthorization/Callback';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (code !== undefined) {
            localVarQueryParameters['code'] = ObjectSerializer.serialize(code, "string");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "string");
        }

        if (error !== undefined) {
            localVarQueryParameters['error'] = ObjectSerializer.serialize(error, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param tokenId 
     * @param {*} [options] Override http request options.
     */
    public removeCredential (tokenId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/MicrosoftAuthorization/Credentials/{tokenId}'
            .replace('{' + 'tokenId' + '}', encodeURIComponent(String(tokenId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'tokenId' is not null or undefined
        if (tokenId === null || tokenId === undefined) {
            throw new Error('Required parameter tokenId was null or undefined when calling removeCredential.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param organizationId 
     * @param applicationId 
     * @param salt 
     * @param {*} [options] Override http request options.
     */
    public requestAuthenticationUrl (organizationId?: string, applicationId?: string, salt?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/MicrosoftAuthorization/AuthorizationUrl';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (organizationId !== undefined) {
            localVarQueryParameters['organizationId'] = ObjectSerializer.serialize(organizationId, "string");
        }

        if (applicationId !== undefined) {
            localVarQueryParameters['applicationId'] = ObjectSerializer.serialize(applicationId, "string");
        }

        if (salt !== undefined) {
            localVarQueryParameters['salt'] = ObjectSerializer.serialize(salt, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ModuleApiApiKeys {
    Bearer,
}

export class ModuleApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ModuleApiApiKeys, value: string) {
        (this.authentications as any)[ModuleApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a collection of new modules to the given application
     * @param applicationId 
     * @param models 
     * @param {*} [options] Override http request options.
     */
    public addCustomModulesToApplication (applicationId: string, models?: Array<NewModuleRequest>, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/Module/addCustomModules/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling addCustomModulesToApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(models, "Array<NewModuleRequest>")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public addFeatureToGeneralModule (applicationId: string, model?: AddFeatureToModuleRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/Module/addUncategorizedFeature/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling addFeatureToGeneralModule.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "AddFeatureToModuleRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a feature to the given application module
     * @param applicationModuleId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public addFeatureToModule (applicationModuleId: string, model?: AddFeatureToModuleRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/Module/addFeature/{applicationModuleId}'
            .replace('{' + 'applicationModuleId' + '}', encodeURIComponent(String(applicationModuleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationModuleId' is not null or undefined
        if (applicationModuleId === null || applicationModuleId === undefined) {
            throw new Error('Required parameter applicationModuleId was null or undefined when calling addFeatureToModule.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "AddFeatureToModuleRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a module to the given application
     * @param applicationId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public addModuleToApplication (applicationId: string, model?: AddModuleToApplicationRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/Module/addModule/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling addModuleToApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "AddModuleToApplicationRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param applicationModuleIds 
     * @param {*} [options] Override http request options.
     */
    public changeApplicationModuleOrder (applicationId: string, applicationModuleIds?: Array<string>, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/Module/reorderModules/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling changeApplicationModuleOrder.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(applicationModuleIds, "Array<string>")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a custom module for the given application
     * @param applicationId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createCustomModule (applicationId: string, model?: NewModuleRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/Module/custom/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling createCustomModule.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewModuleRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Disables the given application module
     * @param applicationModuleId 
     * @param {*} [options] Override http request options.
     */
    public disableApplicationModule (applicationModuleId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/Module/{applicationModuleId}/disable'
            .replace('{' + 'applicationModuleId' + '}', encodeURIComponent(String(applicationModuleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationModuleId' is not null or undefined
        if (applicationModuleId === null || applicationModuleId === undefined) {
            throw new Error('Required parameter applicationModuleId was null or undefined when calling disableApplicationModule.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the modules for the given application
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getModulesForApplication (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/Module/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getModulesForApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets all the system modules supported by voicify
     * @param {*} [options] Override http request options.
     */
    public getSystemModules (options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/Module/SystemModules';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationModuleId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateApplicationModule (applicationModuleId: string, model?: UpdateApplicationModuleRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/Module/{applicationModuleId}/update'
            .replace('{' + 'applicationModuleId' + '}', encodeURIComponent(String(applicationModuleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationModuleId' is not null or undefined
        if (applicationModuleId === null || applicationModuleId === undefined) {
            throw new Error('Required parameter applicationModuleId was null or undefined when calling updateApplicationModule.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateApplicationModuleRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum NumberRangeApiApiKeys {
    Bearer,
}

export class NumberRangeApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: NumberRangeApiApiKeys, value: string) {
        (this.authentications as any)[NumberRangeApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds an audio file to the given response
     * @param numberRangeResponseId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addAudioFile (numberRangeResponseId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NumberRangeResponseModel;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/{numberRangeResponseId}/addAudioFile/{mediaItemId}'
            .replace('{' + 'numberRangeResponseId' + '}', encodeURIComponent(String(numberRangeResponseId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'numberRangeResponseId' is not null or undefined
        if (numberRangeResponseId === null || numberRangeResponseId === undefined) {
            throw new Error('Required parameter numberRangeResponseId was null or undefined when calling addAudioFile.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addAudioFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NumberRangeResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NumberRangeResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a large image to the given response
     * @param numberRangeResponseId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addLargeImage (numberRangeResponseId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NumberRangeResponseModel;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/{numberRangeResponseId}/addLargeImage/{mediaItemId}'
            .replace('{' + 'numberRangeResponseId' + '}', encodeURIComponent(String(numberRangeResponseId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'numberRangeResponseId' is not null or undefined
        if (numberRangeResponseId === null || numberRangeResponseId === undefined) {
            throw new Error('Required parameter numberRangeResponseId was null or undefined when calling addLargeImage.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addLargeImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NumberRangeResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NumberRangeResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a small image item to the given response
     * @param numberRangeResponseId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addSmallImage (numberRangeResponseId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NumberRangeResponseModel;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/{numberRangeResponseId}/addSmallImage/{mediaItemId}'
            .replace('{' + 'numberRangeResponseId' + '}', encodeURIComponent(String(numberRangeResponseId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'numberRangeResponseId' is not null or undefined
        if (numberRangeResponseId === null || numberRangeResponseId === undefined) {
            throw new Error('Required parameter numberRangeResponseId was null or undefined when calling addSmallImage.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addSmallImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NumberRangeResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NumberRangeResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a video file to the given response
     * @param numberRangeResponseId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addVideoFile (numberRangeResponseId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NumberRangeResponseModel;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/{numberRangeResponseId}/addVideoFile/{mediaItemId}'
            .replace('{' + 'numberRangeResponseId' + '}', encodeURIComponent(String(numberRangeResponseId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'numberRangeResponseId' is not null or undefined
        if (numberRangeResponseId === null || numberRangeResponseId === undefined) {
            throw new Error('Required parameter numberRangeResponseId was null or undefined when calling addVideoFile.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addVideoFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NumberRangeResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NumberRangeResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param numberRangeId 
     * @param webhookId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public addWebhook (numberRangeId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NumberRangeWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/{numberRangeId}/webhooks/{webhookId}'
            .replace('{' + 'numberRangeId' + '}', encodeURIComponent(String(numberRangeId)))
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'numberRangeId' is not null or undefined
        if (numberRangeId === null || numberRangeId === undefined) {
            throw new Error('Required parameter numberRangeId was null or undefined when calling addWebhook.');
        }

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling addWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NumberRangeWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NumberRangeWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param numberRangeId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public bulkUpdateNumberRange (numberRangeId: string, model?: BulkUpdateNumberRangeRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NumberRangeModel;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/{numberRangeId}/bulkUpdate'
            .replace('{' + 'numberRangeId' + '}', encodeURIComponent(String(numberRangeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'numberRangeId' is not null or undefined
        if (numberRangeId === null || numberRangeId === undefined) {
            throw new Error('Required parameter numberRangeId was null or undefined when calling bulkUpdateNumberRange.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BulkUpdateNumberRangeRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NumberRangeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NumberRangeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param numberRangeId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public bulkUpdateNumberRangeStub (numberRangeId: string, model?: BulkUpdateNumberRangeStubRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NumberRangeModel;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/{numberRangeId}/bulkUpdate/stub'
            .replace('{' + 'numberRangeId' + '}', encodeURIComponent(String(numberRangeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'numberRangeId' is not null or undefined
        if (numberRangeId === null || numberRangeId === undefined) {
            throw new Error('Required parameter numberRangeId was null or undefined when calling bulkUpdateNumberRangeStub.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BulkUpdateNumberRangeStubRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NumberRangeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NumberRangeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param numberRangeId 
     * @param {*} [options] Override http request options.
     */
    public copyContentItem (numberRangeId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NumberRangeModel;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/{numberRangeId}/copy'
            .replace('{' + 'numberRangeId' + '}', encodeURIComponent(String(numberRangeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'numberRangeId' is not null or undefined
        if (numberRangeId === null || numberRangeId === undefined) {
            throw new Error('Required parameter numberRangeId was null or undefined when calling copyContentItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NumberRangeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NumberRangeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createFullContentItem (model?: NumberRangeModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NumberRangeModel;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/full';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NumberRangeModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NumberRangeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NumberRangeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new number range entity
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createNumberRange (model?: NewNumberRangeRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NumberRangeModel;  }> {
        const localVarPath = this.basePath + '/api/NumberRange';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewNumberRangeRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NumberRangeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NumberRangeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new number range entity
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createNumberRangeStub (model?: NewNumberRangeStubRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NumberRangeModel;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/stub';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewNumberRangeStubRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NumberRangeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NumberRangeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new response varation for the given message
     * @param numberRangeId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createResponse (numberRangeId: string, model?: NewNumberRangeResponseRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NumberRangeResponseModel;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/{numberRangeId}/response'
            .replace('{' + 'numberRangeId' + '}', encodeURIComponent(String(numberRangeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'numberRangeId' is not null or undefined
        if (numberRangeId === null || numberRangeId === undefined) {
            throw new Error('Required parameter numberRangeId was null or undefined when calling createResponse.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewNumberRangeResponseRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NumberRangeResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NumberRangeResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public createUserDefinedParameter (instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/webhook/{instanceWebhookId}/userParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling createUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UserDefinedWebhookParameterCreateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete the given number range
     * @param numberRangeId 
     * @param {*} [options] Override http request options.
     */
    public deleteNumberRange (numberRangeId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NumberRangeModel;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/{numberRangeId}'
            .replace('{' + 'numberRangeId' + '}', encodeURIComponent(String(numberRangeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'numberRangeId' is not null or undefined
        if (numberRangeId === null || numberRangeId === undefined) {
            throw new Error('Required parameter numberRangeId was null or undefined when calling deleteNumberRange.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NumberRangeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NumberRangeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes the given response
     * @param numberRangeResponseId 
     * @param {*} [options] Override http request options.
     */
    public deleteResponse (numberRangeResponseId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NumberRangeResponseModel;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/response/{numberRangeResponseId}'
            .replace('{' + 'numberRangeResponseId' + '}', encodeURIComponent(String(numberRangeResponseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'numberRangeResponseId' is not null or undefined
        if (numberRangeResponseId === null || numberRangeResponseId === undefined) {
            throw new Error('Required parameter numberRangeResponseId was null or undefined when calling deleteResponse.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NumberRangeResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NumberRangeResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Finds the full content item by id
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public findFullById (id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NumberRangeModel;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/full/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findFullById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NumberRangeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NumberRangeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the content for the given application feature
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public getByApplicationFeature (applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<NumberRangeModel>;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/byFeature/{applicationFeatureId}'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling getByApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<NumberRangeModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<NumberRangeModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the number ranges content for the given application  regardless of module
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getMessagesForApplication (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<NumberRangeModel>;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getMessagesForApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<NumberRangeModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<NumberRangeModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the number ranges for the given application module
     * @param applicationModuleId 
     * @param {*} [options] Override http request options.
     */
    public getMessagesForModule (applicationModuleId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<NumberRangeModel>;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/module/{applicationModuleId}'
            .replace('{' + 'applicationModuleId' + '}', encodeURIComponent(String(applicationModuleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationModuleId' is not null or undefined
        if (applicationModuleId === null || applicationModuleId === undefined) {
            throw new Error('Required parameter applicationModuleId was null or undefined when calling getMessagesForModule.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<NumberRangeModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<NumberRangeModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param numberRangeId 
     * @param {*} [options] Override http request options.
     */
    public getWebhooks (numberRangeId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<NumberRangeWebhookModel>;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/{numberRangeId}/webhooks'
            .replace('{' + 'numberRangeId' + '}', encodeURIComponent(String(numberRangeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'numberRangeId' is not null or undefined
        if (numberRangeId === null || numberRangeId === undefined) {
            throw new Error('Required parameter numberRangeId was null or undefined when calling getWebhooks.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<NumberRangeWebhookModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<NumberRangeWebhookModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param contentItemId 
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public moveContentItemToApplicationFeature (contentItemId: string, applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NumberRangeModel;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/{contentItemId}/MoveToFeature/{applicationFeatureId}'
            .replace('{' + 'contentItemId' + '}', encodeURIComponent(String(contentItemId)))
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentItemId' is not null or undefined
        if (contentItemId === null || contentItemId === undefined) {
            throw new Error('Required parameter contentItemId was null or undefined when calling moveContentItemToApplicationFeature.');
        }

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling moveContentItemToApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NumberRangeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NumberRangeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param parameterName 
     * @param {*} [options] Override http request options.
     */
    public removeUserDefinedParameter (instanceWebhookId: string, parameterName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/webhook/{instanceWebhookId}/userParameters/{parameterName}'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)))
            .replace('{' + 'parameterName' + '}', encodeURIComponent(String(parameterName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling removeUserDefinedParameter.');
        }

        // verify required parameter 'parameterName' is not null or undefined
        if (parameterName === null || parameterName === undefined) {
            throw new Error('Required parameter parameterName was null or undefined when calling removeUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param numberRangeWebhookId 
     * @param {*} [options] Override http request options.
     */
    public removeWebhook (numberRangeWebhookId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NumberRangeWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/webhook/{numberRangeWebhookId}'
            .replace('{' + 'numberRangeWebhookId' + '}', encodeURIComponent(String(numberRangeWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'numberRangeWebhookId' is not null or undefined
        if (numberRangeWebhookId === null || numberRangeWebhookId === undefined) {
            throw new Error('Required parameter numberRangeWebhookId was null or undefined when calling removeWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NumberRangeWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NumberRangeWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Toggles the given message as live or not
     * @param numberRangeId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public toggleLive (numberRangeId: string, model?: ToggleLiveRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NumberRangeModel;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/{numberRangeId}/isLive'
            .replace('{' + 'numberRangeId' + '}', encodeURIComponent(String(numberRangeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'numberRangeId' is not null or undefined
        if (numberRangeId === null || numberRangeId === undefined) {
            throw new Error('Required parameter numberRangeId was null or undefined when calling toggleLive.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "ToggleLiveRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NumberRangeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NumberRangeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param numberRangeId 
     * @param webhookInstanceId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public updateAttachedWebhook (numberRangeId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NumberRangeWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/{numberRangeId}/webhooks/{webhookInstanceId}'
            .replace('{' + 'numberRangeId' + '}', encodeURIComponent(String(numberRangeId)))
            .replace('{' + 'webhookInstanceId' + '}', encodeURIComponent(String(webhookInstanceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'numberRangeId' is not null or undefined
        if (numberRangeId === null || numberRangeId === undefined) {
            throw new Error('Required parameter numberRangeId was null or undefined when calling updateAttachedWebhook.');
        }

        // verify required parameter 'webhookInstanceId' is not null or undefined
        if (webhookInstanceId === null || webhookInstanceId === undefined) {
            throw new Error('Required parameter webhookInstanceId was null or undefined when calling updateAttachedWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NumberRangeWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NumberRangeWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param contentItemId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateFullContentItem (contentItemId: string, model?: NumberRangeModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NumberRangeModel;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/{contentItemId}/full'
            .replace('{' + 'contentItemId' + '}', encodeURIComponent(String(contentItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentItemId' is not null or undefined
        if (contentItemId === null || contentItemId === undefined) {
            throw new Error('Required parameter contentItemId was null or undefined when calling updateFullContentItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NumberRangeModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NumberRangeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NumberRangeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the number range with the given fields  If you send null or no value for fields, they won't be updated
     * @param numberRangeId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateMessage (numberRangeId: string, model?: UpdateNumberRangeRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NumberRangeModel;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/{numberRangeId}'
            .replace('{' + 'numberRangeId' + '}', encodeURIComponent(String(numberRangeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'numberRangeId' is not null or undefined
        if (numberRangeId === null || numberRangeId === undefined) {
            throw new Error('Required parameter numberRangeId was null or undefined when calling updateMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateNumberRangeRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NumberRangeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NumberRangeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the given response
     * @param numberRangeResponseId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateResponse (numberRangeResponseId: string, model?: UpdateNumberRangeResponseRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: NumberRangeResponseModel;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/response/{numberRangeResponseId}'
            .replace('{' + 'numberRangeResponseId' + '}', encodeURIComponent(String(numberRangeResponseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'numberRangeResponseId' is not null or undefined
        if (numberRangeResponseId === null || numberRangeResponseId === undefined) {
            throw new Error('Required parameter numberRangeResponseId was null or undefined when calling updateResponse.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateNumberRangeResponseRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: NumberRangeResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "NumberRangeResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateUserDefinedParameter (instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/webhook/{instanceWebhookId}/userParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UserDefinedWebhookParameterUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateWebhookParameter (instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/NumberRange/webhook/{instanceWebhookId}/webhookParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateWebhookParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "WebhookParameterUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum OrganizationApiApiKeys {
    Bearer,
}

export class OrganizationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: OrganizationApiApiKeys, value: string) {
        (this.authentications as any)[OrganizationApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Creates a new Organization
     * @param model The details of the organization
     * @param {*} [options] Override http request options.
     */
    public createOrganization (model?: NewOrganizationRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: OrganizationModel;  }> {
        const localVarPath = this.basePath + '/api/Organization';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewOrganizationRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: OrganizationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OrganizationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the members of an organization
     * @param organizationId The id of the organization
     * @param {*} [options] Override http request options.
     */
    public getDetailedMemberships (organizationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<MembershipModel>;  }> {
        const localVarPath = this.basePath + '/api/Organization/{organizationId}/members/detailed'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getDetailedMemberships.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<MembershipModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<MembershipModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the organization that the current user is a member of
     * @param {*} [options] Override http request options.
     */
    public getForUser (options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<OrganizationModel>;  }> {
        const localVarPath = this.basePath + '/api/Organization';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<OrganizationModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<OrganizationModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the members of an organization
     * @param organizationId The id of the organization
     * @param {*} [options] Override http request options.
     */
    public getMembers (organizationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<OrganizationMemberModel>;  }> {
        const localVarPath = this.basePath + '/api/Organization/{organizationId}/members'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getMembers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<OrganizationMemberModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<OrganizationMemberModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Leaves the organization and deletes the current user member record
     * @param organizationId 
     * @param {*} [options] Override http request options.
     */
    public leaveOrganization (organizationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: OrganizationMemberModel;  }> {
        const localVarPath = this.basePath + '/api/Organization/{organizationId}/leave'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling leaveOrganization.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: OrganizationMemberModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OrganizationMemberModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Regenerates the given org's secret used for authentication
     * @param organizationId 
     * @param {*} [options] Override http request options.
     */
    public regenerateOrganizationSecret (organizationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: OrganizationModel;  }> {
        const localVarPath = this.basePath + '/api/Organization/{organizationId}/regenerateSecrets'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling regenerateOrganizationSecret.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: OrganizationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OrganizationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Removes a member of the organization
     * @param organizationMemberId The member id
     * @param {*} [options] Override http request options.
     */
    public removeMember (organizationMemberId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: OrganizationMemberModel;  }> {
        const localVarPath = this.basePath + '/api/Organization/members/{organizationMemberId}/remove'
            .replace('{' + 'organizationMemberId' + '}', encodeURIComponent(String(organizationMemberId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationMemberId' is not null or undefined
        if (organizationMemberId === null || organizationMemberId === undefined) {
            throw new Error('Required parameter organizationMemberId was null or undefined when calling removeMember.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: OrganizationMemberModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OrganizationMemberModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the organization's details
     * @param organizationId the id of the organization
     * @param model The information to update
     * @param {*} [options] Override http request options.
     */
    public updateDetails (organizationId: string, model?: UpdateOrganizationRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: OrganizationModel;  }> {
        const localVarPath = this.basePath + '/api/Organization/{organizationId}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling updateDetails.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateOrganizationRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: OrganizationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OrganizationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the role of a member of an organization
     * @param organizationMemberId The member id
     * @param model The role information
     * @param {*} [options] Override http request options.
     */
    public updateMemberRole (organizationMemberId: string, model?: MemberRoleUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: OrganizationMemberModel;  }> {
        const localVarPath = this.basePath + '/api/Organization/members/{organizationMemberId}/role'
            .replace('{' + 'organizationMemberId' + '}', encodeURIComponent(String(organizationMemberId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationMemberId' is not null or undefined
        if (organizationMemberId === null || organizationMemberId === undefined) {
            throw new Error('Required parameter organizationMemberId was null or undefined when calling updateMemberRole.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "MemberRoleUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: OrganizationMemberModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "OrganizationMemberModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum QuestionAnswerApiApiKeys {
    Bearer,
}

export class QuestionAnswerApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: QuestionAnswerApiApiKeys, value: string) {
        (this.authentications as any)[QuestionAnswerApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete an FAQ
     * @param questionAnswerId 
     * @param {*} [options] Override http request options.
     */
    public _delete (questionAnswerId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/{questionAnswerId}'
            .replace('{' + 'questionAnswerId' + '}', encodeURIComponent(String(questionAnswerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'questionAnswerId' is not null or undefined
        if (questionAnswerId === null || questionAnswerId === undefined) {
            throw new Error('Required parameter questionAnswerId was null or undefined when calling _delete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionAnswerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds an audio file to the answer message
     * @param answerMessageId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addAudioFileImage (answerMessageId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AnswerModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/{answerMessageId}/addAudioFile/{mediaItemId}'
            .replace('{' + 'answerMessageId' + '}', encodeURIComponent(String(answerMessageId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'answerMessageId' is not null or undefined
        if (answerMessageId === null || answerMessageId === undefined) {
            throw new Error('Required parameter answerMessageId was null or undefined when calling addAudioFileImage.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addAudioFileImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AnswerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AnswerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a large image to the answer message
     * @param answerMessageId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addLargeImage (answerMessageId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AnswerModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/{answerMessageId}/addLargeImage/{mediaItemId}'
            .replace('{' + 'answerMessageId' + '}', encodeURIComponent(String(answerMessageId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'answerMessageId' is not null or undefined
        if (answerMessageId === null || answerMessageId === undefined) {
            throw new Error('Required parameter answerMessageId was null or undefined when calling addLargeImage.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addLargeImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AnswerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AnswerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds required user phrases to a quesiton answer item.
     * @param contentItemId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public addOrUpdateRequiredPhrases (contentItemId: string, request?: RequiredPhrasesRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/{contentItemId}/RequiredPhrases'
            .replace('{' + 'contentItemId' + '}', encodeURIComponent(String(contentItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentItemId' is not null or undefined
        if (contentItemId === null || contentItemId === undefined) {
            throw new Error('Required parameter contentItemId was null or undefined when calling addOrUpdateRequiredPhrases.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "RequiredPhrasesRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionAnswerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a small image to the answer message
     * @param answerMessageId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addSmallImage (answerMessageId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AnswerModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/{answerMessageId}/addSmallImage/{mediaItemId}'
            .replace('{' + 'answerMessageId' + '}', encodeURIComponent(String(answerMessageId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'answerMessageId' is not null or undefined
        if (answerMessageId === null || answerMessageId === undefined) {
            throw new Error('Required parameter answerMessageId was null or undefined when calling addSmallImage.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addSmallImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AnswerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AnswerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a video file to the answer message
     * @param answerMessageId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addVideoFile (answerMessageId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AnswerModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/{answerMessageId}/addVideoFile/{mediaItemId}'
            .replace('{' + 'answerMessageId' + '}', encodeURIComponent(String(answerMessageId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'answerMessageId' is not null or undefined
        if (answerMessageId === null || answerMessageId === undefined) {
            throw new Error('Required parameter answerMessageId was null or undefined when calling addVideoFile.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addVideoFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AnswerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AnswerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add a webhook to a question answer item
     * @param questionAnswerId 
     * @param webhookId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public addWebhook (questionAnswerId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: QuestionAnswerWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/{questionAnswerId}/webhooks/{webhookId}'
            .replace('{' + 'questionAnswerId' + '}', encodeURIComponent(String(questionAnswerId)))
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'questionAnswerId' is not null or undefined
        if (questionAnswerId === null || questionAnswerId === undefined) {
            throw new Error('Required parameter questionAnswerId was null or undefined when calling addWebhook.');
        }

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling addWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: QuestionAnswerWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionAnswerWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Bulk updates the question answer and the internal variations
     * @param questionAnswerId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public bulkUpdate (questionAnswerId: string, model?: BulkQuestionAnswerUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/{questionAnswerId}/bulkUpdate'
            .replace('{' + 'questionAnswerId' + '}', encodeURIComponent(String(questionAnswerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'questionAnswerId' is not null or undefined
        if (questionAnswerId === null || questionAnswerId === undefined) {
            throw new Error('Required parameter questionAnswerId was null or undefined when calling bulkUpdate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BulkQuestionAnswerUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionAnswerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Bulk updates the question answer and the internal variations
     * @param questionAnswerId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public bulkUpdateStub (questionAnswerId: string, model?: BulkQuestionAnswerUpdateStubRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/{questionAnswerId}/bulkUpdate/stub'
            .replace('{' + 'questionAnswerId' + '}', encodeURIComponent(String(questionAnswerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'questionAnswerId' is not null or undefined
        if (questionAnswerId === null || questionAnswerId === undefined) {
            throw new Error('Required parameter questionAnswerId was null or undefined when calling bulkUpdateStub.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BulkQuestionAnswerUpdateStubRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionAnswerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param questionAnswerId 
     * @param {*} [options] Override http request options.
     */
    public copyContentItem (questionAnswerId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/{questionAnswerId}/copy'
            .replace('{' + 'questionAnswerId' + '}', encodeURIComponent(String(questionAnswerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'questionAnswerId' is not null or undefined
        if (questionAnswerId === null || questionAnswerId === undefined) {
            throw new Error('Required parameter questionAnswerId was null or undefined when calling copyContentItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionAnswerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the content for the given application feature with skip/take
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public countByApplicationFeature (applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: number;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/byFeature/{applicationFeatureId}/count'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling countByApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: number;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "number");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new FAQ
     * @param model Initial question and answer
     * @param {*} [options] Override http request options.
     */
    public create (model?: NewQuestionAnswerRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewQuestionAnswerRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionAnswerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add an answer to the FAQ set
     * @param questionAnswerId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createAnswer (questionAnswerId: string, model?: CreateAnswerRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AnswerModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/{questionAnswerId}/Answer'
            .replace('{' + 'questionAnswerId' + '}', encodeURIComponent(String(questionAnswerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'questionAnswerId' is not null or undefined
        if (questionAnswerId === null || questionAnswerId === undefined) {
            throw new Error('Required parameter questionAnswerId was null or undefined when calling createAnswer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "CreateAnswerRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AnswerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AnswerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createFullContentItem (model?: QuestionAnswerModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/full';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "QuestionAnswerModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionAnswerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Add a question to the FAQ set
     * @param questionAnswerId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createQuestion (questionAnswerId: string, model?: CreateQuestionRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: QuestionModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/{questionAnswerId}/Question'
            .replace('{' + 'questionAnswerId' + '}', encodeURIComponent(String(questionAnswerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'questionAnswerId' is not null or undefined
        if (questionAnswerId === null || questionAnswerId === undefined) {
            throw new Error('Required parameter questionAnswerId was null or undefined when calling createQuestion.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "CreateQuestionRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: QuestionModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new FAQ
     * @param model Initial question and answer
     * @param {*} [options] Override http request options.
     */
    public createStub (model?: NewQuestionAnswerStubRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/stub';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewQuestionAnswerStubRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionAnswerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public createUserDefinedParameter (instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/webhook/{instanceWebhookId}/userParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling createUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UserDefinedWebhookParameterCreateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete an answer
     * @param answerId 
     * @param {*} [options] Override http request options.
     */
    public deleteAnswer (answerId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AnswerModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/answer/{answerId}'
            .replace('{' + 'answerId' + '}', encodeURIComponent(String(answerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'answerId' is not null or undefined
        if (answerId === null || answerId === undefined) {
            throw new Error('Required parameter answerId was null or undefined when calling deleteAnswer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AnswerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AnswerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a question
     * @param questionId 
     * @param {*} [options] Override http request options.
     */
    public deleteQuestion (questionId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: QuestionModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/question/{questionId}'
            .replace('{' + 'questionId' + '}', encodeURIComponent(String(questionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'questionId' is not null or undefined
        if (questionId === null || questionId === undefined) {
            throw new Error('Required parameter questionId was null or undefined when calling deleteQuestion.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: QuestionModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit a given Answer
     * @param answerId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public editAnswer (answerId: string, model?: UpdateAnswerRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: AnswerModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/Answer/{answerId}'
            .replace('{' + 'answerId' + '}', encodeURIComponent(String(answerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'answerId' is not null or undefined
        if (answerId === null || answerId === undefined) {
            throw new Error('Required parameter answerId was null or undefined when calling editAnswer.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateAnswerRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: AnswerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "AnswerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Edit a given question
     * @param questionId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public editQuestion (questionId: string, model?: UpdateQuestionRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: QuestionModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/Question/{questionId}'
            .replace('{' + 'questionId' + '}', encodeURIComponent(String(questionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'questionId' is not null or undefined
        if (questionId === null || questionId === undefined) {
            throw new Error('Required parameter questionId was null or undefined when calling editQuestion.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateQuestionRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: QuestionModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Finds the full content item by id
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public findFullById (id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/full/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findFullById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionAnswerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get an FAQ by its ID
     * @param questionAnswerId 
     * @param {*} [options] Override http request options.
     */
    public get (questionAnswerId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/{questionAnswerId}'
            .replace('{' + 'questionAnswerId' + '}', encodeURIComponent(String(questionAnswerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'questionAnswerId' is not null or undefined
        if (questionAnswerId === null || questionAnswerId === undefined) {
            throw new Error('Required parameter questionAnswerId was null or undefined when calling get.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionAnswerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the content for the given application feature
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public getAllByApplicationFeature (applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<QuestionAnswerModel>;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/byFeature/{applicationFeatureId}'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling getAllByApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<QuestionAnswerModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<QuestionAnswerModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the content for the given application feature with skip/take
     * @param applicationFeatureId 
     * @param sortBy 
     * @param skip 
     * @param take 
     * @param {*} [options] Override http request options.
     */
    public getByApplicationFeature (applicationFeatureId: string, sortBy?: string, skip?: number, take?: number, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<QuestionAnswerModel>;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/byFeature/{applicationFeatureId}/paginated'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling getByApplicationFeature.');
        }

        if (sortBy !== undefined) {
            localVarQueryParameters['sortBy'] = ObjectSerializer.serialize(sortBy, "string");
        }

        if (skip !== undefined) {
            localVarQueryParameters['skip'] = ObjectSerializer.serialize(skip, "number");
        }

        if (take !== undefined) {
            localVarQueryParameters['take'] = ObjectSerializer.serialize(take, "number");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<QuestionAnswerModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<QuestionAnswerModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the FAQs for a given application
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getQuestionAnswersForApplication (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<QuestionAnswerModel>;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/{applicationId}/faqs'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getQuestionAnswersForApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<QuestionAnswerModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<QuestionAnswerModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the webhooks associated with a question answer item
     * @param questionAnswerId 
     * @param {*} [options] Override http request options.
     */
    public getWebhooks (questionAnswerId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<QuestionAnswerWebhookModel>;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/{questionAnswerId}/webhooks'
            .replace('{' + 'questionAnswerId' + '}', encodeURIComponent(String(questionAnswerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'questionAnswerId' is not null or undefined
        if (questionAnswerId === null || questionAnswerId === undefined) {
            throw new Error('Required parameter questionAnswerId was null or undefined when calling getWebhooks.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<QuestionAnswerWebhookModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<QuestionAnswerWebhookModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param contentItemId 
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public moveContentItemToApplicationFeature (contentItemId: string, applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/{contentItemId}/MoveToFeature/{applicationFeatureId}'
            .replace('{' + 'contentItemId' + '}', encodeURIComponent(String(contentItemId)))
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentItemId' is not null or undefined
        if (contentItemId === null || contentItemId === undefined) {
            throw new Error('Required parameter contentItemId was null or undefined when calling moveContentItemToApplicationFeature.');
        }

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling moveContentItemToApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionAnswerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param parameterName 
     * @param {*} [options] Override http request options.
     */
    public removeUserDefinedParameter (instanceWebhookId: string, parameterName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/webhook/{instanceWebhookId}/userParameters/{parameterName}'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)))
            .replace('{' + 'parameterName' + '}', encodeURIComponent(String(parameterName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling removeUserDefinedParameter.');
        }

        // verify required parameter 'parameterName' is not null or undefined
        if (parameterName === null || parameterName === undefined) {
            throw new Error('Required parameter parameterName was null or undefined when calling removeUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete a webhook from a question answer item
     * @param questionAnswerWebhookId 
     * @param {*} [options] Override http request options.
     */
    public removeWebhook (questionAnswerWebhookId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: QuestionAnswerWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/webhook/{questionAnswerWebhookId}'
            .replace('{' + 'questionAnswerWebhookId' + '}', encodeURIComponent(String(questionAnswerWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'questionAnswerWebhookId' is not null or undefined
        if (questionAnswerWebhookId === null || questionAnswerWebhookId === undefined) {
            throw new Error('Required parameter questionAnswerWebhookId was null or undefined when calling removeWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: QuestionAnswerWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionAnswerWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Toggles whether the given FAQ is live or not
     * @param questionAnswerId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public toggleIsLive (questionAnswerId: string, model?: ToggleLiveRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/{questionAnswerId}/isLive'
            .replace('{' + 'questionAnswerId' + '}', encodeURIComponent(String(questionAnswerId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'questionAnswerId' is not null or undefined
        if (questionAnswerId === null || questionAnswerId === undefined) {
            throw new Error('Required parameter questionAnswerId was null or undefined when calling toggleIsLive.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "ToggleLiveRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionAnswerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update a webhook on a question answer item
     * @param questionAnswerId 
     * @param instanceWebhookId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public updateAttachedWebhook (questionAnswerId: string, instanceWebhookId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: QuestionAnswerWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/{questionAnswerId}/webhooks/{instanceWebhookId}'
            .replace('{' + 'questionAnswerId' + '}', encodeURIComponent(String(questionAnswerId)))
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'questionAnswerId' is not null or undefined
        if (questionAnswerId === null || questionAnswerId === undefined) {
            throw new Error('Required parameter questionAnswerId was null or undefined when calling updateAttachedWebhook.');
        }

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateAttachedWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: QuestionAnswerWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionAnswerWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param contentItemId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateFullContentItem (contentItemId: string, model?: QuestionAnswerModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/{contentItemId}/full'
            .replace('{' + 'contentItemId' + '}', encodeURIComponent(String(contentItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentItemId' is not null or undefined
        if (contentItemId === null || contentItemId === undefined) {
            throw new Error('Required parameter contentItemId was null or undefined when calling updateFullContentItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "QuestionAnswerModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: QuestionAnswerModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "QuestionAnswerModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateUserDefinedParameter (instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/webhook/{instanceWebhookId}/userParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UserDefinedWebhookParameterUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateWebhookParameter (instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/QuestionAnswer/webhook/{instanceWebhookId}/webhookParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateWebhookParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "WebhookParameterUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RecipeApiApiKeys {
    Bearer,
}

export class RecipeApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RecipeApiApiKeys, value: string) {
        (this.authentications as any)[RecipeApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param recipeId 
     * @param webhookId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public addWebhook (recipeId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RecipeWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/Recipe/{recipeId}/webhooks/{webhookId}'
            .replace('{' + 'recipeId' + '}', encodeURIComponent(String(recipeId)))
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'recipeId' is not null or undefined
        if (recipeId === null || recipeId === undefined) {
            throw new Error('Required parameter recipeId was null or undefined when calling addWebhook.');
        }

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling addWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RecipeWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RecipeWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param recipeId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public bulkUpdate (recipeId: string, model?: BulkUpdateRecipeRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RecipeModel;  }> {
        const localVarPath = this.basePath + '/api/Recipe/{recipeId}/bulkUpdate'
            .replace('{' + 'recipeId' + '}', encodeURIComponent(String(recipeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'recipeId' is not null or undefined
        if (recipeId === null || recipeId === undefined) {
            throw new Error('Required parameter recipeId was null or undefined when calling bulkUpdate.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BulkUpdateRecipeRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RecipeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RecipeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param recipeId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public bulkUpdateStub (recipeId: string, model?: BulkUpdateRecipeStubRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RecipeModel;  }> {
        const localVarPath = this.basePath + '/api/Recipe/{recipeId}/bulkUpdate/stub'
            .replace('{' + 'recipeId' + '}', encodeURIComponent(String(recipeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'recipeId' is not null or undefined
        if (recipeId === null || recipeId === undefined) {
            throw new Error('Required parameter recipeId was null or undefined when calling bulkUpdateStub.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BulkUpdateRecipeStubRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RecipeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RecipeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param recipeId 
     * @param {*} [options] Override http request options.
     */
    public copyContentItem (recipeId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RecipeModel;  }> {
        const localVarPath = this.basePath + '/api/Recipe/{recipeId}/copy'
            .replace('{' + 'recipeId' + '}', encodeURIComponent(String(recipeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'recipeId' is not null or undefined
        if (recipeId === null || recipeId === undefined) {
            throw new Error('Required parameter recipeId was null or undefined when calling copyContentItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RecipeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RecipeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createFullContentItem (model?: RecipeModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RecipeModel;  }> {
        const localVarPath = this.basePath + '/api/Recipe/full';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "RecipeModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RecipeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RecipeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createRecipe (model?: CreateRecipeRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RecipeModel;  }> {
        const localVarPath = this.basePath + '/api/Recipe';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "CreateRecipeRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RecipeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RecipeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createRecipeStub (model?: CreateRecipeStubRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RecipeModel;  }> {
        const localVarPath = this.basePath + '/api/Recipe/stub';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "CreateRecipeStubRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RecipeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RecipeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public createUserDefinedParameter (instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/Recipe/webhook/{instanceWebhookId}/userParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling createUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UserDefinedWebhookParameterCreateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param recipeId 
     * @param {*} [options] Override http request options.
     */
    public deleteRecipe (recipeId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RecipeModel;  }> {
        const localVarPath = this.basePath + '/api/Recipe/{recipeId}'
            .replace('{' + 'recipeId' + '}', encodeURIComponent(String(recipeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'recipeId' is not null or undefined
        if (recipeId === null || recipeId === undefined) {
            throw new Error('Required parameter recipeId was null or undefined when calling deleteRecipe.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RecipeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RecipeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Finds the full content item by id
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public findFullById (id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RecipeModel;  }> {
        const localVarPath = this.basePath + '/api/Recipe/full/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findFullById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RecipeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RecipeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public getByApplicationFeature (applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<RecipeModel>;  }> {
        const localVarPath = this.basePath + '/api/Recipe/byFeature/{applicationFeatureId}'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling getByApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<RecipeModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<RecipeModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param recipeId 
     * @param {*} [options] Override http request options.
     */
    public getWebhooks (recipeId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RecipeWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/Recipe/{recipeId}/webhooks'
            .replace('{' + 'recipeId' + '}', encodeURIComponent(String(recipeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'recipeId' is not null or undefined
        if (recipeId === null || recipeId === undefined) {
            throw new Error('Required parameter recipeId was null or undefined when calling getWebhooks.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RecipeWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RecipeWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param contentItemId 
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public moveContentItemToApplicationFeature (contentItemId: string, applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RecipeModel;  }> {
        const localVarPath = this.basePath + '/api/Recipe/{contentItemId}/MoveToFeature/{applicationFeatureId}'
            .replace('{' + 'contentItemId' + '}', encodeURIComponent(String(contentItemId)))
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentItemId' is not null or undefined
        if (contentItemId === null || contentItemId === undefined) {
            throw new Error('Required parameter contentItemId was null or undefined when calling moveContentItemToApplicationFeature.');
        }

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling moveContentItemToApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RecipeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RecipeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param parameterName 
     * @param {*} [options] Override http request options.
     */
    public removeUserDefinedParameter (instanceWebhookId: string, parameterName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/Recipe/webhook/{instanceWebhookId}/userParameters/{parameterName}'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)))
            .replace('{' + 'parameterName' + '}', encodeURIComponent(String(parameterName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling removeUserDefinedParameter.');
        }

        // verify required parameter 'parameterName' is not null or undefined
        if (parameterName === null || parameterName === undefined) {
            throw new Error('Required parameter parameterName was null or undefined when calling removeUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param recipeWebhookId 
     * @param {*} [options] Override http request options.
     */
    public removeWebhook (recipeWebhookId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RecipeWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/Recipe/webhook/{recipeWebhookId}'
            .replace('{' + 'recipeWebhookId' + '}', encodeURIComponent(String(recipeWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'recipeWebhookId' is not null or undefined
        if (recipeWebhookId === null || recipeWebhookId === undefined) {
            throw new Error('Required parameter recipeWebhookId was null or undefined when calling removeWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RecipeWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RecipeWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param recipeId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public toggleIsLive (recipeId: string, model?: ToggleLiveRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RecipeModel;  }> {
        const localVarPath = this.basePath + '/api/Recipe/{recipeId}/isLive'
            .replace('{' + 'recipeId' + '}', encodeURIComponent(String(recipeId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'recipeId' is not null or undefined
        if (recipeId === null || recipeId === undefined) {
            throw new Error('Required parameter recipeId was null or undefined when calling toggleIsLive.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "ToggleLiveRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RecipeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RecipeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param recipeId 
     * @param webhookInstanceId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public updateAttachedWebhook (recipeId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RecipeWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/Recipe/{recipeId}/webhooks/{webhookInstanceId}'
            .replace('{' + 'recipeId' + '}', encodeURIComponent(String(recipeId)))
            .replace('{' + 'webhookInstanceId' + '}', encodeURIComponent(String(webhookInstanceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'recipeId' is not null or undefined
        if (recipeId === null || recipeId === undefined) {
            throw new Error('Required parameter recipeId was null or undefined when calling updateAttachedWebhook.');
        }

        // verify required parameter 'webhookInstanceId' is not null or undefined
        if (webhookInstanceId === null || webhookInstanceId === undefined) {
            throw new Error('Required parameter webhookInstanceId was null or undefined when calling updateAttachedWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RecipeWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RecipeWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param contentItemId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateFullContentItem (contentItemId: string, model?: RecipeModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RecipeModel;  }> {
        const localVarPath = this.basePath + '/api/Recipe/{contentItemId}/full'
            .replace('{' + 'contentItemId' + '}', encodeURIComponent(String(contentItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentItemId' is not null or undefined
        if (contentItemId === null || contentItemId === undefined) {
            throw new Error('Required parameter contentItemId was null or undefined when calling updateFullContentItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "RecipeModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RecipeModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RecipeModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateUserDefinedParameter (instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/Recipe/webhook/{instanceWebhookId}/userParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UserDefinedWebhookParameterUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateWebhookParameter (instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/Recipe/webhook/{instanceWebhookId}/webhookParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateWebhookParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "WebhookParameterUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RepromptApiApiKeys {
    Bearer,
}

export class RepromptApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RepromptApiApiKeys, value: string) {
        (this.authentications as any)[RepromptApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param applicationId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createReprompt (applicationId: string, model?: CreateRepromptRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RepromptModel;  }> {
        const localVarPath = this.basePath + '/api/Reprompt/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling createReprompt.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "CreateRepromptRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RepromptModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RepromptModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param repromptId 
     * @param {*} [options] Override http request options.
     */
    public deleteReprompt (repromptId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RepromptModel;  }> {
        const localVarPath = this.basePath + '/api/Reprompt/{repromptId}'
            .replace('{' + 'repromptId' + '}', encodeURIComponent(String(repromptId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'repromptId' is not null or undefined
        if (repromptId === null || repromptId === undefined) {
            throw new Error('Required parameter repromptId was null or undefined when calling deleteReprompt.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RepromptModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RepromptModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getForApplication (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<RepromptModel>;  }> {
        const localVarPath = this.basePath + '/api/Reprompt/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getForApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<RepromptModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<RepromptModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateReprompt (model?: UpdateRepromptRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: RepromptModel;  }> {
        const localVarPath = this.basePath + '/api/Reprompt';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateRepromptRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: RepromptModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "RepromptModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SimpleChoiceApiApiKeys {
    Bearer,
}

export class SimpleChoiceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SimpleChoiceApiApiKeys, value: string) {
        (this.authentications as any)[SimpleChoiceApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds an audio file to the given response
     * @param simpleChoiceResponseId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addAudioFile (simpleChoiceResponseId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SimpleChoiceResponseModel;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/{simpleChoiceResponseId}/addAudioFile/{mediaItemId}'
            .replace('{' + 'simpleChoiceResponseId' + '}', encodeURIComponent(String(simpleChoiceResponseId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'simpleChoiceResponseId' is not null or undefined
        if (simpleChoiceResponseId === null || simpleChoiceResponseId === undefined) {
            throw new Error('Required parameter simpleChoiceResponseId was null or undefined when calling addAudioFile.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addAudioFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SimpleChoiceResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SimpleChoiceResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a large image to the given response
     * @param simpleChoiceResponseId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addLargeImage (simpleChoiceResponseId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SimpleChoiceResponseModel;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/{simpleChoiceResponseId}/addLargeImage/{mediaItemId}'
            .replace('{' + 'simpleChoiceResponseId' + '}', encodeURIComponent(String(simpleChoiceResponseId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'simpleChoiceResponseId' is not null or undefined
        if (simpleChoiceResponseId === null || simpleChoiceResponseId === undefined) {
            throw new Error('Required parameter simpleChoiceResponseId was null or undefined when calling addLargeImage.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addLargeImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SimpleChoiceResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SimpleChoiceResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a small image item to the given response
     * @param simpleChoiceResponseId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addSmallImage (simpleChoiceResponseId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SimpleChoiceResponseModel;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/{simpleChoiceResponseId}/addSmallImage/{mediaItemId}'
            .replace('{' + 'simpleChoiceResponseId' + '}', encodeURIComponent(String(simpleChoiceResponseId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'simpleChoiceResponseId' is not null or undefined
        if (simpleChoiceResponseId === null || simpleChoiceResponseId === undefined) {
            throw new Error('Required parameter simpleChoiceResponseId was null or undefined when calling addSmallImage.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addSmallImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SimpleChoiceResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SimpleChoiceResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a video file to the given response
     * @param simpleChoiceResponseId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addVideoFile (simpleChoiceResponseId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SimpleChoiceResponseModel;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/{simpleChoiceResponseId}/addVideoFile/{mediaItemId}'
            .replace('{' + 'simpleChoiceResponseId' + '}', encodeURIComponent(String(simpleChoiceResponseId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'simpleChoiceResponseId' is not null or undefined
        if (simpleChoiceResponseId === null || simpleChoiceResponseId === undefined) {
            throw new Error('Required parameter simpleChoiceResponseId was null or undefined when calling addVideoFile.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addVideoFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SimpleChoiceResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SimpleChoiceResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param simpleChoiceId 
     * @param webhookId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public addWebhook (simpleChoiceId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SimpleChoiceWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/{simpleChoiceId}/webhooks/{webhookId}'
            .replace('{' + 'simpleChoiceId' + '}', encodeURIComponent(String(simpleChoiceId)))
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'simpleChoiceId' is not null or undefined
        if (simpleChoiceId === null || simpleChoiceId === undefined) {
            throw new Error('Required parameter simpleChoiceId was null or undefined when calling addWebhook.');
        }

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling addWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SimpleChoiceWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SimpleChoiceWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param simpleChoiceId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public bulkUpdateSimpleChoice (simpleChoiceId: string, model?: BulkUpdateSimpleChoiceRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SimpleChoiceModel;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/{simpleChoiceId}/bulkUpdate'
            .replace('{' + 'simpleChoiceId' + '}', encodeURIComponent(String(simpleChoiceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'simpleChoiceId' is not null or undefined
        if (simpleChoiceId === null || simpleChoiceId === undefined) {
            throw new Error('Required parameter simpleChoiceId was null or undefined when calling bulkUpdateSimpleChoice.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BulkUpdateSimpleChoiceRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SimpleChoiceModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SimpleChoiceModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param simpleChoiceId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public bulkUpdateSimpleChoiceStub (simpleChoiceId: string, model?: BulkUpdateSimpleChoiceStubRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SimpleChoiceModel;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/{simpleChoiceId}/bulkUpdate/stub'
            .replace('{' + 'simpleChoiceId' + '}', encodeURIComponent(String(simpleChoiceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'simpleChoiceId' is not null or undefined
        if (simpleChoiceId === null || simpleChoiceId === undefined) {
            throw new Error('Required parameter simpleChoiceId was null or undefined when calling bulkUpdateSimpleChoiceStub.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "BulkUpdateSimpleChoiceStubRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SimpleChoiceModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SimpleChoiceModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param simpleChoiceId 
     * @param {*} [options] Override http request options.
     */
    public copyContentItem (simpleChoiceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SimpleChoiceModel;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/{simpleChoiceId}/copy'
            .replace('{' + 'simpleChoiceId' + '}', encodeURIComponent(String(simpleChoiceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'simpleChoiceId' is not null or undefined
        if (simpleChoiceId === null || simpleChoiceId === undefined) {
            throw new Error('Required parameter simpleChoiceId was null or undefined when calling copyContentItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SimpleChoiceModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SimpleChoiceModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createFullContentItem (model?: SimpleChoiceModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SimpleChoiceModel;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/full';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "SimpleChoiceModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SimpleChoiceModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SimpleChoiceModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new response varation for the given message
     * @param simpleChoiceId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createResponse (simpleChoiceId: string, model?: NewSimpleChoiceResponseRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SimpleChoiceResponseModel;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/{simpleChoiceId}/response'
            .replace('{' + 'simpleChoiceId' + '}', encodeURIComponent(String(simpleChoiceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'simpleChoiceId' is not null or undefined
        if (simpleChoiceId === null || simpleChoiceId === undefined) {
            throw new Error('Required parameter simpleChoiceId was null or undefined when calling createResponse.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewSimpleChoiceResponseRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SimpleChoiceResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SimpleChoiceResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new simple choice entity
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createSimpleChoice (model?: NewSimpleChoiceRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SimpleChoiceModel;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewSimpleChoiceRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SimpleChoiceModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SimpleChoiceModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new simple choice entity
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createSimpleChoiceStub (model?: NewSimpleChoiceStubRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SimpleChoiceModel;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/stub';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewSimpleChoiceStubRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SimpleChoiceModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SimpleChoiceModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public createUserDefinedParameter (instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/webhook/{instanceWebhookId}/userParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling createUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UserDefinedWebhookParameterCreateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes the given response
     * @param simpleChoiceResponseId 
     * @param {*} [options] Override http request options.
     */
    public deleteResponse (simpleChoiceResponseId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SimpleChoiceResponseModel;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/response/{simpleChoiceResponseId}'
            .replace('{' + 'simpleChoiceResponseId' + '}', encodeURIComponent(String(simpleChoiceResponseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'simpleChoiceResponseId' is not null or undefined
        if (simpleChoiceResponseId === null || simpleChoiceResponseId === undefined) {
            throw new Error('Required parameter simpleChoiceResponseId was null or undefined when calling deleteResponse.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SimpleChoiceResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SimpleChoiceResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Delete the given simple choice
     * @param simpleChoiceId 
     * @param {*} [options] Override http request options.
     */
    public deleteSimpleChoice (simpleChoiceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SimpleChoiceModel;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/{simpleChoiceId}'
            .replace('{' + 'simpleChoiceId' + '}', encodeURIComponent(String(simpleChoiceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'simpleChoiceId' is not null or undefined
        if (simpleChoiceId === null || simpleChoiceId === undefined) {
            throw new Error('Required parameter simpleChoiceId was null or undefined when calling deleteSimpleChoice.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SimpleChoiceModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SimpleChoiceModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Finds the full content item by id
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public findFullById (id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SimpleChoiceModel;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/full/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findFullById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SimpleChoiceModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SimpleChoiceModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the content for the given application feature
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public getByApplicationFeature (applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<SimpleChoiceModel>;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/byFeature/{applicationFeatureId}'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling getByApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<SimpleChoiceModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<SimpleChoiceModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the simple choices content for the given application  regardless of module
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getMessagesForApplication (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<SimpleChoiceModel>;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getMessagesForApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<SimpleChoiceModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<SimpleChoiceModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the simple choices for the given application module
     * @param applicationModuleId 
     * @param {*} [options] Override http request options.
     */
    public getMessagesForModule (applicationModuleId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<SimpleChoiceModel>;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/module/{applicationModuleId}'
            .replace('{' + 'applicationModuleId' + '}', encodeURIComponent(String(applicationModuleId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationModuleId' is not null or undefined
        if (applicationModuleId === null || applicationModuleId === undefined) {
            throw new Error('Required parameter applicationModuleId was null or undefined when calling getMessagesForModule.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<SimpleChoiceModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<SimpleChoiceModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param simpleChoiceId 
     * @param {*} [options] Override http request options.
     */
    public getWebhooks (simpleChoiceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<SimpleChoiceWebhookModel>;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/{simpleChoiceId}/webhooks'
            .replace('{' + 'simpleChoiceId' + '}', encodeURIComponent(String(simpleChoiceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'simpleChoiceId' is not null or undefined
        if (simpleChoiceId === null || simpleChoiceId === undefined) {
            throw new Error('Required parameter simpleChoiceId was null or undefined when calling getWebhooks.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<SimpleChoiceWebhookModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<SimpleChoiceWebhookModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param contentItemId 
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public moveContentItemToApplicationFeature (contentItemId: string, applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SimpleChoiceModel;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/{contentItemId}/MoveToFeature/{applicationFeatureId}'
            .replace('{' + 'contentItemId' + '}', encodeURIComponent(String(contentItemId)))
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentItemId' is not null or undefined
        if (contentItemId === null || contentItemId === undefined) {
            throw new Error('Required parameter contentItemId was null or undefined when calling moveContentItemToApplicationFeature.');
        }

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling moveContentItemToApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SimpleChoiceModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SimpleChoiceModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param parameterName 
     * @param {*} [options] Override http request options.
     */
    public removeUserDefinedParameter (instanceWebhookId: string, parameterName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/webhook/{instanceWebhookId}/userParameters/{parameterName}'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)))
            .replace('{' + 'parameterName' + '}', encodeURIComponent(String(parameterName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling removeUserDefinedParameter.');
        }

        // verify required parameter 'parameterName' is not null or undefined
        if (parameterName === null || parameterName === undefined) {
            throw new Error('Required parameter parameterName was null or undefined when calling removeUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param simpleChoiceWebhookId 
     * @param {*} [options] Override http request options.
     */
    public removeWebhook (simpleChoiceWebhookId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SimpleChoiceWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/webhook/{simpleChoiceWebhookId}'
            .replace('{' + 'simpleChoiceWebhookId' + '}', encodeURIComponent(String(simpleChoiceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'simpleChoiceWebhookId' is not null or undefined
        if (simpleChoiceWebhookId === null || simpleChoiceWebhookId === undefined) {
            throw new Error('Required parameter simpleChoiceWebhookId was null or undefined when calling removeWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SimpleChoiceWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SimpleChoiceWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Toggles the given message as live or not
     * @param simpleChoiceId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public toggleLive (simpleChoiceId: string, model?: ToggleLiveRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SimpleChoiceModel;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/{simpleChoiceId}/isLive'
            .replace('{' + 'simpleChoiceId' + '}', encodeURIComponent(String(simpleChoiceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'simpleChoiceId' is not null or undefined
        if (simpleChoiceId === null || simpleChoiceId === undefined) {
            throw new Error('Required parameter simpleChoiceId was null or undefined when calling toggleLive.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "ToggleLiveRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SimpleChoiceModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SimpleChoiceModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param simpleChoiceId 
     * @param webhookInstanceId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public updateAttachedWebhook (simpleChoiceId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SimpleChoiceWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/{simpleChoiceId}/webhooks/{webhookInstanceId}'
            .replace('{' + 'simpleChoiceId' + '}', encodeURIComponent(String(simpleChoiceId)))
            .replace('{' + 'webhookInstanceId' + '}', encodeURIComponent(String(webhookInstanceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'simpleChoiceId' is not null or undefined
        if (simpleChoiceId === null || simpleChoiceId === undefined) {
            throw new Error('Required parameter simpleChoiceId was null or undefined when calling updateAttachedWebhook.');
        }

        // verify required parameter 'webhookInstanceId' is not null or undefined
        if (webhookInstanceId === null || webhookInstanceId === undefined) {
            throw new Error('Required parameter webhookInstanceId was null or undefined when calling updateAttachedWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SimpleChoiceWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SimpleChoiceWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param contentItemId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateFullContentItem (contentItemId: string, model?: SimpleChoiceModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SimpleChoiceModel;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/{contentItemId}/full'
            .replace('{' + 'contentItemId' + '}', encodeURIComponent(String(contentItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentItemId' is not null or undefined
        if (contentItemId === null || contentItemId === undefined) {
            throw new Error('Required parameter contentItemId was null or undefined when calling updateFullContentItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "SimpleChoiceModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SimpleChoiceModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SimpleChoiceModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the simple choice with the given fields  If you send null or no value for fields, they won't be updated
     * @param simpleChoiceId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateMessage (simpleChoiceId: string, model?: UpdateSimpleChoiceRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SimpleChoiceModel;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/{simpleChoiceId}'
            .replace('{' + 'simpleChoiceId' + '}', encodeURIComponent(String(simpleChoiceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'simpleChoiceId' is not null or undefined
        if (simpleChoiceId === null || simpleChoiceId === undefined) {
            throw new Error('Required parameter simpleChoiceId was null or undefined when calling updateMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateSimpleChoiceRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SimpleChoiceModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SimpleChoiceModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the given response
     * @param simpleChoiceResponseId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateResponse (simpleChoiceResponseId: string, model?: UpdateSimpleChoiceResponseRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SimpleChoiceResponseModel;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/response/{simpleChoiceResponseId}'
            .replace('{' + 'simpleChoiceResponseId' + '}', encodeURIComponent(String(simpleChoiceResponseId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'simpleChoiceResponseId' is not null or undefined
        if (simpleChoiceResponseId === null || simpleChoiceResponseId === undefined) {
            throw new Error('Required parameter simpleChoiceResponseId was null or undefined when calling updateResponse.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateSimpleChoiceResponseRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SimpleChoiceResponseModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SimpleChoiceResponseModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateUserDefinedParameter (instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/webhook/{instanceWebhookId}/userParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UserDefinedWebhookParameterUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateWebhookParameter (instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/SimpleChoice/webhook/{instanceWebhookId}/webhookParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateWebhookParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "WebhookParameterUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SingleSignOnApiApiKeys {
    Bearer,
}

export class SingleSignOnApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SingleSignOnApiApiKeys, value: string) {
        (this.authentications as any)[SingleSignOnApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Begins single sign in process
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public signInWithSingleSignOn (request?: SingleSignOnRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SingleSignOnResponse;  }> {
        const localVarPath = this.basePath + '/api/SingleSignOn/signIn';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "SingleSignOnRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SingleSignOnResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SingleSignOnResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Begins sign up with SSO process
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public signUpWithSingleSignOn (request?: SingleSignOnRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SingleSignOnResponse;  }> {
        const localVarPath = this.basePath + '/api/SingleSignOn/signUp';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "SingleSignOnRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SingleSignOnResponse;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SingleSignOnResponse");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SingleSignOnRedirectApiApiKeys {
    Bearer,
}

export class SingleSignOnRedirectApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SingleSignOnRedirectApiApiKeys, value: string) {
        (this.authentications as any)[SingleSignOnRedirectApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param code 
     * @param state 
     * @param error 
     * @param {*} [options] Override http request options.
     */
    public oAuth2CallbackGet (code?: string, state?: string, error?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/SingleSignOnRedirect/oauth2';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (code !== undefined) {
            localVarQueryParameters['code'] = ObjectSerializer.serialize(code, "string");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "string");
        }

        if (error !== undefined) {
            localVarQueryParameters['error'] = ObjectSerializer.serialize(error, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param samlResponse 
     * @param redirectUrl 
     * @param email 
     * @param clientId 
     * @param {*} [options] Override http request options.
     */
    public sAMLCallback (samlResponse?: string, redirectUrl?: string, email?: string, clientId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/SingleSignOnRedirect/saml';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (redirectUrl !== undefined) {
            localVarQueryParameters['redirectUrl'] = ObjectSerializer.serialize(redirectUrl, "string");
        }

        if (email !== undefined) {
            localVarQueryParameters['email'] = ObjectSerializer.serialize(email, "string");
        }

        if (clientId !== undefined) {
            localVarQueryParameters['clientId'] = ObjectSerializer.serialize(clientId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (samlResponse !== undefined) {
            localVarFormParams['samlResponse'] = ObjectSerializer.serialize(samlResponse, "string");
        }

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SsmlApiApiKeys {
    Bearer,
}

export class SsmlApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SsmlApiApiKeys, value: string) {
        (this.authentications as any)[SsmlApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param element 
     * @param {*} [options] Override http request options.
     */
    public build (element?: SsmlElement, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/api/Ssml/build';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(element, "SsmlElement")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public parse (request?: SsmlRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: SsmlElement;  }> {
        const localVarPath = this.basePath + '/api/Ssml/parse';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "SsmlRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: SsmlElement;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "SsmlElement");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param request 
     * @param tag 
     * @param {*} [options] Override http request options.
     */
    public segment (request?: SsmlRequest, tag?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<SsmlElement>;  }> {
        const localVarPath = this.basePath + '/api/Ssml/segment';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "SsmlRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<SsmlElement>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<SsmlElement>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param request 
     * @param tag 
     * @param {*} [options] Override http request options.
     */
    public segmentAndBuild (request?: SsmlRequest, tag?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/api/Ssml/segmentAndBuild';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (tag !== undefined) {
            localVarQueryParameters['tag'] = ObjectSerializer.serialize(tag, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "SsmlRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param request 
     * @param tags 
     * @param {*} [options] Override http request options.
     */
    public segmentAndBuild_1 (request?: SsmlRequest, tags?: Array<string>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/api/Ssml/segmentAndBuildMulti';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (tags !== undefined) {
            localVarQueryParameters['tags'] = ObjectSerializer.serialize(tags, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "SsmlRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param assistant 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public ssmlToSpeech (assistant: string, request?: SsmlRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<SpeechOutput>;  }> {
        const localVarPath = this.basePath + '/api/Ssml/toSpeech/{assistant}'
            .replace('{' + 'assistant' + '}', encodeURIComponent(String(assistant)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'assistant' is not null or undefined
        if (assistant === null || assistant === undefined) {
            throw new Error('Required parameter assistant was null or undefined when calling ssmlToSpeech.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "SsmlRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<SpeechOutput>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<SpeechOutput>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public validateAlexaSsml (request?: SsmlRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/Ssml/validate/alexa';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "SsmlRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public validateGoogleSsml (request?: SsmlRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/Ssml/validate/google';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "SsmlRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public validateSsml (request?: SsmlRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/Ssml/validate';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "SsmlRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SubscriptionApiApiKeys {
    Bearer,
}

export class SubscriptionApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SubscriptionApiApiKeys, value: string) {
        (this.authentications as any)[SubscriptionApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getBuiltInTypes (options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<SubscriptionTypeModel>;  }> {
        const localVarPath = this.basePath + '/api/Subscription/types';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<SubscriptionTypeModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<SubscriptionTypeModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param organizationId 
     * @param {*} [options] Override http request options.
     */
    public getSubscriptionsForOrganization (organizationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<SubscriptionModel>;  }> {
        const localVarPath = this.basePath + '/api/Subscription/forOrganization/{organizationId}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getSubscriptionsForOrganization.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<SubscriptionModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<SubscriptionModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TemplateConfigurationApiApiKeys {
    Bearer,
}

export class TemplateConfigurationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TemplateConfigurationApiApiKeys, value: string) {
        (this.authentications as any)[TemplateConfigurationApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createTemplateConfigurationFromModel (model?: TemplateConfigurationModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TemplateConfigurationModel;  }> {
        const localVarPath = this.basePath + '/api/TemplateConfiguration';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "TemplateConfigurationModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TemplateConfigurationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateConfigurationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param templateConfigurationId 
     * @param {*} [options] Override http request options.
     */
    public deleteTemplateConfiguration (templateConfigurationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TemplateConfigurationModel;  }> {
        const localVarPath = this.basePath + '/api/TemplateConfiguration/{templateConfigurationId}'
            .replace('{' + 'templateConfigurationId' + '}', encodeURIComponent(String(templateConfigurationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'templateConfigurationId' is not null or undefined
        if (templateConfigurationId === null || templateConfigurationId === undefined) {
            throw new Error('Required parameter templateConfigurationId was null or undefined when calling deleteTemplateConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TemplateConfigurationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateConfigurationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param templateConfigurationId 
     * @param {*} [options] Override http request options.
     */
    public disableTemplateConfiguration (templateConfigurationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TemplateConfigurationModel;  }> {
        const localVarPath = this.basePath + '/api/TemplateConfiguration/{templateConfigurationId}/disable'
            .replace('{' + 'templateConfigurationId' + '}', encodeURIComponent(String(templateConfigurationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'templateConfigurationId' is not null or undefined
        if (templateConfigurationId === null || templateConfigurationId === undefined) {
            throw new Error('Required parameter templateConfigurationId was null or undefined when calling disableTemplateConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TemplateConfigurationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateConfigurationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param templateConfigurationId 
     * @param {*} [options] Override http request options.
     */
    public enableTemplateConfiguration (templateConfigurationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TemplateConfigurationModel;  }> {
        const localVarPath = this.basePath + '/api/TemplateConfiguration/{templateConfigurationId}/enable'
            .replace('{' + 'templateConfigurationId' + '}', encodeURIComponent(String(templateConfigurationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'templateConfigurationId' is not null or undefined
        if (templateConfigurationId === null || templateConfigurationId === undefined) {
            throw new Error('Required parameter templateConfigurationId was null or undefined when calling enableTemplateConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TemplateConfigurationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateConfigurationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the available template configs
     * @param organizationId 
     * @param {*} [options] Override http request options.
     */
    public getAvailableTemplateConfigurations (organizationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<TemplateConfigurationModel>;  }> {
        const localVarPath = this.basePath + '/api/TemplateConfiguration/{organizationId}/available'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getAvailableTemplateConfigurations.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<TemplateConfigurationModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TemplateConfigurationModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param organizationId 
     * @param {*} [options] Override http request options.
     */
    public getOrganizationTemplateConfigurations (organizationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<TemplateConfigurationModel>;  }> {
        const localVarPath = this.basePath + '/api/TemplateConfiguration/{organizationId}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getOrganizationTemplateConfigurations.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<TemplateConfigurationModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TemplateConfigurationModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param templateConfigurationId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateTemplateConfiguration (templateConfigurationId: string, model?: TemplateConfigurationModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: TemplateConfigurationModel;  }> {
        const localVarPath = this.basePath + '/api/TemplateConfiguration/{templateConfigurationId}'
            .replace('{' + 'templateConfigurationId' + '}', encodeURIComponent(String(templateConfigurationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'templateConfigurationId' is not null or undefined
        if (templateConfigurationId === null || templateConfigurationId === undefined) {
            throw new Error('Required parameter templateConfigurationId was null or undefined when calling updateTemplateConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "TemplateConfigurationModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TemplateConfigurationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TemplateConfigurationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TermApiApiKeys {
    Bearer,
}

export class TermApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TermApiApiKeys, value: string) {
        (this.authentications as any)[TermApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public addTermAgreement (model?: NewUserTermRequestModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: UserTermModel;  }> {
        const localVarPath = this.basePath + '/api/Term/agreement';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewUserTermRequestModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UserTermModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserTermModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getLatestTerm (options: any = {}) : Promise<{ response: http.IncomingMessage; body: TermModel;  }> {
        const localVarPath = this.basePath + '/api/Term/latest';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: TermModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "TermModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UserApiApiKeys {
    Bearer,
}

export class UserApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UserApiApiKeys, value: string) {
        (this.authentications as any)[UserApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Changes the current user's password
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public changePassword (model?: ChangePasswordRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/User/ChangePassword';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "ChangePasswordRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Create an api-only user, mainly for integration use
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createApiUser (model?: NewApiUserRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ApiUserModel;  }> {
        const localVarPath = this.basePath + '/api/User/ApiUser';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewApiUserRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ApiUserModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ApiUserModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates the user.
     * @param model Model.
     * @param {*} [options] Override http request options.
     */
    public createUser (model?: NewUserRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: UserModel;  }> {
        const localVarPath = this.basePath + '/api/User';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewUserRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UserModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the current user's info
     * @param {*} [options] Override http request options.
     */
    public getCurrentUserData (options: any = {}) : Promise<{ response: http.IncomingMessage; body: UserModel;  }> {
        const localVarPath = this.basePath + '/api/User/me';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UserModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the current user's terms agreement info
     * @param {*} [options] Override http request options.
     */
    public getCurrentUserTermsAgreement (options: any = {}) : Promise<{ response: http.IncomingMessage; body: UserTermAgreementModel;  }> {
        const localVarPath = this.basePath + '/api/User/terms';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UserTermAgreementModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserTermAgreementModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Checks if sso is available for this user's email.
     * @param email 
     * @param {*} [options] Override http request options.
     */
    public getSingleSignOnAvailability (email: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/User/useSso/{email}'
            .replace('{' + 'email' + '}', encodeURIComponent(String(email)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'email' is not null or undefined
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling getSingleSignOnAvailability.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getSystemUserRoles (options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<UserRoleModel>;  }> {
        const localVarPath = this.basePath + '/api/User/SystemRoles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<UserRoleModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<UserRoleModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Requests to reset the user's password
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public requestPasswordReset (model?: ResetRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: PasswordResetModel;  }> {
        const localVarPath = this.basePath + '/api/User/ResetPassword';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "ResetRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: PasswordResetModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "PasswordResetModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sets the user's password based on the reset request
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public setPassword (model?: CreateNewPasswordRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/User/SetPassword';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "CreateNewPasswordRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateDetails (model?: UpdateUserRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/api/User/UpdateDetails';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateUserRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param file 
     * @param {*} [options] Override http request options.
     */
    public updateProfileImage (file?: Buffer, options: any = {}) : Promise<{ response: http.IncomingMessage; body: UserModel;  }> {
        const localVarPath = this.basePath + '/api/User/UpdateImage';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        if (file !== undefined) {
            localVarFormParams['file'] = file;
        }
        localVarUseFormData = true;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UserModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VoicifyNotificationApiApiKeys {
    Bearer,
}

export class VoicifyNotificationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VoicifyNotificationApiApiKeys, value: string) {
        (this.authentications as any)[VoicifyNotificationApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getUnreadNotifications (options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<UserVoicifyNotificationModel>;  }> {
        const localVarPath = this.basePath + '/api/VoicifyNotification/unread';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<UserVoicifyNotificationModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<UserVoicifyNotificationModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getUserNotifications (options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<UserVoicifyNotificationModel>;  }> {
        const localVarPath = this.basePath + '/api/VoicifyNotification/all';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<UserVoicifyNotificationModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<UserVoicifyNotificationModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public markAllAsRead (options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<UserVoicifyNotificationModel>;  }> {
        const localVarPath = this.basePath + '/api/VoicifyNotification/read';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<UserVoicifyNotificationModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<UserVoicifyNotificationModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param notificationId 
     * @param {*} [options] Override http request options.
     */
    public markAsRead (notificationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: UserVoicifyNotificationModel;  }> {
        const localVarPath = this.basePath + '/api/VoicifyNotification/{notificationId}/read'
            .replace('{' + 'notificationId' + '}', encodeURIComponent(String(notificationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'notificationId' is not null or undefined
        if (notificationId === null || notificationId === undefined) {
            throw new Error('Required parameter notificationId was null or undefined when calling markAsRead.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: UserVoicifyNotificationModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "UserVoicifyNotificationModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebhookApiApiKeys {
    Bearer,
}

export class WebhookApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WebhookApiApiKeys, value: string) {
        (this.authentications as any)[WebhookApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param webhookId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public addWebhookParameter (webhookId: string, model?: NewWebhookParameterRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/Webhook/{webhookId}/parameter'
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling addWebhookParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewWebhookParameterRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param organizationId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createWebhook (organizationId: string, model?: NewWebhookRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WebhookModel;  }> {
        const localVarPath = this.basePath + '/api/Webhook/{organizationId}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling createWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewWebhookRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param organizationId 
     * @param {*} [options] Override http request options.
     */
    public getOrganizationWebhooks (organizationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<WebhookModel>;  }> {
        const localVarPath = this.basePath + '/api/Webhook/fromOrganization/{organizationId}'
            .replace('{' + 'organizationId' + '}', encodeURIComponent(String(organizationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'organizationId' is not null or undefined
        if (organizationId === null || organizationId === undefined) {
            throw new Error('Required parameter organizationId was null or undefined when calling getOrganizationWebhooks.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<WebhookModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<WebhookModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getWebhookTypes (options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<WebhookTypeModel>;  }> {
        const localVarPath = this.basePath + '/api/Webhook/types';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<WebhookTypeModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<WebhookTypeModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param webhookId 
     * @param {*} [options] Override http request options.
     */
    public removeWebhook (webhookId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/Webhook/{webhookId}'
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling removeWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param webhookId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateWebhook (webhookId: string, model?: UpdateWebhookRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WebhookModel;  }> {
        const localVarPath = this.basePath + '/api/Webhook/{webhookId}'
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling updateWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateWebhookRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WelcomeMessageApiApiKeys {
    Bearer,
}

export class WelcomeMessageApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'Bearer': new ApiKeyAuth('header', 'Authorization'),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: WelcomeMessageApiApiKeys, value: string) {
        (this.authentications as any)[WelcomeMessageApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds an audio file to the welcome message
     * @param welcomeMessageId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addAudioFileImage (welcomeMessageId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/{welcomeMessageId}/addAudioFile/{mediaItemId}'
            .replace('{' + 'welcomeMessageId' + '}', encodeURIComponent(String(welcomeMessageId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'welcomeMessageId' is not null or undefined
        if (welcomeMessageId === null || welcomeMessageId === undefined) {
            throw new Error('Required parameter welcomeMessageId was null or undefined when calling addAudioFileImage.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addAudioFileImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WelcomeMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a large image to the welcome message
     * @param welcomeMessageId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addLargeImage (welcomeMessageId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/{welcomeMessageId}/addLargeImage/{mediaItemId}'
            .replace('{' + 'welcomeMessageId' + '}', encodeURIComponent(String(welcomeMessageId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'welcomeMessageId' is not null or undefined
        if (welcomeMessageId === null || welcomeMessageId === undefined) {
            throw new Error('Required parameter welcomeMessageId was null or undefined when calling addLargeImage.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addLargeImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WelcomeMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a small image to the welcome message
     * @param welcomeMessageId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addSmallImage (welcomeMessageId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/{welcomeMessageId}/addSmallImage/{mediaItemId}'
            .replace('{' + 'welcomeMessageId' + '}', encodeURIComponent(String(welcomeMessageId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'welcomeMessageId' is not null or undefined
        if (welcomeMessageId === null || welcomeMessageId === undefined) {
            throw new Error('Required parameter welcomeMessageId was null or undefined when calling addSmallImage.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addSmallImage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WelcomeMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a video file to the welcome message
     * @param welcomeMessageId 
     * @param mediaItemId 
     * @param {*} [options] Override http request options.
     */
    public addVideoFile (welcomeMessageId: string, mediaItemId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/{welcomeMessageId}/addVideoFile/{mediaItemId}'
            .replace('{' + 'welcomeMessageId' + '}', encodeURIComponent(String(welcomeMessageId)))
            .replace('{' + 'mediaItemId' + '}', encodeURIComponent(String(mediaItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'welcomeMessageId' is not null or undefined
        if (welcomeMessageId === null || welcomeMessageId === undefined) {
            throw new Error('Required parameter welcomeMessageId was null or undefined when calling addVideoFile.');
        }

        // verify required parameter 'mediaItemId' is not null or undefined
        if (mediaItemId === null || mediaItemId === undefined) {
            throw new Error('Required parameter mediaItemId was null or undefined when calling addVideoFile.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WelcomeMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param welcomeMessageId 
     * @param webhookId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public addWebhook (welcomeMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WelcomeMessageWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/{welcomeMessageId}/webhooks/{webhookId}'
            .replace('{' + 'welcomeMessageId' + '}', encodeURIComponent(String(welcomeMessageId)))
            .replace('{' + 'webhookId' + '}', encodeURIComponent(String(webhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'welcomeMessageId' is not null or undefined
        if (welcomeMessageId === null || welcomeMessageId === undefined) {
            throw new Error('Required parameter welcomeMessageId was null or undefined when calling addWebhook.');
        }

        // verify required parameter 'webhookId' is not null or undefined
        if (webhookId === null || webhookId === undefined) {
            throw new Error('Required parameter webhookId was null or undefined when calling addWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WelcomeMessageWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WelcomeMessageWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a new welcome message to the given application
     * @param applicationId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public addWelcomeMessage (applicationId: string, model?: NewWelcomeMessageRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling addWelcomeMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewWelcomeMessageRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WelcomeMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a new welcome message to the given application
     * @param applicationId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public addWelcomeMessageStub (applicationId: string, model?: NewWelcomeMessageStubRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/{applicationId}/stub'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling addWelcomeMessageStub.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "NewWelcomeMessageStubRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WelcomeMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param welcomeMessageId 
     * @param {*} [options] Override http request options.
     */
    public copyContentItem (welcomeMessageId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/{welcomeMessageId}/copy'
            .replace('{' + 'welcomeMessageId' + '}', encodeURIComponent(String(welcomeMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'welcomeMessageId' is not null or undefined
        if (welcomeMessageId === null || welcomeMessageId === undefined) {
            throw new Error('Required parameter welcomeMessageId was null or undefined when calling copyContentItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WelcomeMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public createFullContentItem (model?: WelcomeMessageModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/full';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "WelcomeMessageModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WelcomeMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public createUserDefinedParameter (instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/webhook/{instanceWebhookId}/userParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling createUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UserDefinedWebhookParameterCreateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes the given message
     * @param welcomeMessageId 
     * @param {*} [options] Override http request options.
     */
    public deleteWelcomeMessage (welcomeMessageId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/{welcomeMessageId}'
            .replace('{' + 'welcomeMessageId' + '}', encodeURIComponent(String(welcomeMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'welcomeMessageId' is not null or undefined
        if (welcomeMessageId === null || welcomeMessageId === undefined) {
            throw new Error('Required parameter welcomeMessageId was null or undefined when calling deleteWelcomeMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WelcomeMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Finds the full content item by id
     * @param id 
     * @param {*} [options] Override http request options.
     */
    public findFullById (id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/full/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findFullById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WelcomeMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the content for the given application feature
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public getByApplicationFeature (applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<WelcomeMessageModel>;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/byFeature/{applicationFeatureId}'
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling getByApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<WelcomeMessageModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<WelcomeMessageModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param welcomeMessageId 
     * @param {*} [options] Override http request options.
     */
    public getWebhooks (welcomeMessageId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<WelcomeMessageWebhookModel>;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/{welcomeMessageId}/webhooks'
            .replace('{' + 'welcomeMessageId' + '}', encodeURIComponent(String(welcomeMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'welcomeMessageId' is not null or undefined
        if (welcomeMessageId === null || welcomeMessageId === undefined) {
            throw new Error('Required parameter welcomeMessageId was null or undefined when calling getWebhooks.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<WelcomeMessageWebhookModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<WelcomeMessageWebhookModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the welcome messages for the given application
     * @param applicationId 
     * @param {*} [options] Override http request options.
     */
    public getWelcomeMessagesForApplication (applicationId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<WelcomeMessageModel>;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/{applicationId}'
            .replace('{' + 'applicationId' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling getWelcomeMessagesForApplication.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<WelcomeMessageModel>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<WelcomeMessageModel>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param contentItemId 
     * @param applicationFeatureId 
     * @param {*} [options] Override http request options.
     */
    public moveContentItemToApplicationFeature (contentItemId: string, applicationFeatureId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/{contentItemId}/MoveToFeature/{applicationFeatureId}'
            .replace('{' + 'contentItemId' + '}', encodeURIComponent(String(contentItemId)))
            .replace('{' + 'applicationFeatureId' + '}', encodeURIComponent(String(applicationFeatureId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentItemId' is not null or undefined
        if (contentItemId === null || contentItemId === undefined) {
            throw new Error('Required parameter contentItemId was null or undefined when calling moveContentItemToApplicationFeature.');
        }

        // verify required parameter 'applicationFeatureId' is not null or undefined
        if (applicationFeatureId === null || applicationFeatureId === undefined) {
            throw new Error('Required parameter applicationFeatureId was null or undefined when calling moveContentItemToApplicationFeature.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WelcomeMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param parameterName 
     * @param {*} [options] Override http request options.
     */
    public removeUserDefinedParameter (instanceWebhookId: string, parameterName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/webhook/{instanceWebhookId}/userParameters/{parameterName}'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)))
            .replace('{' + 'parameterName' + '}', encodeURIComponent(String(parameterName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling removeUserDefinedParameter.');
        }

        // verify required parameter 'parameterName' is not null or undefined
        if (parameterName === null || parameterName === undefined) {
            throw new Error('Required parameter parameterName was null or undefined when calling removeUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param welcomeMessageWebhookId 
     * @param {*} [options] Override http request options.
     */
    public removeWebhook (welcomeMessageWebhookId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WelcomeMessageWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/webhook/{welcomeMessageWebhookId}'
            .replace('{' + 'welcomeMessageWebhookId' + '}', encodeURIComponent(String(welcomeMessageWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'welcomeMessageWebhookId' is not null or undefined
        if (welcomeMessageWebhookId === null || welcomeMessageWebhookId === undefined) {
            throw new Error('Required parameter welcomeMessageWebhookId was null or undefined when calling removeWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WelcomeMessageWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WelcomeMessageWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Toggles whether the given welcome Message is live or not
     * @param welcomeMessageId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public toggleIsLive (welcomeMessageId: string, model?: ToggleLiveRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/{welcomeMessageId}/isLive'
            .replace('{' + 'welcomeMessageId' + '}', encodeURIComponent(String(welcomeMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'welcomeMessageId' is not null or undefined
        if (welcomeMessageId === null || welcomeMessageId === undefined) {
            throw new Error('Required parameter welcomeMessageId was null or undefined when calling toggleIsLive.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "ToggleLiveRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WelcomeMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param welcomeMessageId 
     * @param webhookInstanceId 
     * @param parameters 
     * @param {*} [options] Override http request options.
     */
    public updateAttachedWebhook (welcomeMessageId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WelcomeMessageWebhookModel;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/{welcomeMessageId}/webhooks/{webhookInstanceId}'
            .replace('{' + 'welcomeMessageId' + '}', encodeURIComponent(String(welcomeMessageId)))
            .replace('{' + 'webhookInstanceId' + '}', encodeURIComponent(String(webhookInstanceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'welcomeMessageId' is not null or undefined
        if (welcomeMessageId === null || welcomeMessageId === undefined) {
            throw new Error('Required parameter welcomeMessageId was null or undefined when calling updateAttachedWebhook.');
        }

        // verify required parameter 'webhookInstanceId' is not null or undefined
        if (webhookInstanceId === null || webhookInstanceId === undefined) {
            throw new Error('Required parameter webhookInstanceId was null or undefined when calling updateAttachedWebhook.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(parameters, "WebhookParametersRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WelcomeMessageWebhookModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WelcomeMessageWebhookModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param contentItemId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateFullContentItem (contentItemId: string, model?: WelcomeMessageModel, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/{contentItemId}/full'
            .replace('{' + 'contentItemId' + '}', encodeURIComponent(String(contentItemId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'contentItemId' is not null or undefined
        if (contentItemId === null || contentItemId === undefined) {
            throw new Error('Required parameter contentItemId was null or undefined when calling updateFullContentItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "WelcomeMessageModel")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WelcomeMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateUserDefinedParameter (instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/webhook/{instanceWebhookId}/userParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateUserDefinedParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "UserDefinedWebhookParameterUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param instanceWebhookId 
     * @param request 
     * @param {*} [options] Override http request options.
     */
    public updateWebhookParameter (instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/webhook/{instanceWebhookId}/webhookParameters'
            .replace('{' + 'instanceWebhookId' + '}', encodeURIComponent(String(instanceWebhookId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'instanceWebhookId' is not null or undefined
        if (instanceWebhookId === null || instanceWebhookId === undefined) {
            throw new Error('Required parameter instanceWebhookId was null or undefined when calling updateWebhookParameter.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(request, "WebhookParameterUpdateRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the content of the given welcome message id
     * @param welcomeMessageId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateWelcomeMessage (welcomeMessageId: string, model?: UpdateWelcomeMessageRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/{welcomeMessageId}/update'
            .replace('{' + 'welcomeMessageId' + '}', encodeURIComponent(String(welcomeMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'welcomeMessageId' is not null or undefined
        if (welcomeMessageId === null || welcomeMessageId === undefined) {
            throw new Error('Required parameter welcomeMessageId was null or undefined when calling updateWelcomeMessage.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateWelcomeMessageRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WelcomeMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the content of the given welcome message id
     * @param welcomeMessageId 
     * @param model 
     * @param {*} [options] Override http request options.
     */
    public updateWelcomeMessageStub (welcomeMessageId: string, model?: UpdateWelcomeMessageStubRequest, options: any = {}) : Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }> {
        const localVarPath = this.basePath + '/api/WelcomeMessage/{welcomeMessageId}/update/stub'
            .replace('{' + 'welcomeMessageId' + '}', encodeURIComponent(String(welcomeMessageId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'welcomeMessageId' is not null or undefined
        if (welcomeMessageId === null || welcomeMessageId === undefined) {
            throw new Error('Required parameter welcomeMessageId was null or undefined when calling updateWelcomeMessageStub.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(model, "UpdateWelcomeMessageStubRequest")
        };

        this.authentications.Bearer.applyToRequest(localVarRequestOptions);

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WelcomeMessageModel;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "WelcomeMessageModel");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
