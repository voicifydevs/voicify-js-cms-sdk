/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Voicify CMS API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: V1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://cms.voicify.com".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface AddFeatureToModuleRequest
 */
export interface AddFeatureToModuleRequest {
    /**
     * 
     * @type {string}
     * @memberof AddFeatureToModuleRequest
     */
    featureId?: string;
    /**
     * 
     * @type {string}
     * @memberof AddFeatureToModuleRequest
     */
    name: string;
}

/**
 * 
 * @export
 * @interface AddModuleToApplicationRequest
 */
export interface AddModuleToApplicationRequest {
    /**
     * 
     * @type {string}
     * @memberof AddModuleToApplicationRequest
     */
    moduleId: string;
}

/**
 * 
 * @export
 * @interface AlexaVendor
 */
export interface AlexaVendor {
    /**
     * 
     * @type {string}
     * @memberof AlexaVendor
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof AlexaVendor
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface AlexaVendorResponse
 */
export interface AlexaVendorResponse {
    /**
     * 
     * @type {Array<AlexaVendor>}
     * @memberof AlexaVendorResponse
     */
    vendors?: Array<AlexaVendor>;
}

/**
 * 
 * @export
 * @interface AnswerModel
 */
export interface AnswerModel {
    /**
     * 
     * @type {string}
     * @memberof AnswerModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof AnswerModel
     */
    content?: string;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof AnswerModel
     */
    smallImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof AnswerModel
     */
    largeImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof AnswerModel
     */
    backgroundImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof AnswerModel
     */
    audio?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof AnswerModel
     */
    video?: MediaItemModel;
    /**
     * 
     * @type {MediaResponseContainerModel}
     * @memberof AnswerModel
     */
    mediaResponseContainer?: MediaResponseContainerModel;
    /**
     * 
     * @type {RepromptModel}
     * @memberof AnswerModel
     */
    reprompt?: RepromptModel;
    /**
     * 
     * @type {FollowUpModel}
     * @memberof AnswerModel
     */
    followUp?: FollowUpModel;
    /**
     * 
     * @type {string}
     * @memberof AnswerModel
     */
    repromptId?: string;
    /**
     * 
     * @type {Date}
     * @memberof AnswerModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof AnswerModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof AnswerModel
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof AnswerModel
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof AnswerModel
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof AnswerModel
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof AnswerModel
     */
    questionAnswerId?: string;
}

/**
 * 
 * @export
 * @interface ApiUserModel
 */
export interface ApiUserModel {
    /**
     * 
     * @type {string}
     * @memberof ApiUserModel
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserModel
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiUserModel
     */
    userId?: string;
}

/**
 * 
 * @export
 * @interface ApplicationConversationCountModel
 */
export interface ApplicationConversationCountModel {
    /**
     * 
     * @type {string}
     * @memberof ApplicationConversationCountModel
     */
    applicationId?: string;
    /**
     * 
     * @type {number}
     * @memberof ApplicationConversationCountModel
     */
    conversationCount?: number;
}

/**
 * 
 * @export
 * @interface ApplicationFeatureExportModel
 */
export interface ApplicationFeatureExportModel {
    /**
     * 
     * @type {Array<WelcomeMessageExportModel>}
     * @memberof ApplicationFeatureExportModel
     */
    welcomeMessages?: Array<WelcomeMessageExportModel>;
    /**
     * 
     * @type {Array<ExitMessageExportModel>}
     * @memberof ApplicationFeatureExportModel
     */
    exitMessages?: Array<ExitMessageExportModel>;
    /**
     * 
     * @type {Array<FallbackMessageExportModel>}
     * @memberof ApplicationFeatureExportModel
     */
    fallbackMessages?: Array<FallbackMessageExportModel>;
    /**
     * 
     * @type {Array<HelpMessageExportModel>}
     * @memberof ApplicationFeatureExportModel
     */
    helpMessages?: Array<HelpMessageExportModel>;
    /**
     * 
     * @type {Array<QuestionAnswerExportModel>}
     * @memberof ApplicationFeatureExportModel
     */
    questionAnswers?: Array<QuestionAnswerExportModel>;
    /**
     * 
     * @type {Array<EventItemExportModel>}
     * @memberof ApplicationFeatureExportModel
     */
    eventItems?: Array<EventItemExportModel>;
    /**
     * 
     * @type {Array<LatestMessageExportModel>}
     * @memberof ApplicationFeatureExportModel
     */
    latestMessages?: Array<LatestMessageExportModel>;
    /**
     * 
     * @type {Array<SimpleChoiceExportModel>}
     * @memberof ApplicationFeatureExportModel
     */
    simpleChoices?: Array<SimpleChoiceExportModel>;
    /**
     * 
     * @type {Array<RecipeExportModel>}
     * @memberof ApplicationFeatureExportModel
     */
    recipes?: Array<RecipeExportModel>;
    /**
     * 
     * @type {Array<NumberRangeExportModel>}
     * @memberof ApplicationFeatureExportModel
     */
    numberRanges?: Array<NumberRangeExportModel>;
    /**
     * 
     * @type {Array<CustomRequestExportModel>}
     * @memberof ApplicationFeatureExportModel
     */
    customRequests?: Array<CustomRequestExportModel>;
    /**
     * 
     * @type {Array<ApplicationFeatureExportModel>}
     * @memberof ApplicationFeatureExportModel
     */
    children?: Array<ApplicationFeatureExportModel>;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFeatureExportModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFeatureExportModel
     */
    applicationModuleId?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFeatureExportModel
     */
    applicationId?: string;
    /**
     * 
     * @type {FeatureModel}
     * @memberof ApplicationFeatureExportModel
     */
    feature?: FeatureModel;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFeatureExportModel
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ApplicationFeatureExportModel
     */
    priority?: number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFeatureExportModel
     */
    parentId?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFeatureExportModel
     */
    createdFromId?: string;
    /**
     * 
     * @type {Array<ApplicationFeatureWebhookModel>}
     * @memberof ApplicationFeatureExportModel
     */
    applicationFeatureWebhooks?: Array<ApplicationFeatureWebhookModel>;
}

/**
 * 
 * @export
 * @interface ApplicationFeatureModel
 */
export interface ApplicationFeatureModel {
    /**
     * 
     * @type {string}
     * @memberof ApplicationFeatureModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFeatureModel
     */
    applicationModuleId?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFeatureModel
     */
    applicationId?: string;
    /**
     * 
     * @type {FeatureModel}
     * @memberof ApplicationFeatureModel
     */
    feature?: FeatureModel;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFeatureModel
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ApplicationFeatureModel
     */
    priority?: number;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFeatureModel
     */
    parentId?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFeatureModel
     */
    createdFromId?: string;
    /**
     * 
     * @type {Array<ApplicationFeatureWebhookModel>}
     * @memberof ApplicationFeatureModel
     */
    applicationFeatureWebhooks?: Array<ApplicationFeatureWebhookModel>;
}

/**
 * 
 * @export
 * @interface ApplicationFeatureRequestItem
 */
export interface ApplicationFeatureRequestItem {
    /**
     * 
     * @type {string}
     * @memberof ApplicationFeatureRequestItem
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface ApplicationFeatureWebhookModel
 */
export interface ApplicationFeatureWebhookModel {
    /**
     * 
     * @type {string}
     * @memberof ApplicationFeatureWebhookModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFeatureWebhookModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {WebhookModel}
     * @memberof ApplicationFeatureWebhookModel
     */
    webhook?: WebhookModel;
    /**
     * 
     * @type {Array<WebhookParameterValueModel>}
     * @memberof ApplicationFeatureWebhookModel
     */
    parameterValues?: Array<WebhookParameterValueModel>;
}

/**
 * 
 * @export
 * @interface ApplicationFulfillmentEndpoints
 */
export interface ApplicationFulfillmentEndpoints {
    /**
     * 
     * @type {string}
     * @memberof ApplicationFulfillmentEndpoints
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFulfillmentEndpoints
     */
    alexaEndpoint?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFulfillmentEndpoints
     */
    alexaProxyEndpoint?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFulfillmentEndpoints
     */
    dialogFlowEndpoint?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFulfillmentEndpoints
     */
    botServiceEndpoint?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFulfillmentEndpoints
     */
    bixbyEndpoint?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationFulfillmentEndpoints
     */
    customAssistantEndpoint?: string;
}

/**
 * 
 * @export
 * @interface ApplicationInformationModel
 */
export interface ApplicationInformationModel {
    /**
     * 
     * @type {string}
     * @memberof ApplicationInformationModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationInformationModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationInformationModel
     */
    languageId?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationInformationModel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationInformationModel
     */
    shortDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationInformationModel
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationInformationModel
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationInformationModel
     */
    invocationPhrase?: string;
}

/**
 * 
 * @export
 * @interface ApplicationMemberModel
 */
export interface ApplicationMemberModel {
    /**
     * 
     * @type {string}
     * @memberof ApplicationMemberModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationMemberModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationMemberModel
     */
    organizationMemberId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationMemberModel
     */
    isAdmin?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationMemberModel
     */
    canEdit?: boolean;
    /**
     * 
     * @type {OrganizationMemberModel}
     * @memberof ApplicationMemberModel
     */
    organizationMember?: OrganizationMemberModel;
}

/**
 * 
 * @export
 * @interface ApplicationMemberRoleModel
 */
export interface ApplicationMemberRoleModel {
    /**
     * 
     * @type {string}
     * @memberof ApplicationMemberRoleModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationMemberRoleModel
     */
    roleId?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationMemberRoleModel
     */
    userId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationMemberRoleModel
     */
    isAdmin?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationMemberRoleModel
     */
    canEdit?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApplicationMemberRoleModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationMemberRoleModel
     */
    applicationName?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationMemberRoleModel
     */
    applicationImageUrl?: string;
}

/**
 * 
 * @export
 * @interface ApplicationModel
 */
export interface ApplicationModel {
    /**
     * 
     * @type {string}
     * @memberof ApplicationModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationModel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationModel
     */
    secret?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationModel
     */
    shortDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationModel
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationModel
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationModel
     */
    invocationPhrase?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationModel
     */
    imageUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationModel
     */
    shortCode?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationModel
     */
    imageItemId?: string;
    /**
     * 
     * @type {Array<ApplicationInformationModel>}
     * @memberof ApplicationModel
     */
    applicationInformationItems?: Array<ApplicationInformationModel>;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof ApplicationModel
     */
    languages?: Array<LanguageModel>;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationModel
     */
    isDisabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApplicationModel
     */
    alexaFallbackSensitivity?: ApplicationModel.AlexaFallbackSensitivityEnum;
}

/**
 * @export
 * @namespace ApplicationModel
 */
export namespace ApplicationModel {
    /**
     * @export
     * @enum {string}
     */
    export enum AlexaFallbackSensitivityEnum {
        LOW = <any> 'LOW',
        MEDIUM = <any> 'MEDIUM',
        HIGH = <any> 'HIGH'
    }
}

/**
 * 
 * @export
 * @interface ApplicationWebhookModel
 */
export interface ApplicationWebhookModel {
    /**
     * 
     * @type {string}
     * @memberof ApplicationWebhookModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationWebhookModel
     */
    applicationId?: string;
    /**
     * 
     * @type {WebhookModel}
     * @memberof ApplicationWebhookModel
     */
    webhook?: WebhookModel;
    /**
     * 
     * @type {Array<WebhookParameterValueModel>}
     * @memberof ApplicationWebhookModel
     */
    parameterValues?: Array<WebhookParameterValueModel>;
}

/**
 * 
 * @export
 * @interface ApplicationWithFeaturesModel
 */
export interface ApplicationWithFeaturesModel {
    /**
     * 
     * @type {string}
     * @memberof ApplicationWithFeaturesModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationWithFeaturesModel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationWithFeaturesModel
     */
    secret?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationWithFeaturesModel
     */
    imageUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationWithFeaturesModel
     */
    invocationPhrase?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationWithFeaturesModel
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationWithFeaturesModel
     */
    shortDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationWithFeaturesModel
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationWithFeaturesModel
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationWithFeaturesModel
     */
    defaultLanguageId?: string;
    /**
     * 
     * @type {Array<ApplicationFeatureModel>}
     * @memberof ApplicationWithFeaturesModel
     */
    applicationFeatures?: Array<ApplicationFeatureModel>;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof ApplicationWithFeaturesModel
     */
    languages?: Array<LanguageModel>;
    /**
     * 
     * @type {Array<ApplicationInformationModel>}
     * @memberof ApplicationWithFeaturesModel
     */
    applicationInformationItems?: Array<ApplicationInformationModel>;
}

/**
 * 
 * @export
 * @interface ApplicationsByAmazonAccount
 */
export interface ApplicationsByAmazonAccount {
    /**
     * 
     * @type {string}
     * @memberof ApplicationsByAmazonAccount
     */
    platform?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApplicationsByAmazonAccount
     */
    applicationIds?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ApplicationsByAmazonAccount
     */
    userName?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationsByAmazonAccount
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface ApplicationsByGoogleAccount
 */
export interface ApplicationsByGoogleAccount {
    /**
     * 
     * @type {string}
     * @memberof ApplicationsByGoogleAccount
     */
    platform?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApplicationsByGoogleAccount
     */
    applicationIds?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ApplicationsByGoogleAccount
     */
    userName?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationsByGoogleAccount
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface ApplicationsByMicrosoftAccount
 */
export interface ApplicationsByMicrosoftAccount {
    /**
     * 
     * @type {string}
     * @memberof ApplicationsByMicrosoftAccount
     */
    platform?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApplicationsByMicrosoftAccount
     */
    applicationIds?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ApplicationsByMicrosoftAccount
     */
    userName?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationsByMicrosoftAccount
     */
    id?: string;
}

/**
 * 
 * @export
 * @interface AppliedApplicationTemplateFormModel
 */
export interface AppliedApplicationTemplateFormModel {
    /**
     * 
     * @type {string}
     * @memberof AppliedApplicationTemplateFormModel
     */
    id?: string;
    /**
     * 
     * @type {Date}
     * @memberof AppliedApplicationTemplateFormModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof AppliedApplicationTemplateFormModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof AppliedApplicationTemplateFormModel
     */
    createdByUserId?: string;
    /**
     * 
     * @type {string}
     * @memberof AppliedApplicationTemplateFormModel
     */
    modifiedByUserId?: string;
    /**
     * 
     * @type {string}
     * @memberof AppliedApplicationTemplateFormModel
     */
    templateFormId?: string;
    /**
     * 
     * @type {string}
     * @memberof AppliedApplicationTemplateFormModel
     */
    appliedApplicationId?: string;
    /**
     * 
     * @type {Date}
     * @memberof AppliedApplicationTemplateFormModel
     */
    lastSyncedDate?: Date;
    /**
     * 
     * @type {TemplateFormWithConfigurationModel}
     * @memberof AppliedApplicationTemplateFormModel
     */
    templateForm?: TemplateFormWithConfigurationModel;
    /**
     * 
     * @type {Array<TemplateFormFieldValueModel>}
     * @memberof AppliedApplicationTemplateFormModel
     */
    templateFormFieldValues?: Array<TemplateFormFieldValueModel>;
}

/**
 * 
 * @export
 * @interface AuthenticationResponse
 */
export interface AuthenticationResponse {
    /**
     * 
     * @type {UserModel}
     * @memberof AuthenticationResponse
     */
    user?: UserModel;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationResponse
     */
    accessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationResponse
     */
    refreshToken?: string;
    /**
     * 
     * @type {Date}
     * @memberof AuthenticationResponse
     */
    accessTokenExpirationDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof AuthenticationResponse
     */
    refreshTokenExpirationDate?: Date;
}

/**
 * 
 * @export
 * @interface AzureBotServiceInformation
 */
export interface AzureBotServiceInformation {
    /**
     * 
     * @type {string}
     * @memberof AzureBotServiceInformation
     */
    registrationUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof AzureBotServiceInformation
     */
    microsoftAppId?: string;
    /**
     * 
     * @type {string}
     * @memberof AzureBotServiceInformation
     */
    microsoftAppPassword?: string;
    /**
     * 
     * @type {string}
     * @memberof AzureBotServiceInformation
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof AzureBotServiceInformation
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface AzureSubscriptionInformation
 */
export interface AzureSubscriptionInformation {
    /**
     * 
     * @type {string}
     * @memberof AzureSubscriptionInformation
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof AzureSubscriptionInformation
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface BasicDeviceTargetModel
 */
export interface BasicDeviceTargetModel {
    /**
     * 
     * @type {string}
     * @memberof BasicDeviceTargetModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof BasicDeviceTargetModel
     */
    assistant?: string;
    /**
     * 
     * @type {string}
     * @memberof BasicDeviceTargetModel
     */
    displayName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BasicDeviceTargetModel
     */
    supportsForegroundImages?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BasicDeviceTargetModel
     */
    supportsRichAudio?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BasicDeviceTargetModel
     */
    supportsSsml?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BasicDeviceTargetModel
     */
    supportsVideo?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BasicDeviceTargetModel
     */
    supportsBackgroundImages?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BasicDeviceTargetModel
     */
    supportsDisplayTitle?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BasicDeviceTargetModel
     */
    supportsDisplayText?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BasicDeviceTargetModel
     */
    iconUrl?: string;
}

/**
 * 
 * @export
 * @interface BasicInvitationRequest
 */
export interface BasicInvitationRequest {
    /**
     * 
     * @type {string}
     * @memberof BasicInvitationRequest
     */
    email: string;
    /**
     * 
     * @type {boolean}
     * @memberof BasicInvitationRequest
     */
    isAdmin: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BasicInvitationRequest
     */
    isAddedToApplications?: boolean;
    /**
     * 
     * @type {string}
     * @memberof BasicInvitationRequest
     */
    applicationRoleId?: string;
}

/**
 * 
 * @export
 * @interface BulkContentRequest
 */
export interface BulkContentRequest {
    /**
     * 
     * @type {string}
     * @memberof BulkContentRequest
     */
    applicationId: string;
    /**
     * 
     * @type {Array<ContentRequestItem>}
     * @memberof BulkContentRequest
     */
    content?: Array<ContentRequestItem>;
    /**
     * 
     * @type {Array<ApplicationFeatureRequestItem>}
     * @memberof BulkContentRequest
     */
    applicationFeatures?: Array<ApplicationFeatureRequestItem>;
}

/**
 * 
 * @export
 * @interface BulkQuestionAnswerUpdateRequest
 */
export interface BulkQuestionAnswerUpdateRequest {
    /**
     * 
     * @type {Array<UpdateQuestionRequest>}
     * @memberof BulkQuestionAnswerUpdateRequest
     */
    questions: Array<UpdateQuestionRequest>;
    /**
     * 
     * @type {Array<UpdateAnswerRequest>}
     * @memberof BulkQuestionAnswerUpdateRequest
     */
    answers: Array<UpdateAnswerRequest>;
    /**
     * 
     * @type {string}
     * @memberof BulkQuestionAnswerUpdateRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof BulkQuestionAnswerUpdateRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkQuestionAnswerUpdateRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkQuestionAnswerUpdateRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkQuestionAnswerUpdateRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkQuestionAnswerUpdateRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkQuestionAnswerUpdateRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkQuestionAnswerUpdateRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkQuestionAnswerUpdateRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkQuestionAnswerUpdateRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BulkQuestionAnswerUpdateRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkQuestionAnswerUpdateRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface BulkQuestionAnswerUpdateStubRequest
 */
export interface BulkQuestionAnswerUpdateStubRequest {
    /**
     * 
     * @type {string}
     * @memberof BulkQuestionAnswerUpdateStubRequest
     */
    title: string;
    /**
     * 
     * @type {Array<UpdateQuestionRequest>}
     * @memberof BulkQuestionAnswerUpdateStubRequest
     */
    questions?: Array<UpdateQuestionRequest>;
    /**
     * 
     * @type {Array<UpdateAnswerRequest>}
     * @memberof BulkQuestionAnswerUpdateStubRequest
     */
    answers?: Array<UpdateAnswerRequest>;
    /**
     * 
     * @type {string}
     * @memberof BulkQuestionAnswerUpdateStubRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkQuestionAnswerUpdateStubRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkQuestionAnswerUpdateStubRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkQuestionAnswerUpdateStubRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkQuestionAnswerUpdateStubRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkQuestionAnswerUpdateStubRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkQuestionAnswerUpdateStubRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkQuestionAnswerUpdateStubRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkQuestionAnswerUpdateStubRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BulkQuestionAnswerUpdateStubRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkQuestionAnswerUpdateStubRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface BulkUpdateCustomRequestRequest
 */
export interface BulkUpdateCustomRequestRequest {
    /**
     * 
     * @type {Array<UpdateCustomRequestResponseRequest>}
     * @memberof BulkUpdateCustomRequestRequest
     */
    responses: Array<UpdateCustomRequestResponseRequest>;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestRequest
     */
    applicationId: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BulkUpdateCustomRequestRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkUpdateCustomRequestRequest
     */
    languageIds?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestRequest
     */
    requestTypes?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestRequest
     */
    requestNames?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestRequest
     */
    platformFilter?: string;
    /**
     * 
     * @type {Date}
     * @memberof BulkUpdateCustomRequestRequest
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof BulkUpdateCustomRequestRequest
     */
    endDate?: Date;
}

/**
 * 
 * @export
 * @interface BulkUpdateCustomRequestStubRequest
 */
export interface BulkUpdateCustomRequestStubRequest {
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestStubRequest
     */
    applicationId: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestStubRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestStubRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestStubRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestStubRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestStubRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestStubRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestStubRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestStubRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestStubRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestStubRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {Array<UpdateCustomRequestResponseRequest>}
     * @memberof BulkUpdateCustomRequestStubRequest
     */
    responses?: Array<UpdateCustomRequestResponseRequest>;
    /**
     * 
     * @type {boolean}
     * @memberof BulkUpdateCustomRequestStubRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkUpdateCustomRequestStubRequest
     */
    languageIds?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestStubRequest
     */
    requestTypes?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestStubRequest
     */
    requestNames?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateCustomRequestStubRequest
     */
    platformFilter?: string;
    /**
     * 
     * @type {Date}
     * @memberof BulkUpdateCustomRequestStubRequest
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof BulkUpdateCustomRequestStubRequest
     */
    endDate?: Date;
}

/**
 * 
 * @export
 * @interface BulkUpdateEventRequest
 */
export interface BulkUpdateEventRequest {
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventRequest
     */
    eventName: string;
    /**
     * 
     * @type {Date}
     * @memberof BulkUpdateEventRequest
     */
    startDate: Date;
    /**
     * 
     * @type {Array<UpdateEventResponseRequest>}
     * @memberof BulkUpdateEventRequest
     */
    responses: Array<UpdateEventResponseRequest>;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventRequest
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventRequest
     */
    locationName?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkUpdateEventRequest
     */
    categoryNames?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventRequest
     */
    ownerName?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventRequest
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventRequest
     */
    status?: string;
    /**
     * 
     * @type {Date}
     * @memberof BulkUpdateEventRequest
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BulkUpdateEventRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkUpdateEventRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface BulkUpdateEventStubRequest
 */
export interface BulkUpdateEventStubRequest {
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventStubRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventStubRequest
     */
    eventName?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventStubRequest
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventStubRequest
     */
    locationName?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkUpdateEventStubRequest
     */
    categoryNames?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventStubRequest
     */
    ownerName?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventStubRequest
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventStubRequest
     */
    status?: string;
    /**
     * 
     * @type {Date}
     * @memberof BulkUpdateEventStubRequest
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof BulkUpdateEventStubRequest
     */
    endDate?: Date;
    /**
     * 
     * @type {Array<UpdateEventResponseRequest>}
     * @memberof BulkUpdateEventStubRequest
     */
    responses?: Array<UpdateEventResponseRequest>;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventStubRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventStubRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventStubRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventStubRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventStubRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventStubRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventStubRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventStubRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateEventStubRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BulkUpdateEventStubRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkUpdateEventStubRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface BulkUpdateLatestMessageRequest
 */
export interface BulkUpdateLatestMessageRequest {
    /**
     * 
     * @type {Date}
     * @memberof BulkUpdateLatestMessageRequest
     */
    startDate: Date;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateLatestMessageRequest
     */
    category: string;
    /**
     * 
     * @type {Array<UpdateLatestMessageResponseRequest>}
     * @memberof BulkUpdateLatestMessageRequest
     */
    responses: Array<UpdateLatestMessageResponseRequest>;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateLatestMessageRequest
     */
    applicationId: string;
    /**
     * 
     * @type {Date}
     * @memberof BulkUpdateLatestMessageRequest
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateLatestMessageRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateLatestMessageRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateLatestMessageRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateLatestMessageRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateLatestMessageRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateLatestMessageRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateLatestMessageRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateLatestMessageRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateLatestMessageRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateLatestMessageRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BulkUpdateLatestMessageRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkUpdateLatestMessageRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface BulkUpdateLatestMessageStubRequest
 */
export interface BulkUpdateLatestMessageStubRequest {
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateLatestMessageStubRequest
     */
    applicationId: string;
    /**
     * 
     * @type {Date}
     * @memberof BulkUpdateLatestMessageStubRequest
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof BulkUpdateLatestMessageStubRequest
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateLatestMessageStubRequest
     */
    category?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateLatestMessageStubRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateLatestMessageStubRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateLatestMessageStubRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateLatestMessageStubRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateLatestMessageStubRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateLatestMessageStubRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateLatestMessageStubRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateLatestMessageStubRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateLatestMessageStubRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateLatestMessageStubRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {Array<UpdateLatestMessageResponseRequest>}
     * @memberof BulkUpdateLatestMessageStubRequest
     */
    responses?: Array<UpdateLatestMessageResponseRequest>;
    /**
     * 
     * @type {boolean}
     * @memberof BulkUpdateLatestMessageStubRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkUpdateLatestMessageStubRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface BulkUpdateNumberRangeRequest
 */
export interface BulkUpdateNumberRangeRequest {
    /**
     * 
     * @type {Array<UpdateNumberRangeResponseRequest>}
     * @memberof BulkUpdateNumberRangeRequest
     */
    responses: Array<UpdateNumberRangeResponseRequest>;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateNumberRangeRequest
     */
    applicationId: string;
    /**
     * 
     * @type {number}
     * @memberof BulkUpdateNumberRangeRequest
     */
    minimumValue?: number;
    /**
     * 
     * @type {number}
     * @memberof BulkUpdateNumberRangeRequest
     */
    maximumValue?: number;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateNumberRangeRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateNumberRangeRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateNumberRangeRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateNumberRangeRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateNumberRangeRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateNumberRangeRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateNumberRangeRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateNumberRangeRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateNumberRangeRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateNumberRangeRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkUpdateNumberRangeRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface BulkUpdateNumberRangeStubRequest
 */
export interface BulkUpdateNumberRangeStubRequest {
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateNumberRangeStubRequest
     */
    applicationId: string;
    /**
     * 
     * @type {number}
     * @memberof BulkUpdateNumberRangeStubRequest
     */
    minimumValue?: number;
    /**
     * 
     * @type {number}
     * @memberof BulkUpdateNumberRangeStubRequest
     */
    maximumValue?: number;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateNumberRangeStubRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateNumberRangeStubRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateNumberRangeStubRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateNumberRangeStubRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateNumberRangeStubRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateNumberRangeStubRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateNumberRangeStubRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateNumberRangeStubRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateNumberRangeStubRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateNumberRangeStubRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {Array<UpdateNumberRangeResponseRequest>}
     * @memberof BulkUpdateNumberRangeStubRequest
     */
    responses?: Array<UpdateNumberRangeResponseRequest>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkUpdateNumberRangeStubRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface BulkUpdateRecipeRequest
 */
export interface BulkUpdateRecipeRequest {
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeRequest
     */
    recipeName: string;
    /**
     * 
     * @type {Array<UpdateStepRequest>}
     * @memberof BulkUpdateRecipeRequest
     */
    steps: Array<UpdateStepRequest>;
    /**
     * 
     * @type {Array<UpdateIngredientRequest>}
     * @memberof BulkUpdateRecipeRequest
     */
    ingredients: Array<UpdateIngredientRequest>;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeRequest
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeRequest
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeRequest
     */
    mealType?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeRequest
     */
    servings?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeRequest
     */
    totalTime?: string;
    /**
     * 
     * @type {number}
     * @memberof BulkUpdateRecipeRequest
     */
    calories?: number;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeRequest
     */
    smallImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeRequest
     */
    largeImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeRequest
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BulkUpdateRecipeRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkUpdateRecipeRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface BulkUpdateRecipeStubRequest
 */
export interface BulkUpdateRecipeStubRequest {
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeStubRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeStubRequest
     */
    recipeName?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeStubRequest
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeStubRequest
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeStubRequest
     */
    mealType?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeStubRequest
     */
    servings?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeStubRequest
     */
    totalTime?: string;
    /**
     * 
     * @type {number}
     * @memberof BulkUpdateRecipeStubRequest
     */
    calories?: number;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeStubRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeStubRequest
     */
    smallImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeStubRequest
     */
    largeImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeStubRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeStubRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeStubRequest
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeStubRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeStubRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateRecipeStubRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {Array<UpdateStepRequest>}
     * @memberof BulkUpdateRecipeStubRequest
     */
    steps?: Array<UpdateStepRequest>;
    /**
     * 
     * @type {Array<UpdateIngredientRequest>}
     * @memberof BulkUpdateRecipeStubRequest
     */
    ingredients?: Array<UpdateIngredientRequest>;
    /**
     * 
     * @type {boolean}
     * @memberof BulkUpdateRecipeStubRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkUpdateRecipeStubRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface BulkUpdateSimpleChoiceRequest
 */
export interface BulkUpdateSimpleChoiceRequest {
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateSimpleChoiceRequest
     */
    choiceType: BulkUpdateSimpleChoiceRequest.ChoiceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateSimpleChoiceRequest
     */
    title: string;
    /**
     * 
     * @type {Array<UpdateSimpleChoiceResponseRequest>}
     * @memberof BulkUpdateSimpleChoiceRequest
     */
    responses: Array<UpdateSimpleChoiceResponseRequest>;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateSimpleChoiceRequest
     */
    applicationId: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateSimpleChoiceRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateSimpleChoiceRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateSimpleChoiceRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateSimpleChoiceRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateSimpleChoiceRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateSimpleChoiceRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateSimpleChoiceRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateSimpleChoiceRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateSimpleChoiceRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkUpdateSimpleChoiceRequest
     */
    languageIds?: Array<string>;
}

/**
 * @export
 * @namespace BulkUpdateSimpleChoiceRequest
 */
export namespace BulkUpdateSimpleChoiceRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum ChoiceTypeEnum {
        Yes = <any> 'Yes',
        No = <any> 'No',
        Maybe = <any> 'Maybe'
    }
}

/**
 * 
 * @export
 * @interface BulkUpdateSimpleChoiceStubRequest
 */
export interface BulkUpdateSimpleChoiceStubRequest {
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateSimpleChoiceStubRequest
     */
    applicationId: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateSimpleChoiceStubRequest
     */
    choiceType?: BulkUpdateSimpleChoiceStubRequest.ChoiceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateSimpleChoiceStubRequest
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateSimpleChoiceStubRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateSimpleChoiceStubRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateSimpleChoiceStubRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateSimpleChoiceStubRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateSimpleChoiceStubRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateSimpleChoiceStubRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateSimpleChoiceStubRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateSimpleChoiceStubRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof BulkUpdateSimpleChoiceStubRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {Array<UpdateSimpleChoiceResponseRequest>}
     * @memberof BulkUpdateSimpleChoiceStubRequest
     */
    responses?: Array<UpdateSimpleChoiceResponseRequest>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BulkUpdateSimpleChoiceStubRequest
     */
    languageIds?: Array<string>;
}

/**
 * @export
 * @namespace BulkUpdateSimpleChoiceStubRequest
 */
export namespace BulkUpdateSimpleChoiceStubRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum ChoiceTypeEnum {
        Yes = <any> 'Yes',
        No = <any> 'No',
        Maybe = <any> 'Maybe'
    }
}

/**
 * 
 * @export
 * @interface ChangePasswordRequest
 */
export interface ChangePasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    oldPassword: string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    newPassword: string;
    /**
     * 
     * @type {string}
     * @memberof ChangePasswordRequest
     */
    newPasswordConfirmation: string;
}

/**
 * 
 * @export
 * @interface ChildContentContainerModel
 */
export interface ChildContentContainerModel {
    /**
     * 
     * @type {string}
     * @memberof ChildContentContainerModel
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ChildContentContainerModel
     */
    isLimitedToChildren?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ChildContentContainerModel
     */
    applicationId?: string;
    /**
     * 
     * @type {Array<WelcomeMessageModel>}
     * @memberof ChildContentContainerModel
     */
    welcomeMessages?: Array<WelcomeMessageModel>;
    /**
     * 
     * @type {Array<HelpMessageModel>}
     * @memberof ChildContentContainerModel
     */
    helpMessages?: Array<HelpMessageModel>;
    /**
     * 
     * @type {Array<FallbackMessageModel>}
     * @memberof ChildContentContainerModel
     */
    fallbackMessages?: Array<FallbackMessageModel>;
    /**
     * 
     * @type {Array<ExitMessageModel>}
     * @memberof ChildContentContainerModel
     */
    exitMessages?: Array<ExitMessageModel>;
    /**
     * 
     * @type {Array<QuestionAnswerModel>}
     * @memberof ChildContentContainerModel
     */
    questionAnswers?: Array<QuestionAnswerModel>;
    /**
     * 
     * @type {Array<LatestMessageModel>}
     * @memberof ChildContentContainerModel
     */
    latestMessages?: Array<LatestMessageModel>;
    /**
     * 
     * @type {Array<EventItemModel>}
     * @memberof ChildContentContainerModel
     */
    eventItems?: Array<EventItemModel>;
    /**
     * 
     * @type {Array<RecipeModel>}
     * @memberof ChildContentContainerModel
     */
    recipes?: Array<RecipeModel>;
    /**
     * 
     * @type {Array<SimpleChoiceModel>}
     * @memberof ChildContentContainerModel
     */
    simpleChoices?: Array<SimpleChoiceModel>;
    /**
     * 
     * @type {Array<NumberRangeModel>}
     * @memberof ChildContentContainerModel
     */
    numberRanges?: Array<NumberRangeModel>;
    /**
     * 
     * @type {Array<CustomRequestModel>}
     * @memberof ChildContentContainerModel
     */
    customRequests?: Array<CustomRequestModel>;
    /**
     * 
     * @type {Array<GenericContentModel>}
     * @memberof ChildContentContainerModel
     */
    contentItems?: Array<GenericContentModel>;
}

/**
 * 
 * @export
 * @interface CompleteTemplateFormModel
 */
export interface CompleteTemplateFormModel {
    /**
     * 
     * @type {string}
     * @memberof CompleteTemplateFormModel
     */
    templateConfigurationId: string;
    /**
     * 
     * @type {Array<TemplateFormFieldValueModel>}
     * @memberof CompleteTemplateFormModel
     */
    templateFormFieldValues?: Array<TemplateFormFieldValueModel>;
}

/**
 * 
 * @export
 * @interface ContentRequestItem
 */
export interface ContentRequestItem {
    /**
     * 
     * @type {string}
     * @memberof ContentRequestItem
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentRequestItem
     */
    featureTypeId?: string;
}

/**
 * 
 * @export
 * @interface ConversationCountModel
 */
export interface ConversationCountModel {
    /**
     * 
     * @type {string}
     * @memberof ConversationCountModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {number}
     * @memberof ConversationCountModel
     */
    conversationCount?: number;
}

/**
 * 
 * @export
 * @interface CreateAnswerRequest
 */
export interface CreateAnswerRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateAnswerRequest
     */
    content: string;
}

/**
 * 
 * @export
 * @interface CreateApplicationFeatureRequest
 */
export interface CreateApplicationFeatureRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationFeatureRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationFeatureRequest
     */
    parentApplicationFeatureId?: string;
}

/**
 * 
 * @export
 * @interface CreateApplicationFromCompletedFormsRequest
 */
export interface CreateApplicationFromCompletedFormsRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateApplicationFromCompletedFormsRequest
     */
    organizationId: string;
    /**
     * 
     * @type {NewApplicationRequest}
     * @memberof CreateApplicationFromCompletedFormsRequest
     */
    applicationInfo: NewApplicationRequest;
    /**
     * 
     * @type {Array<CompleteTemplateFormModel>}
     * @memberof CreateApplicationFromCompletedFormsRequest
     */
    completeForms: Array<CompleteTemplateFormModel>;
}

/**
 * 
 * @export
 * @interface CreateEventRequest
 */
export interface CreateEventRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateEventRequest
     */
    eventName: string;
    /**
     * 
     * @type {Date}
     * @memberof CreateEventRequest
     */
    startDate: Date;
    /**
     * 
     * @type {string}
     * @memberof CreateEventRequest
     */
    applicationId: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventRequest
     */
    applicationFeatureId: string;
    /**
     * 
     * @type {Array<CreateEventResponseRequest>}
     * @memberof CreateEventRequest
     */
    responses: Array<CreateEventResponseRequest>;
    /**
     * 
     * @type {string}
     * @memberof CreateEventRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventRequest
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventRequest
     */
    locationName?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateEventRequest
     */
    categoryNames?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateEventRequest
     */
    ownerName?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventRequest
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventRequest
     */
    status?: string;
    /**
     * 
     * @type {Date}
     * @memberof CreateEventRequest
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof CreateEventRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateEventRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateEventRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface CreateEventResponseRequest
 */
export interface CreateEventResponseRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateEventResponseRequest
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventResponseRequest
     */
    eventQueryType?: CreateEventResponseRequest.EventQueryTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateEventResponseRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventResponseRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventResponseRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventResponseRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventResponseRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventResponseRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventResponseRequest
     */
    mediaResponseContainerId?: string;
}

/**
 * @export
 * @namespace CreateEventResponseRequest
 */
export namespace CreateEventResponseRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum EventQueryTypeEnum {
        General = <any> 'General',
        Location = <any> 'Location',
        StartDate = <any> 'StartDate',
        Status = <any> 'Status'
    }
}

/**
 * 
 * @export
 * @interface CreateEventStubRequest
 */
export interface CreateEventStubRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateEventStubRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventStubRequest
     */
    eventName?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventStubRequest
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventStubRequest
     */
    locationName?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateEventStubRequest
     */
    categoryNames?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateEventStubRequest
     */
    ownerName?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventStubRequest
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventStubRequest
     */
    status?: string;
    /**
     * 
     * @type {Date}
     * @memberof CreateEventStubRequest
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CreateEventStubRequest
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof CreateEventStubRequest
     */
    applicationId: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventStubRequest
     */
    applicationFeatureId: string;
    /**
     * 
     * @type {Array<CreateEventResponseRequest>}
     * @memberof CreateEventStubRequest
     */
    responses?: Array<CreateEventResponseRequest>;
    /**
     * 
     * @type {string}
     * @memberof CreateEventStubRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventStubRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventStubRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventStubRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventStubRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventStubRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventStubRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventStubRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEventStubRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateEventStubRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateEventStubRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface CreateFollowUpHintRequest
 */
export interface CreateFollowUpHintRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateFollowUpHintRequest
     */
    content: string;
}

/**
 * 
 * @export
 * @interface CreateFollowUpRequest
 */
export interface CreateFollowUpRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateFollowUpRequest
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateFollowUpRequest
     */
    name?: string;
    /**
     * 
     * @type {Array<CreateFollowUpHintRequest>}
     * @memberof CreateFollowUpRequest
     */
    followUpHints?: Array<CreateFollowUpHintRequest>;
    /**
     * 
     * @type {UpdateChildContentContainerRequest}
     * @memberof CreateFollowUpRequest
     */
    childContentContainer?: UpdateChildContentContainerRequest;
    /**
     * 
     * @type {string}
     * @memberof CreateFollowUpRequest
     */
    fallbackMessageId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateFollowUpRequest
     */
    helpMessageId?: string;
}

/**
 * 
 * @export
 * @interface CreateIngredientRequest
 */
export interface CreateIngredientRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateIngredientRequest
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof CreateIngredientRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateIngredientRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateIngredientRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateIngredientRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateIngredientRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateIngredientRequest
     */
    displayTitleOverride?: string;
}

/**
 * 
 * @export
 * @interface CreateNewPasswordRequest
 */
export interface CreateNewPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateNewPasswordRequest
     */
    resetCode: string;
    /**
     * 
     * @type {string}
     * @memberof CreateNewPasswordRequest
     */
    newPassword: string;
    /**
     * 
     * @type {string}
     * @memberof CreateNewPasswordRequest
     */
    confirmNewPassword: string;
}

/**
 * 
 * @export
 * @interface CreateQuestionRequest
 */
export interface CreateQuestionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateQuestionRequest
     */
    content: string;
}

/**
 * 
 * @export
 * @interface CreateRecipeRequest
 */
export interface CreateRecipeRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeRequest
     */
    recipeName: string;
    /**
     * 
     * @type {Array<CreateStepRequest>}
     * @memberof CreateRecipeRequest
     */
    steps: Array<CreateStepRequest>;
    /**
     * 
     * @type {Array<CreateIngredientRequest>}
     * @memberof CreateRecipeRequest
     */
    ingredients: Array<CreateIngredientRequest>;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeRequest
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeRequest
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeRequest
     */
    mealType?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeRequest
     */
    servings?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeRequest
     */
    totalTime?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateRecipeRequest
     */
    calories?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeRequest
     */
    smallImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeRequest
     */
    largeImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeRequest
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeRequest
     */
    applicationId: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeRequest
     */
    applicationFeatureId: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRecipeRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateRecipeRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface CreateRecipeStubRequest
 */
export interface CreateRecipeStubRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeStubRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeStubRequest
     */
    recipeName?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeStubRequest
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeStubRequest
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeStubRequest
     */
    mealType?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeStubRequest
     */
    servings?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeStubRequest
     */
    totalTime?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateRecipeStubRequest
     */
    calories?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeStubRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeStubRequest
     */
    smallImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeStubRequest
     */
    largeImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeStubRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeStubRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeStubRequest
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeStubRequest
     */
    applicationId: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeStubRequest
     */
    applicationFeatureId: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeStubRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeStubRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRecipeStubRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {Array<CreateStepRequest>}
     * @memberof CreateRecipeStubRequest
     */
    steps?: Array<CreateStepRequest>;
    /**
     * 
     * @type {Array<CreateIngredientRequest>}
     * @memberof CreateRecipeStubRequest
     */
    ingredients?: Array<CreateIngredientRequest>;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRecipeStubRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateRecipeStubRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface CreateRepromptRequest
 */
export interface CreateRepromptRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateRepromptRequest
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRepromptRequest
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateRepromptRequest
     */
    includeFollowUp?: boolean;
}

/**
 * 
 * @export
 * @interface CreateStepRequest
 */
export interface CreateStepRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateStepRequest
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof CreateStepRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateStepRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateStepRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateStepRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateStepRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateStepRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateStepRequest
     */
    displayTitleOverride?: string;
}

/**
 * 
 * @export
 * @interface CustomRequestExportModel
 */
export interface CustomRequestExportModel {
    /**
     * 
     * @type {string}
     * @memberof CustomRequestExportModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomRequestExportModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomRequestExportModel
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomRequestExportModel
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomRequestExportModel
     */
    isLive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomRequestExportModel
     */
    applicationModuleId?: string;
    /**
     * 
     * @type {Date}
     * @memberof CustomRequestExportModel
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CustomRequestExportModel
     */
    endDate?: Date;
    /**
     * 
     * @type {Array<CustomRequestResponseModel>}
     * @memberof CustomRequestExportModel
     */
    responses?: Array<CustomRequestResponseModel>;
    /**
     * 
     * @type {Array<CustomRequestWebhookModel>}
     * @memberof CustomRequestExportModel
     */
    customRequestWebhooks?: Array<CustomRequestWebhookModel>;
    /**
     * 
     * @type {number}
     * @memberof CustomRequestExportModel
     */
    hits?: number;
    /**
     * 
     * @type {Date}
     * @memberof CustomRequestExportModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CustomRequestExportModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof CustomRequestExportModel
     */
    requestTypes?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomRequestExportModel
     */
    requestNames?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomRequestExportModel
     */
    platformFilter?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomRequestExportModel
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomRequestExportModel
     */
    isComplete?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomRequestExportModel
     */
    createdFromId?: string;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof CustomRequestExportModel
     */
    languages?: Array<LanguageModel>;
    /**
     * 
     * @type {boolean}
     * @memberof CustomRequestExportModel
     */
    shouldNotSync?: boolean;
}

/**
 * 
 * @export
 * @interface CustomRequestModel
 */
export interface CustomRequestModel {
    /**
     * 
     * @type {string}
     * @memberof CustomRequestModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomRequestModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomRequestModel
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomRequestModel
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomRequestModel
     */
    isLive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomRequestModel
     */
    applicationModuleId?: string;
    /**
     * 
     * @type {Date}
     * @memberof CustomRequestModel
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CustomRequestModel
     */
    endDate?: Date;
    /**
     * 
     * @type {Array<CustomRequestResponseModel>}
     * @memberof CustomRequestModel
     */
    responses?: Array<CustomRequestResponseModel>;
    /**
     * 
     * @type {Array<CustomRequestWebhookModel>}
     * @memberof CustomRequestModel
     */
    customRequestWebhooks?: Array<CustomRequestWebhookModel>;
    /**
     * 
     * @type {number}
     * @memberof CustomRequestModel
     */
    hits?: number;
    /**
     * 
     * @type {Date}
     * @memberof CustomRequestModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CustomRequestModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof CustomRequestModel
     */
    requestTypes?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomRequestModel
     */
    requestNames?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomRequestModel
     */
    platformFilter?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomRequestModel
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomRequestModel
     */
    isComplete?: boolean;
    /**
     * 
     * @type {string}
     * @memberof CustomRequestModel
     */
    createdFromId?: string;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof CustomRequestModel
     */
    languages?: Array<LanguageModel>;
    /**
     * 
     * @type {boolean}
     * @memberof CustomRequestModel
     */
    shouldNotSync?: boolean;
}

/**
 * 
 * @export
 * @interface CustomRequestResponseModel
 */
export interface CustomRequestResponseModel {
    /**
     * 
     * @type {string}
     * @memberof CustomRequestResponseModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomRequestResponseModel
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomRequestResponseModel
     */
    customRequestId?: string;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof CustomRequestResponseModel
     */
    smallImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof CustomRequestResponseModel
     */
    largeImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof CustomRequestResponseModel
     */
    backgroundImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof CustomRequestResponseModel
     */
    audio?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof CustomRequestResponseModel
     */
    video?: MediaItemModel;
    /**
     * 
     * @type {RepromptModel}
     * @memberof CustomRequestResponseModel
     */
    reprompt?: RepromptModel;
    /**
     * 
     * @type {MediaResponseContainerModel}
     * @memberof CustomRequestResponseModel
     */
    mediaResponseContainer?: MediaResponseContainerModel;
    /**
     * 
     * @type {FollowUpModel}
     * @memberof CustomRequestResponseModel
     */
    followUp?: FollowUpModel;
    /**
     * 
     * @type {string}
     * @memberof CustomRequestResponseModel
     */
    repromptId?: string;
    /**
     * 
     * @type {Date}
     * @memberof CustomRequestResponseModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof CustomRequestResponseModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof CustomRequestResponseModel
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomRequestResponseModel
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomRequestResponseModel
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomRequestResponseModel
     */
    followUpId?: string;
}

/**
 * 
 * @export
 * @interface CustomRequestWebhookModel
 */
export interface CustomRequestWebhookModel {
    /**
     * 
     * @type {string}
     * @memberof CustomRequestWebhookModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomRequestWebhookModel
     */
    customRequestId?: string;
    /**
     * 
     * @type {WebhookModel}
     * @memberof CustomRequestWebhookModel
     */
    webhook?: WebhookModel;
    /**
     * 
     * @type {Array<WebhookParameterValueModel>}
     * @memberof CustomRequestWebhookModel
     */
    parameterValues?: Array<WebhookParameterValueModel>;
}

/**
 * 
 * @export
 * @interface DeploymentLink
 */
export interface DeploymentLink {
    /**
     * 
     * @type {string}
     * @memberof DeploymentLink
     */
    userName?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentLink
     */
    tokenId?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentLink
     */
    linkedProjectId?: string;
    /**
     * 
     * @type {string}
     * @memberof DeploymentLink
     */
    vendorId?: string;
    /**
     * 
     * @type {any}
     * @memberof DeploymentLink
     */
    additionalProperties?: any;
}

/**
 * 
 * @export
 * @interface DeviceTargetModel
 */
export interface DeviceTargetModel {
    /**
     * 
     * @type {string}
     * @memberof DeviceTargetModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceTargetModel
     */
    assistant?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceTargetModel
     */
    displayName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceTargetModel
     */
    supportsForegroundImages?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceTargetModel
     */
    supportsRichAudio?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceTargetModel
     */
    supportsSsml?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceTargetModel
     */
    supportsVideo?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceTargetModel
     */
    supportsBackgroundImages?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceTargetModel
     */
    supportsDisplayTitle?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof DeviceTargetModel
     */
    supportsDisplayText?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeviceTargetModel
     */
    iconUrl?: string;
    /**
     * 
     * @type {Array<ResponseTemplateTypeModel>}
     * @memberof DeviceTargetModel
     */
    responseTemplates?: Array<ResponseTemplateTypeModel>;
}

/**
 * 
 * @export
 * @interface DialogflowAgentInformation
 */
export interface DialogflowAgentInformation {
    /**
     * 
     * @type {string}
     * @memberof DialogflowAgentInformation
     */
    parent?: string;
    /**
     * 
     * @type {string}
     * @memberof DialogflowAgentInformation
     */
    displayName?: string;
    /**
     * 
     * @type {string}
     * @memberof DialogflowAgentInformation
     */
    defaultLanguageCode?: string;
}

/**
 * 
 * @export
 * @interface DisabledIntent
 */
export interface DisabledIntent {
    /**
     * 
     * @type {string}
     * @memberof DisabledIntent
     */
    displayName?: string;
}

/**
 * 
 * @export
 * @interface EventCategoryModel
 */
export interface EventCategoryModel {
    /**
     * 
     * @type {string}
     * @memberof EventCategoryModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof EventCategoryModel
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface EventItemExportModel
 */
export interface EventItemExportModel {
    /**
     * 
     * @type {string}
     * @memberof EventItemExportModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof EventItemExportModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof EventItemExportModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {string}
     * @memberof EventItemExportModel
     */
    title?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EventItemExportModel
     */
    isLive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EventItemExportModel
     */
    applicationModuleId?: string;
    /**
     * 
     * @type {string}
     * @memberof EventItemExportModel
     */
    eventName?: string;
    /**
     * 
     * @type {string}
     * @memberof EventItemExportModel
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof EventItemExportModel
     */
    locationName?: string;
    /**
     * 
     * @type {string}
     * @memberof EventItemExportModel
     */
    ownerName?: string;
    /**
     * 
     * @type {string}
     * @memberof EventItemExportModel
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof EventItemExportModel
     */
    status?: string;
    /**
     * 
     * @type {Date}
     * @memberof EventItemExportModel
     */
    eventStartDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof EventItemExportModel
     */
    eventEndDate?: Date;
    /**
     * 
     * @type {Array<EventCategoryModel>}
     * @memberof EventItemExportModel
     */
    categories?: Array<EventCategoryModel>;
    /**
     * 
     * @type {Array<EventResponseModel>}
     * @memberof EventItemExportModel
     */
    responses?: Array<EventResponseModel>;
    /**
     * 
     * @type {Array<EventItemWebhookModel>}
     * @memberof EventItemExportModel
     */
    eventItemWebhooks?: Array<EventItemWebhookModel>;
    /**
     * 
     * @type {number}
     * @memberof EventItemExportModel
     */
    hits?: number;
    /**
     * 
     * @type {Date}
     * @memberof EventItemExportModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof EventItemExportModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof EventItemExportModel
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EventItemExportModel
     */
    isComplete?: boolean;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof EventItemExportModel
     */
    languages?: Array<LanguageModel>;
    /**
     * 
     * @type {string}
     * @memberof EventItemExportModel
     */
    createdFromId?: string;
}

/**
 * 
 * @export
 * @interface EventItemModel
 */
export interface EventItemModel {
    /**
     * 
     * @type {string}
     * @memberof EventItemModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof EventItemModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof EventItemModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {string}
     * @memberof EventItemModel
     */
    title?: string;
    /**
     * 
     * @type {boolean}
     * @memberof EventItemModel
     */
    isLive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EventItemModel
     */
    applicationModuleId?: string;
    /**
     * 
     * @type {string}
     * @memberof EventItemModel
     */
    eventName?: string;
    /**
     * 
     * @type {string}
     * @memberof EventItemModel
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof EventItemModel
     */
    locationName?: string;
    /**
     * 
     * @type {string}
     * @memberof EventItemModel
     */
    ownerName?: string;
    /**
     * 
     * @type {string}
     * @memberof EventItemModel
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof EventItemModel
     */
    status?: string;
    /**
     * 
     * @type {Date}
     * @memberof EventItemModel
     */
    eventStartDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof EventItemModel
     */
    eventEndDate?: Date;
    /**
     * 
     * @type {Array<EventCategoryModel>}
     * @memberof EventItemModel
     */
    categories?: Array<EventCategoryModel>;
    /**
     * 
     * @type {Array<EventResponseModel>}
     * @memberof EventItemModel
     */
    responses?: Array<EventResponseModel>;
    /**
     * 
     * @type {Array<EventItemWebhookModel>}
     * @memberof EventItemModel
     */
    eventItemWebhooks?: Array<EventItemWebhookModel>;
    /**
     * 
     * @type {number}
     * @memberof EventItemModel
     */
    hits?: number;
    /**
     * 
     * @type {Date}
     * @memberof EventItemModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof EventItemModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof EventItemModel
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof EventItemModel
     */
    isComplete?: boolean;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof EventItemModel
     */
    languages?: Array<LanguageModel>;
    /**
     * 
     * @type {string}
     * @memberof EventItemModel
     */
    createdFromId?: string;
}

/**
 * 
 * @export
 * @interface EventItemWebhookModel
 */
export interface EventItemWebhookModel {
    /**
     * 
     * @type {string}
     * @memberof EventItemWebhookModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof EventItemWebhookModel
     */
    eventItemId?: string;
    /**
     * 
     * @type {WebhookModel}
     * @memberof EventItemWebhookModel
     */
    webhook?: WebhookModel;
    /**
     * 
     * @type {Array<WebhookParameterValueModel>}
     * @memberof EventItemWebhookModel
     */
    parameterValues?: Array<WebhookParameterValueModel>;
}

/**
 * 
 * @export
 * @interface EventResponseModel
 */
export interface EventResponseModel {
    /**
     * 
     * @type {string}
     * @memberof EventResponseModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof EventResponseModel
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof EventResponseModel
     */
    eventQueryType?: EventResponseModel.EventQueryTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof EventResponseModel
     */
    eventId?: string;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof EventResponseModel
     */
    smallImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof EventResponseModel
     */
    largeImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof EventResponseModel
     */
    backgroundImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof EventResponseModel
     */
    audio?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof EventResponseModel
     */
    video?: MediaItemModel;
    /**
     * 
     * @type {RepromptModel}
     * @memberof EventResponseModel
     */
    reprompt?: RepromptModel;
    /**
     * 
     * @type {string}
     * @memberof EventResponseModel
     */
    repromptId?: string;
    /**
     * 
     * @type {Date}
     * @memberof EventResponseModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof EventResponseModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {MediaResponseContainerModel}
     * @memberof EventResponseModel
     */
    mediaResponseContainer?: MediaResponseContainerModel;
    /**
     * 
     * @type {FollowUpModel}
     * @memberof EventResponseModel
     */
    followUp?: FollowUpModel;
    /**
     * 
     * @type {string}
     * @memberof EventResponseModel
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof EventResponseModel
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof EventResponseModel
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof EventResponseModel
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof EventResponseModel
     */
    applicationFeatureId?: string;
}

/**
 * @export
 * @namespace EventResponseModel
 */
export namespace EventResponseModel {
    /**
     * @export
     * @enum {string}
     */
    export enum EventQueryTypeEnum {
        General = <any> 'General',
        Location = <any> 'Location',
        StartDate = <any> 'StartDate',
        Status = <any> 'Status'
    }
}

/**
 * 
 * @export
 * @interface ExitMessageExportModel
 */
export interface ExitMessageExportModel {
    /**
     * 
     * @type {string}
     * @memberof ExitMessageExportModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ExitMessageExportModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof ExitMessageExportModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {string}
     * @memberof ExitMessageExportModel
     */
    title?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ExitMessageExportModel
     */
    isLive?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof ExitMessageExportModel
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ExitMessageExportModel
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof ExitMessageExportModel
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof ExitMessageExportModel
     */
    createdFromId?: string;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof ExitMessageExportModel
     */
    smallImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof ExitMessageExportModel
     */
    largeImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof ExitMessageExportModel
     */
    backgroundImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof ExitMessageExportModel
     */
    audio?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof ExitMessageExportModel
     */
    video?: MediaItemModel;
    /**
     * 
     * @type {Array<ExitMessageWebhookModel>}
     * @memberof ExitMessageExportModel
     */
    exitMessageWebhooks?: Array<ExitMessageWebhookModel>;
    /**
     * 
     * @type {MediaResponseContainerModel}
     * @memberof ExitMessageExportModel
     */
    mediaResponseContainer?: MediaResponseContainerModel;
    /**
     * 
     * @type {number}
     * @memberof ExitMessageExportModel
     */
    hits?: number;
    /**
     * 
     * @type {RepromptModel}
     * @memberof ExitMessageExportModel
     */
    reprompt?: RepromptModel;
    /**
     * 
     * @type {string}
     * @memberof ExitMessageExportModel
     */
    repromptId?: string;
    /**
     * 
     * @type {Date}
     * @memberof ExitMessageExportModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ExitMessageExportModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof ExitMessageExportModel
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof ExitMessageExportModel
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof ExitMessageExportModel
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof ExitMessageExportModel
     */
    followUpId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ExitMessageExportModel
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExitMessageExportModel
     */
    isComplete?: boolean;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof ExitMessageExportModel
     */
    languages?: Array<LanguageModel>;
    /**
     * 
     * @type {boolean}
     * @memberof ExitMessageExportModel
     */
    shouldNotSync?: boolean;
}

/**
 * 
 * @export
 * @interface ExitMessageModel
 */
export interface ExitMessageModel {
    /**
     * 
     * @type {string}
     * @memberof ExitMessageModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ExitMessageModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof ExitMessageModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {string}
     * @memberof ExitMessageModel
     */
    title?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ExitMessageModel
     */
    isLive?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof ExitMessageModel
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ExitMessageModel
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof ExitMessageModel
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof ExitMessageModel
     */
    createdFromId?: string;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof ExitMessageModel
     */
    smallImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof ExitMessageModel
     */
    largeImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof ExitMessageModel
     */
    backgroundImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof ExitMessageModel
     */
    audio?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof ExitMessageModel
     */
    video?: MediaItemModel;
    /**
     * 
     * @type {Array<ExitMessageWebhookModel>}
     * @memberof ExitMessageModel
     */
    exitMessageWebhooks?: Array<ExitMessageWebhookModel>;
    /**
     * 
     * @type {MediaResponseContainerModel}
     * @memberof ExitMessageModel
     */
    mediaResponseContainer?: MediaResponseContainerModel;
    /**
     * 
     * @type {number}
     * @memberof ExitMessageModel
     */
    hits?: number;
    /**
     * 
     * @type {RepromptModel}
     * @memberof ExitMessageModel
     */
    reprompt?: RepromptModel;
    /**
     * 
     * @type {string}
     * @memberof ExitMessageModel
     */
    repromptId?: string;
    /**
     * 
     * @type {Date}
     * @memberof ExitMessageModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ExitMessageModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof ExitMessageModel
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof ExitMessageModel
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof ExitMessageModel
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof ExitMessageModel
     */
    followUpId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ExitMessageModel
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ExitMessageModel
     */
    isComplete?: boolean;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof ExitMessageModel
     */
    languages?: Array<LanguageModel>;
    /**
     * 
     * @type {boolean}
     * @memberof ExitMessageModel
     */
    shouldNotSync?: boolean;
}

/**
 * 
 * @export
 * @interface ExitMessageWebhookModel
 */
export interface ExitMessageWebhookModel {
    /**
     * 
     * @type {string}
     * @memberof ExitMessageWebhookModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ExitMessageWebhookModel
     */
    exitMessageId?: string;
    /**
     * 
     * @type {WebhookModel}
     * @memberof ExitMessageWebhookModel
     */
    webhook?: WebhookModel;
    /**
     * 
     * @type {Array<WebhookParameterValueModel>}
     * @memberof ExitMessageWebhookModel
     */
    parameterValues?: Array<WebhookParameterValueModel>;
}

/**
 * 
 * @export
 * @interface ExportModel
 */
export interface ExportModel {
    /**
     * 
     * @type {Array<ApplicationFeatureExportModel>}
     * @memberof ExportModel
     */
    applicationFeatures?: Array<ApplicationFeatureExportModel>;
    /**
     * 
     * @type {SharedReferencesExportModel}
     * @memberof ExportModel
     */
    sharedReferences?: SharedReferencesExportModel;
    /**
     * 
     * @type {Array<WelcomeMessageExportModel>}
     * @memberof ExportModel
     */
    welcomeMessages?: Array<WelcomeMessageExportModel>;
    /**
     * 
     * @type {Array<ExitMessageExportModel>}
     * @memberof ExportModel
     */
    exitMessages?: Array<ExitMessageExportModel>;
    /**
     * 
     * @type {Array<FallbackMessageExportModel>}
     * @memberof ExportModel
     */
    fallbackMessages?: Array<FallbackMessageExportModel>;
    /**
     * 
     * @type {Array<HelpMessageExportModel>}
     * @memberof ExportModel
     */
    helpMessages?: Array<HelpMessageExportModel>;
    /**
     * 
     * @type {Array<QuestionAnswerExportModel>}
     * @memberof ExportModel
     */
    questionAnswers?: Array<QuestionAnswerExportModel>;
    /**
     * 
     * @type {Array<EventItemExportModel>}
     * @memberof ExportModel
     */
    eventItems?: Array<EventItemExportModel>;
    /**
     * 
     * @type {Array<LatestMessageExportModel>}
     * @memberof ExportModel
     */
    latestMessages?: Array<LatestMessageExportModel>;
    /**
     * 
     * @type {Array<SimpleChoiceExportModel>}
     * @memberof ExportModel
     */
    simpleChoices?: Array<SimpleChoiceExportModel>;
    /**
     * 
     * @type {Array<RecipeExportModel>}
     * @memberof ExportModel
     */
    recipes?: Array<RecipeExportModel>;
    /**
     * 
     * @type {Array<NumberRangeExportModel>}
     * @memberof ExportModel
     */
    numberRanges?: Array<NumberRangeExportModel>;
    /**
     * 
     * @type {Array<CustomRequestExportModel>}
     * @memberof ExportModel
     */
    customRequests?: Array<CustomRequestExportModel>;
    /**
     * 
     * @type {Array<InteractionModelUpdateWithReference>}
     * @memberof ExportModel
     */
    interactionModelUpdates?: Array<InteractionModelUpdateWithReference>;
}

/**
 * 
 * @export
 * @interface FallbackMessageCategoryModel
 */
export interface FallbackMessageCategoryModel {
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageCategoryModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageCategoryModel
     */
    featureTypeId?: string;
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageCategoryModel
     */
    name?: string;
    /**
     * 
     * @type {FeatureTypeModel}
     * @memberof FallbackMessageCategoryModel
     */
    featureType?: FeatureTypeModel;
}

/**
 * 
 * @export
 * @interface FallbackMessageExportModel
 */
export interface FallbackMessageExportModel {
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageExportModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageExportModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageExportModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageExportModel
     */
    title?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FallbackMessageExportModel
     */
    isLive?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof FallbackMessageExportModel
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FallbackMessageExportModel
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageExportModel
     */
    content?: string;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof FallbackMessageExportModel
     */
    smallImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof FallbackMessageExportModel
     */
    largeImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof FallbackMessageExportModel
     */
    backgroundImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof FallbackMessageExportModel
     */
    audio?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof FallbackMessageExportModel
     */
    video?: MediaItemModel;
    /**
     * 
     * @type {number}
     * @memberof FallbackMessageExportModel
     */
    hits?: number;
    /**
     * 
     * @type {FallbackMessageCategoryModel}
     * @memberof FallbackMessageExportModel
     */
    category?: FallbackMessageCategoryModel;
    /**
     * 
     * @type {RepromptModel}
     * @memberof FallbackMessageExportModel
     */
    reprompt?: RepromptModel;
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageExportModel
     */
    repromptId?: string;
    /**
     * 
     * @type {Array<FallbackMessageWebhookModel>}
     * @memberof FallbackMessageExportModel
     */
    fallbackMessageWebhooks?: Array<FallbackMessageWebhookModel>;
    /**
     * 
     * @type {Date}
     * @memberof FallbackMessageExportModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FallbackMessageExportModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageExportModel
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageExportModel
     */
    createdFromId?: string;
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageExportModel
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageExportModel
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageExportModel
     */
    followUpId?: string;
    /**
     * 
     * @type {FollowUpModel}
     * @memberof FallbackMessageExportModel
     */
    followUp?: FollowUpModel;
    /**
     * 
     * @type {MediaResponseContainerModel}
     * @memberof FallbackMessageExportModel
     */
    mediaResponseContainer?: MediaResponseContainerModel;
    /**
     * 
     * @type {boolean}
     * @memberof FallbackMessageExportModel
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FallbackMessageExportModel
     */
    isComplete?: boolean;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof FallbackMessageExportModel
     */
    languages?: Array<LanguageModel>;
}

/**
 * 
 * @export
 * @interface FallbackMessageModel
 */
export interface FallbackMessageModel {
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageModel
     */
    title?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FallbackMessageModel
     */
    isLive?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof FallbackMessageModel
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FallbackMessageModel
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageModel
     */
    content?: string;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof FallbackMessageModel
     */
    smallImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof FallbackMessageModel
     */
    largeImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof FallbackMessageModel
     */
    backgroundImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof FallbackMessageModel
     */
    audio?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof FallbackMessageModel
     */
    video?: MediaItemModel;
    /**
     * 
     * @type {number}
     * @memberof FallbackMessageModel
     */
    hits?: number;
    /**
     * 
     * @type {FallbackMessageCategoryModel}
     * @memberof FallbackMessageModel
     */
    category?: FallbackMessageCategoryModel;
    /**
     * 
     * @type {RepromptModel}
     * @memberof FallbackMessageModel
     */
    reprompt?: RepromptModel;
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageModel
     */
    repromptId?: string;
    /**
     * 
     * @type {Array<FallbackMessageWebhookModel>}
     * @memberof FallbackMessageModel
     */
    fallbackMessageWebhooks?: Array<FallbackMessageWebhookModel>;
    /**
     * 
     * @type {Date}
     * @memberof FallbackMessageModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof FallbackMessageModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageModel
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageModel
     */
    createdFromId?: string;
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageModel
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageModel
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageModel
     */
    followUpId?: string;
    /**
     * 
     * @type {FollowUpModel}
     * @memberof FallbackMessageModel
     */
    followUp?: FollowUpModel;
    /**
     * 
     * @type {MediaResponseContainerModel}
     * @memberof FallbackMessageModel
     */
    mediaResponseContainer?: MediaResponseContainerModel;
    /**
     * 
     * @type {boolean}
     * @memberof FallbackMessageModel
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FallbackMessageModel
     */
    isComplete?: boolean;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof FallbackMessageModel
     */
    languages?: Array<LanguageModel>;
}

/**
 * 
 * @export
 * @interface FallbackMessageWebhookModel
 */
export interface FallbackMessageWebhookModel {
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageWebhookModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof FallbackMessageWebhookModel
     */
    fallbackMessageId?: string;
    /**
     * 
     * @type {WebhookModel}
     * @memberof FallbackMessageWebhookModel
     */
    webhook?: WebhookModel;
    /**
     * 
     * @type {Array<WebhookParameterValueModel>}
     * @memberof FallbackMessageWebhookModel
     */
    parameterValues?: Array<WebhookParameterValueModel>;
}

/**
 * 
 * @export
 * @interface FeatureModel
 */
export interface FeatureModel {
    /**
     * 
     * @type {string}
     * @memberof FeatureModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof FeatureModel
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FeatureModel
     */
    isCustom?: boolean;
    /**
     * 
     * @type {FeatureTypeModel}
     * @memberof FeatureModel
     */
    featureType?: FeatureTypeModel;
}

/**
 * 
 * @export
 * @interface FeatureTypeModel
 */
export interface FeatureTypeModel {
    /**
     * 
     * @type {string}
     * @memberof FeatureTypeModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof FeatureTypeModel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof FeatureTypeModel
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface FollowUpHintModel
 */
export interface FollowUpHintModel {
    /**
     * 
     * @type {string}
     * @memberof FollowUpHintModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof FollowUpHintModel
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof FollowUpHintModel
     */
    followUpId?: string;
}

/**
 * 
 * @export
 * @interface FollowUpModel
 */
export interface FollowUpModel {
    /**
     * 
     * @type {string}
     * @memberof FollowUpModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof FollowUpModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof FollowUpModel
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof FollowUpModel
     */
    name?: string;
    /**
     * 
     * @type {Array<FollowUpHintModel>}
     * @memberof FollowUpModel
     */
    followUpHints?: Array<FollowUpHintModel>;
    /**
     * 
     * @type {string}
     * @memberof FollowUpModel
     */
    childContentContainerId?: string;
    /**
     * 
     * @type {ChildContentContainerModel}
     * @memberof FollowUpModel
     */
    childContentContainer?: ChildContentContainerModel;
    /**
     * 
     * @type {string}
     * @memberof FollowUpModel
     */
    helpMessageId?: string;
    /**
     * 
     * @type {HelpMessageModel}
     * @memberof FollowUpModel
     */
    helpMessage?: HelpMessageModel;
    /**
     * 
     * @type {string}
     * @memberof FollowUpModel
     */
    fallbackMessageId?: string;
    /**
     * 
     * @type {FallbackMessageModel}
     * @memberof FollowUpModel
     */
    fallbackMessage?: FallbackMessageModel;
    /**
     * 
     * @type {string}
     * @memberof FollowUpModel
     */
    createdFromId?: string;
}

/**
 * 
 * @export
 * @interface GenericContentModel
 */
export interface GenericContentModel {
    /**
     * 
     * @type {string}
     * @memberof GenericContentModel
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GenericContentModel
     */
    isLive?: boolean;
    /**
     * 
     * @type {number}
     * @memberof GenericContentModel
     */
    hits?: number;
    /**
     * 
     * @type {string}
     * @memberof GenericContentModel
     */
    title?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GenericContentModel
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GenericContentModel
     */
    isComplete?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GenericContentModel
     */
    featureTypeId?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericContentModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof GenericContentModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {Date}
     * @memberof GenericContentModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof GenericContentModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof GenericContentModel
     */
    hasAudio?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GenericContentModel
     */
    hasVideo?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GenericContentModel
     */
    hasBackgroundImage?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GenericContentModel
     */
    hasForegroundImage?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GenericContentModel
     */
    followUpId?: string;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof GenericContentModel
     */
    languages?: Array<LanguageModel>;
    /**
     * 
     * @type {boolean}
     * @memberof GenericContentModel
     */
    shouldNotSync?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GenericContentModel
     */
    createdFromId?: string;
}

/**
 * 
 * @export
 * @interface HelpMessageExportModel
 */
export interface HelpMessageExportModel {
    /**
     * 
     * @type {string}
     * @memberof HelpMessageExportModel
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof HelpMessageExportModel
     */
    isLive?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof HelpMessageExportModel
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof HelpMessageExportModel
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof HelpMessageExportModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof HelpMessageExportModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {string}
     * @memberof HelpMessageExportModel
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof HelpMessageExportModel
     */
    content?: string;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof HelpMessageExportModel
     */
    smallImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof HelpMessageExportModel
     */
    largeImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof HelpMessageExportModel
     */
    backgroundImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof HelpMessageExportModel
     */
    audio?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof HelpMessageExportModel
     */
    video?: MediaItemModel;
    /**
     * 
     * @type {Array<HelpMessageWebhookModel>}
     * @memberof HelpMessageExportModel
     */
    helpMessageWebhooks?: Array<HelpMessageWebhookModel>;
    /**
     * 
     * @type {MediaResponseContainerModel}
     * @memberof HelpMessageExportModel
     */
    mediaResponseContainer?: MediaResponseContainerModel;
    /**
     * 
     * @type {FollowUpModel}
     * @memberof HelpMessageExportModel
     */
    followUp?: FollowUpModel;
    /**
     * 
     * @type {number}
     * @memberof HelpMessageExportModel
     */
    hits?: number;
    /**
     * 
     * @type {Date}
     * @memberof HelpMessageExportModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof HelpMessageExportModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {RepromptModel}
     * @memberof HelpMessageExportModel
     */
    reprompt?: RepromptModel;
    /**
     * 
     * @type {string}
     * @memberof HelpMessageExportModel
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof HelpMessageExportModel
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof HelpMessageExportModel
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof HelpMessageExportModel
     */
    followUpId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof HelpMessageExportModel
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {string}
     * @memberof HelpMessageExportModel
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof HelpMessageExportModel
     */
    createdFromId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof HelpMessageExportModel
     */
    isComplete?: boolean;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof HelpMessageExportModel
     */
    languages?: Array<LanguageModel>;
}

/**
 * 
 * @export
 * @interface HelpMessageModel
 */
export interface HelpMessageModel {
    /**
     * 
     * @type {string}
     * @memberof HelpMessageModel
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof HelpMessageModel
     */
    isLive?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof HelpMessageModel
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof HelpMessageModel
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof HelpMessageModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof HelpMessageModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {string}
     * @memberof HelpMessageModel
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof HelpMessageModel
     */
    content?: string;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof HelpMessageModel
     */
    smallImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof HelpMessageModel
     */
    largeImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof HelpMessageModel
     */
    backgroundImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof HelpMessageModel
     */
    audio?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof HelpMessageModel
     */
    video?: MediaItemModel;
    /**
     * 
     * @type {Array<HelpMessageWebhookModel>}
     * @memberof HelpMessageModel
     */
    helpMessageWebhooks?: Array<HelpMessageWebhookModel>;
    /**
     * 
     * @type {MediaResponseContainerModel}
     * @memberof HelpMessageModel
     */
    mediaResponseContainer?: MediaResponseContainerModel;
    /**
     * 
     * @type {FollowUpModel}
     * @memberof HelpMessageModel
     */
    followUp?: FollowUpModel;
    /**
     * 
     * @type {number}
     * @memberof HelpMessageModel
     */
    hits?: number;
    /**
     * 
     * @type {Date}
     * @memberof HelpMessageModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof HelpMessageModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {RepromptModel}
     * @memberof HelpMessageModel
     */
    reprompt?: RepromptModel;
    /**
     * 
     * @type {string}
     * @memberof HelpMessageModel
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof HelpMessageModel
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof HelpMessageModel
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof HelpMessageModel
     */
    followUpId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof HelpMessageModel
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {string}
     * @memberof HelpMessageModel
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof HelpMessageModel
     */
    createdFromId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof HelpMessageModel
     */
    isComplete?: boolean;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof HelpMessageModel
     */
    languages?: Array<LanguageModel>;
}

/**
 * 
 * @export
 * @interface HelpMessageWebhookModel
 */
export interface HelpMessageWebhookModel {
    /**
     * 
     * @type {string}
     * @memberof HelpMessageWebhookModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof HelpMessageWebhookModel
     */
    helpMessageId?: string;
    /**
     * 
     * @type {WebhookModel}
     * @memberof HelpMessageWebhookModel
     */
    webhook?: WebhookModel;
    /**
     * 
     * @type {Array<WebhookParameterValueModel>}
     * @memberof HelpMessageWebhookModel
     */
    parameterValues?: Array<WebhookParameterValueModel>;
}

/**
 * 
 * @export
 * @interface Intent
 */
export interface Intent {
    /**
     * 
     * @type {string}
     * @memberof Intent
     */
    displayName?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Intent
     */
    name?: { [key: string]: string; };
    /**
     * 
     * @type {Array<string>}
     * @memberof Intent
     */
    utterances?: Array<string>;
    /**
     * 
     * @type {Array<Slot>}
     * @memberof Intent
     */
    slots?: Array<Slot>;
    /**
     * 
     * @type {boolean}
     * @memberof Intent
     */
    isUserEditable?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Intent
     */
    platformsToIgnoreUtterances?: Array<string>;
}

/**
 * 
 * @export
 * @interface IntentStatusUpdate
 */
export interface IntentStatusUpdate {
    /**
     * 
     * @type {string}
     * @memberof IntentStatusUpdate
     */
    intentName?: string;
}

/**
 * 
 * @export
 * @interface IntentUpdate
 */
export interface IntentUpdate {
    /**
     * 
     * @type {Array<string>}
     * @memberof IntentUpdate
     */
    addedUtterances?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof IntentUpdate
     */
    removedUtterances?: Array<string>;
}

/**
 * 
 * @export
 * @interface InteractionModel
 */
export interface InteractionModel {
    /**
     * 
     * @type {number}
     * @memberof InteractionModel
     */
    validAsOf?: number;
    /**
     * 
     * @type {string}
     * @memberof InteractionModel
     */
    locale?: string;
    /**
     * 
     * @type {Array<Intent>}
     * @memberof InteractionModel
     */
    intents?: Array<Intent>;
    /**
     * 
     * @type {Array<DisabledIntent>}
     * @memberof InteractionModel
     */
    disabledIntents?: Array<DisabledIntent>;
}

/**
 * 
 * @export
 * @interface InteractionModelDeploymentResultModel
 */
export interface InteractionModelDeploymentResultModel {
    /**
     * 
     * @type {string}
     * @memberof InteractionModelDeploymentResultModel
     */
    applicationId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InteractionModelDeploymentResultModel
     */
    success?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InteractionModelDeploymentResultModel
     */
    platform?: string;
    /**
     * 
     * @type {string}
     * @memberof InteractionModelDeploymentResultModel
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof InteractionModelDeploymentResultModel
     */
    validAsOfTicks?: number;
}

/**
 * 
 * @export
 * @interface InteractionModelStatus
 */
export interface InteractionModelStatus {
    /**
     * 
     * @type {Array<InteractionModelDeploymentResultModel>}
     * @memberof InteractionModelStatus
     */
    latestDeploymentResults?: Array<InteractionModelDeploymentResultModel>;
    /**
     * 
     * @type {Array<QueuedInteractionModelUpdate>}
     * @memberof InteractionModelStatus
     */
    queuedForDeploymentToPlatforms?: Array<QueuedInteractionModelUpdate>;
}

/**
 * 
 * @export
 * @interface InteractionModelUpdate
 */
export interface InteractionModelUpdate {
    /**
     * 
     * @type {number}
     * @memberof InteractionModelUpdate
     */
    effectiveAsOf?: number;
    /**
     * 
     * @type {{ [key: string]: IntentUpdate; }}
     * @memberof InteractionModelUpdate
     */
    intents?: { [key: string]: IntentUpdate; };
    /**
     * 
     * @type {Array<IntentStatusUpdate>}
     * @memberof InteractionModelUpdate
     */
    disableIntents?: Array<IntentStatusUpdate>;
    /**
     * 
     * @type {Array<IntentStatusUpdate>}
     * @memberof InteractionModelUpdate
     */
    enableIntents?: Array<IntentStatusUpdate>;
    /**
     * 
     * @type {boolean}
     * @memberof InteractionModelUpdate
     */
    isBaseUpdate?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InteractionModelUpdate
     */
    locale?: string;
}

/**
 * 
 * @export
 * @interface InteractionModelUpdateWithReference
 */
export interface InteractionModelUpdateWithReference {
    /**
     * 
     * @type {string}
     * @memberof InteractionModelUpdateWithReference
     */
    createdFromReferenceId?: string;
    /**
     * 
     * @type {number}
     * @memberof InteractionModelUpdateWithReference
     */
    effectiveAsOf?: number;
    /**
     * 
     * @type {{ [key: string]: IntentUpdate; }}
     * @memberof InteractionModelUpdateWithReference
     */
    intents?: { [key: string]: IntentUpdate; };
    /**
     * 
     * @type {Array<IntentStatusUpdate>}
     * @memberof InteractionModelUpdateWithReference
     */
    disableIntents?: Array<IntentStatusUpdate>;
    /**
     * 
     * @type {Array<IntentStatusUpdate>}
     * @memberof InteractionModelUpdateWithReference
     */
    enableIntents?: Array<IntentStatusUpdate>;
    /**
     * 
     * @type {boolean}
     * @memberof InteractionModelUpdateWithReference
     */
    isBaseUpdate?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InteractionModelUpdateWithReference
     */
    locale?: string;
}

/**
 * 
 * @export
 * @interface InvitationModel
 */
export interface InvitationModel {
    /**
     * 
     * @type {string}
     * @memberof InvitationModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof InvitationModel
     */
    organizationId?: string;
    /**
     * 
     * @type {string}
     * @memberof InvitationModel
     */
    email?: string;
    /**
     * 
     * @type {Date}
     * @memberof InvitationModel
     */
    expirationDate?: Date;
}

/**
 * 
 * @export
 * @interface LanguageModel
 */
export interface LanguageModel {
    /**
     * 
     * @type {string}
     * @memberof LanguageModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof LanguageModel
     */
    shortCode?: string;
    /**
     * 
     * @type {string}
     * @memberof LanguageModel
     */
    languageGroupCode?: string;
    /**
     * 
     * @type {string}
     * @memberof LanguageModel
     */
    regionCode?: string;
    /**
     * 
     * @type {string}
     * @memberof LanguageModel
     */
    supportedPlatforms?: string;
}

/**
 * 
 * @export
 * @interface LatestMessageExportModel
 */
export interface LatestMessageExportModel {
    /**
     * 
     * @type {string}
     * @memberof LatestMessageExportModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof LatestMessageExportModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof LatestMessageExportModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {string}
     * @memberof LatestMessageExportModel
     */
    title?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LatestMessageExportModel
     */
    isLive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LatestMessageExportModel
     */
    applicationModuleId?: string;
    /**
     * 
     * @type {string}
     * @memberof LatestMessageExportModel
     */
    createdFromId?: string;
    /**
     * 
     * @type {Date}
     * @memberof LatestMessageExportModel
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof LatestMessageExportModel
     */
    endDate?: Date;
    /**
     * 
     * @type {Array<LatestMessageResponseModel>}
     * @memberof LatestMessageExportModel
     */
    responses?: Array<LatestMessageResponseModel>;
    /**
     * 
     * @type {Array<LatestMessageWebhookModel>}
     * @memberof LatestMessageExportModel
     */
    latestMessageWebhooks?: Array<LatestMessageWebhookModel>;
    /**
     * 
     * @type {number}
     * @memberof LatestMessageExportModel
     */
    hits?: number;
    /**
     * 
     * @type {Date}
     * @memberof LatestMessageExportModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof LatestMessageExportModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof LatestMessageExportModel
     */
    category?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LatestMessageExportModel
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LatestMessageExportModel
     */
    isComplete?: boolean;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof LatestMessageExportModel
     */
    languages?: Array<LanguageModel>;
}

/**
 * 
 * @export
 * @interface LatestMessageModel
 */
export interface LatestMessageModel {
    /**
     * 
     * @type {string}
     * @memberof LatestMessageModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof LatestMessageModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof LatestMessageModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {string}
     * @memberof LatestMessageModel
     */
    title?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LatestMessageModel
     */
    isLive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LatestMessageModel
     */
    applicationModuleId?: string;
    /**
     * 
     * @type {string}
     * @memberof LatestMessageModel
     */
    createdFromId?: string;
    /**
     * 
     * @type {Date}
     * @memberof LatestMessageModel
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof LatestMessageModel
     */
    endDate?: Date;
    /**
     * 
     * @type {Array<LatestMessageResponseModel>}
     * @memberof LatestMessageModel
     */
    responses?: Array<LatestMessageResponseModel>;
    /**
     * 
     * @type {Array<LatestMessageWebhookModel>}
     * @memberof LatestMessageModel
     */
    latestMessageWebhooks?: Array<LatestMessageWebhookModel>;
    /**
     * 
     * @type {number}
     * @memberof LatestMessageModel
     */
    hits?: number;
    /**
     * 
     * @type {Date}
     * @memberof LatestMessageModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof LatestMessageModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof LatestMessageModel
     */
    category?: string;
    /**
     * 
     * @type {boolean}
     * @memberof LatestMessageModel
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof LatestMessageModel
     */
    isComplete?: boolean;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof LatestMessageModel
     */
    languages?: Array<LanguageModel>;
}

/**
 * 
 * @export
 * @interface LatestMessageResponseModel
 */
export interface LatestMessageResponseModel {
    /**
     * 
     * @type {string}
     * @memberof LatestMessageResponseModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof LatestMessageResponseModel
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof LatestMessageResponseModel
     */
    latestMessageId?: string;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof LatestMessageResponseModel
     */
    smallImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof LatestMessageResponseModel
     */
    largeImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof LatestMessageResponseModel
     */
    backgroundImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof LatestMessageResponseModel
     */
    audio?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof LatestMessageResponseModel
     */
    video?: MediaItemModel;
    /**
     * 
     * @type {string}
     * @memberof LatestMessageResponseModel
     */
    repromptId?: string;
    /**
     * 
     * @type {RepromptModel}
     * @memberof LatestMessageResponseModel
     */
    reprompt?: RepromptModel;
    /**
     * 
     * @type {MediaResponseContainerModel}
     * @memberof LatestMessageResponseModel
     */
    mediaResponseContainer?: MediaResponseContainerModel;
    /**
     * 
     * @type {FollowUpModel}
     * @memberof LatestMessageResponseModel
     */
    followUp?: FollowUpModel;
    /**
     * 
     * @type {Date}
     * @memberof LatestMessageResponseModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof LatestMessageResponseModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof LatestMessageResponseModel
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof LatestMessageResponseModel
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof LatestMessageResponseModel
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof LatestMessageResponseModel
     */
    followUpId?: string;
}

/**
 * 
 * @export
 * @interface LatestMessageWebhookModel
 */
export interface LatestMessageWebhookModel {
    /**
     * 
     * @type {string}
     * @memberof LatestMessageWebhookModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof LatestMessageWebhookModel
     */
    latestMessageId?: string;
    /**
     * 
     * @type {WebhookModel}
     * @memberof LatestMessageWebhookModel
     */
    webhook?: WebhookModel;
    /**
     * 
     * @type {Array<WebhookParameterValueModel>}
     * @memberof LatestMessageWebhookModel
     */
    parameterValues?: Array<WebhookParameterValueModel>;
}

/**
 * 
 * @export
 * @interface LuisAppEndpoint
 */
export interface LuisAppEndpoint {
    /**
     * 
     * @type {string}
     * @memberof LuisAppEndpoint
     */
    endpointRegion?: string;
    /**
     * 
     * @type {string}
     * @memberof LuisAppEndpoint
     */
    endpointUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof LuisAppEndpoint
     */
    versionId?: string;
}

/**
 * 
 * @export
 * @interface LuisAppEndpointsContainer
 */
export interface LuisAppEndpointsContainer {
    /**
     * 
     * @type {LuisAppEndpoint}
     * @memberof LuisAppEndpointsContainer
     */
    PRODUCTION?: LuisAppEndpoint;
}

/**
 * 
 * @export
 * @interface LuisApplicationInformation
 */
export interface LuisApplicationInformation {
    /**
     * 
     * @type {LuisAppEndpointsContainer}
     * @memberof LuisApplicationInformation
     */
    endpoints?: LuisAppEndpointsContainer;
    /**
     * 
     * @type {string}
     * @memberof LuisApplicationInformation
     */
    activeVersion?: string;
    /**
     * 
     * @type {string}
     * @memberof LuisApplicationInformation
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof LuisApplicationInformation
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface MediaContentItems
 */
export interface MediaContentItems {
    /**
     * 
     * @type {string}
     * @memberof MediaContentItems
     */
    mediaItemId?: string;
    /**
     * 
     * @type {Array<MediaRelatedContentItem>}
     * @memberof MediaContentItems
     */
    contentItems?: Array<MediaRelatedContentItem>;
}

/**
 * 
 * @export
 * @interface MediaItemModel
 */
export interface MediaItemModel {
    /**
     * 
     * @type {string}
     * @memberof MediaItemModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaItemModel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaItemModel
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaItemModel
     */
    fileExtension?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaItemModel
     */
    mediaType?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaItemModel
     */
    applicationId?: string;
    /**
     * 
     * @type {Date}
     * @memberof MediaItemModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof MediaItemModel
     */
    caption?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MediaItemModel
     */
    isDisabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MediaItemModel
     */
    modifiedByUserId?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaItemModel
     */
    createdFromId?: string;
    /**
     * 
     * @type {UserModel}
     * @memberof MediaItemModel
     */
    modifiedByUser?: UserModel;
}

/**
 * 
 * @export
 * @interface MediaRelatedContentItem
 */
export interface MediaRelatedContentItem {
    /**
     * 
     * @type {string}
     * @memberof MediaRelatedContentItem
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaRelatedContentItem
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaRelatedContentItem
     */
    featureTypeId?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaRelatedContentItem
     */
    contentItemId?: string;
}

/**
 * 
 * @export
 * @interface MediaResponseContainerModel
 */
export interface MediaResponseContainerModel {
    /**
     * 
     * @type {string}
     * @memberof MediaResponseContainerModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaResponseContainerModel
     */
    applicationId?: string;
    /**
     * 
     * @type {Array<MediaItemModel>}
     * @memberof MediaResponseContainerModel
     */
    additionalMediaItems?: Array<MediaItemModel>;
    /**
     * 
     * @type {Array<MediaResponseModel>}
     * @memberof MediaResponseContainerModel
     */
    responses?: Array<MediaResponseModel>;
    /**
     * 
     * @type {string}
     * @memberof MediaResponseContainerModel
     */
    createdFromId?: string;
}

/**
 * 
 * @export
 * @interface MediaResponseModel
 */
export interface MediaResponseModel {
    /**
     * 
     * @type {string}
     * @memberof MediaResponseModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaResponseModel
     */
    responseTemplateTypeId?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaResponseModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaResponseModel
     */
    displayTitle?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaResponseModel
     */
    displayText?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaResponseModel
     */
    readoutOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaResponseModel
     */
    foregroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaResponseModel
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaResponseModel
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaResponseModel
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaResponseModel
     */
    deviceTargetId?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaResponseModel
     */
    customMarkup?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaResponseModel
     */
    createdFromId?: string;
    /**
     * 
     * @type {ResponseTemplateTypeModel}
     * @memberof MediaResponseModel
     */
    responseTemplateType?: ResponseTemplateTypeModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof MediaResponseModel
     */
    foregroundImageItem?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof MediaResponseModel
     */
    backgroundImageItem?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof MediaResponseModel
     */
    audioItem?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof MediaResponseModel
     */
    videoItem?: MediaItemModel;
    /**
     * 
     * @type {BasicDeviceTargetModel}
     * @memberof MediaResponseModel
     */
    deviceTarget?: BasicDeviceTargetModel;
}

/**
 * 
 * @export
 * @interface MemberRoleUpdateRequest
 */
export interface MemberRoleUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof MemberRoleUpdateRequest
     */
    roleId: string;
}

/**
 * 
 * @export
 * @interface MembershipModel
 */
export interface MembershipModel {
    /**
     * 
     * @type {string}
     * @memberof MembershipModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof MembershipModel
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof MembershipModel
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof MembershipModel
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof MembershipModel
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof MembershipModel
     */
    imageUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof MembershipModel
     */
    organizationId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MembershipModel
     */
    isAdmin?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MembershipModel
     */
    canEdit?: boolean;
    /**
     * 
     * @type {Array<ApplicationMemberRoleModel>}
     * @memberof MembershipModel
     */
    applicationMemberships?: Array<ApplicationMemberRoleModel>;
}

/**
 * 
 * @export
 * @interface MicrosoftDeploymentLink
 */
export interface MicrosoftDeploymentLink {
    /**
     * 
     * @type {string}
     * @memberof MicrosoftDeploymentLink
     */
    botServiceName?: string;
    /**
     * 
     * @type {string}
     * @memberof MicrosoftDeploymentLink
     */
    microsoftAppId?: string;
    /**
     * 
     * @type {string}
     * @memberof MicrosoftDeploymentLink
     */
    microsoftAppPassword?: string;
    /**
     * 
     * @type {string}
     * @memberof MicrosoftDeploymentLink
     */
    luisRegion?: string;
    /**
     * 
     * @type {string}
     * @memberof MicrosoftDeploymentLink
     */
    luisAuthoringKey?: string;
    /**
     * 
     * @type {string}
     * @memberof MicrosoftDeploymentLink
     */
    luisAppId?: string;
}

/**
 * 
 * @export
 * @interface NewApiUserRequest
 */
export interface NewApiUserRequest {
    /**
     * 
     * @type {string}
     * @memberof NewApiUserRequest
     */
    organizationId: string;
}

/**
 * 
 * @export
 * @interface NewApplicationMemberRequest
 */
export interface NewApplicationMemberRequest {
    /**
     * 
     * @type {string}
     * @memberof NewApplicationMemberRequest
     */
    organizationMemberId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewApplicationMemberRequest
     */
    roleId?: string;
}

/**
 * 
 * @export
 * @interface NewApplicationRequest
 */
export interface NewApplicationRequest {
    /**
     * 
     * @type {string}
     * @memberof NewApplicationRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewApplicationRequest
     */
    shortDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof NewApplicationRequest
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof NewApplicationRequest
     */
    invocationPhrase: string;
    /**
     * 
     * @type {string}
     * @memberof NewApplicationRequest
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof NewApplicationRequest
     */
    defaultLanguageId?: string;
}

/**
 * 
 * @export
 * @interface NewBulkApplicationMemberRequest
 */
export interface NewBulkApplicationMemberRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof NewBulkApplicationMemberRequest
     */
    organizationMemberIds?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof NewBulkApplicationMemberRequest
     */
    roleId?: string;
}

/**
 * 
 * @export
 * @interface NewBulkMediaResponseContainerRequest
 */
export interface NewBulkMediaResponseContainerRequest {
    /**
     * 
     * @type {string}
     * @memberof NewBulkMediaResponseContainerRequest
     */
    applicationId: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewBulkMediaResponseContainerRequest
     */
    additionalMediaItemIds: Array<string>;
    /**
     * 
     * @type {Array<NewMediaResponseRequest>}
     * @memberof NewBulkMediaResponseContainerRequest
     */
    responses: Array<NewMediaResponseRequest>;
}

/**
 * 
 * @export
 * @interface NewCustomRequestRequest
 */
export interface NewCustomRequestRequest {
    /**
     * 
     * @type {Array<NewCustomRequestResponseRequest>}
     * @memberof NewCustomRequestRequest
     */
    responses: Array<NewCustomRequestResponseRequest>;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestRequest
     */
    applicationId: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestRequest
     */
    applicationFeatureId: string;
    /**
     * 
     * @type {Date}
     * @memberof NewCustomRequestRequest
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof NewCustomRequestRequest
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestRequest
     */
    requestTypes?: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestRequest
     */
    requestNames?: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestRequest
     */
    platformFilter?: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewCustomRequestRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewCustomRequestRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface NewCustomRequestResponseRequest
 */
export interface NewCustomRequestResponseRequest {
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestResponseRequest
     */
    content: string;
}

/**
 * 
 * @export
 * @interface NewCustomRequestStubRequest
 */
export interface NewCustomRequestStubRequest {
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestStubRequest
     */
    applicationId: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestStubRequest
     */
    applicationFeatureId: string;
    /**
     * 
     * @type {Date}
     * @memberof NewCustomRequestStubRequest
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof NewCustomRequestStubRequest
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestStubRequest
     */
    requestTypes?: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestStubRequest
     */
    requestNames?: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestStubRequest
     */
    platformFilter?: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestStubRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestStubRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestStubRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestStubRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestStubRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestStubRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestStubRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestStubRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestStubRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof NewCustomRequestStubRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {Array<NewCustomRequestResponseRequest>}
     * @memberof NewCustomRequestStubRequest
     */
    responses?: Array<NewCustomRequestResponseRequest>;
    /**
     * 
     * @type {boolean}
     * @memberof NewCustomRequestStubRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewCustomRequestStubRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface NewExitMessageRequest
 */
export interface NewExitMessageRequest {
    /**
     * 
     * @type {string}
     * @memberof NewExitMessageRequest
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof NewExitMessageRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof NewExitMessageRequest
     */
    applicationId: string;
    /**
     * 
     * @type {string}
     * @memberof NewExitMessageRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewExitMessageRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewExitMessageRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewExitMessageRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewExitMessageRequest
     */
    applicationFeatureId: string;
    /**
     * 
     * @type {string}
     * @memberof NewExitMessageRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewExitMessageRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof NewExitMessageRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewExitMessageRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewExitMessageRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface NewExitMessageStubRequest
 */
export interface NewExitMessageStubRequest {
    /**
     * 
     * @type {string}
     * @memberof NewExitMessageStubRequest
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof NewExitMessageStubRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof NewExitMessageStubRequest
     */
    applicationId: string;
    /**
     * 
     * @type {string}
     * @memberof NewExitMessageStubRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewExitMessageStubRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewExitMessageStubRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewExitMessageStubRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewExitMessageStubRequest
     */
    applicationFeatureId: string;
    /**
     * 
     * @type {string}
     * @memberof NewExitMessageStubRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewExitMessageStubRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof NewExitMessageStubRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewExitMessageStubRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewExitMessageStubRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface NewFallbackMessageRequest
 */
export interface NewFallbackMessageRequest {
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageRequest
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageRequest
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageRequest
     */
    applicationFeatureId: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageRequest
     */
    categoryId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewFallbackMessageRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewFallbackMessageRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface NewFallbackMessageStubRequest
 */
export interface NewFallbackMessageStubRequest {
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageStubRequest
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageStubRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageStubRequest
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageStubRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageStubRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageStubRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageStubRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageStubRequest
     */
    applicationFeatureId: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageStubRequest
     */
    categoryId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageStubRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageStubRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageStubRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageStubRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof NewFallbackMessageStubRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewFallbackMessageStubRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewFallbackMessageStubRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface NewHelpMessageRequest
 */
export interface NewHelpMessageRequest {
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageRequest
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageRequest
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageRequest
     */
    applicationFeatureId: string;
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewHelpMessageRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewHelpMessageRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface NewHelpMessageStubRequest
 */
export interface NewHelpMessageStubRequest {
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageStubRequest
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageStubRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageStubRequest
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageStubRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageStubRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageStubRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageStubRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageStubRequest
     */
    applicationFeatureId: string;
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageStubRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageStubRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageStubRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageStubRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof NewHelpMessageStubRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewHelpMessageStubRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewHelpMessageStubRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface NewInvitationRequest
 */
export interface NewInvitationRequest {
    /**
     * 
     * @type {string}
     * @memberof NewInvitationRequest
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof NewInvitationRequest
     */
    roleId: string;
}

/**
 * 
 * @export
 * @interface NewLatestMessageRequest
 */
export interface NewLatestMessageRequest {
    /**
     * 
     * @type {Array<NewLatestMessageResponseRequest>}
     * @memberof NewLatestMessageRequest
     */
    responses: Array<NewLatestMessageResponseRequest>;
    /**
     * 
     * @type {Date}
     * @memberof NewLatestMessageRequest
     */
    startDate: Date;
    /**
     * 
     * @type {Date}
     * @memberof NewLatestMessageRequest
     */
    endDate: Date;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageRequest
     */
    category: string;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageRequest
     */
    applicationId: string;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageRequest
     */
    applicationFeatureId: string;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewLatestMessageRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewLatestMessageRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface NewLatestMessageResponseRequest
 */
export interface NewLatestMessageResponseRequest {
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageResponseRequest
     */
    content: string;
}

/**
 * 
 * @export
 * @interface NewLatestMessageStubRequest
 */
export interface NewLatestMessageStubRequest {
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageStubRequest
     */
    applicationId: string;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageStubRequest
     */
    applicationFeatureId: string;
    /**
     * 
     * @type {Date}
     * @memberof NewLatestMessageStubRequest
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof NewLatestMessageStubRequest
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageStubRequest
     */
    category?: string;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageStubRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageStubRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageStubRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageStubRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageStubRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageStubRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageStubRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageStubRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageStubRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof NewLatestMessageStubRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {Array<NewLatestMessageResponseRequest>}
     * @memberof NewLatestMessageStubRequest
     */
    responses?: Array<NewLatestMessageResponseRequest>;
    /**
     * 
     * @type {boolean}
     * @memberof NewLatestMessageStubRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewLatestMessageStubRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface NewLuisAppResponse
 */
export interface NewLuisAppResponse {
    /**
     * 
     * @type {string}
     * @memberof NewLuisAppResponse
     */
    luisAppId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewLuisAppResponse
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface NewMediaItemRequest
 */
export interface NewMediaItemRequest {
    /**
     * 
     * @type {string}
     * @memberof NewMediaItemRequest
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof NewMediaItemRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewMediaItemRequest
     */
    fileName: string;
    /**
     * 
     * @type {string}
     * @memberof NewMediaItemRequest
     */
    caption?: string;
}

/**
 * 
 * @export
 * @interface NewMediaResponseContainerRequest
 */
export interface NewMediaResponseContainerRequest {
    /**
     * 
     * @type {string}
     * @memberof NewMediaResponseContainerRequest
     */
    applicationId: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewMediaResponseContainerRequest
     */
    additionalMediaItemIds: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewMediaResponseContainerRequest
     */
    responseIds: Array<string>;
}

/**
 * 
 * @export
 * @interface NewMediaResponseRequest
 */
export interface NewMediaResponseRequest {
    /**
     * 
     * @type {string}
     * @memberof NewMediaResponseRequest
     */
    responseTemplateTypeId: string;
    /**
     * 
     * @type {string}
     * @memberof NewMediaResponseRequest
     */
    applicationId: string;
    /**
     * 
     * @type {string}
     * @memberof NewMediaResponseRequest
     */
    displayTitle?: string;
    /**
     * 
     * @type {string}
     * @memberof NewMediaResponseRequest
     */
    displayText?: string;
    /**
     * 
     * @type {string}
     * @memberof NewMediaResponseRequest
     */
    readoutOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof NewMediaResponseRequest
     */
    foregroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewMediaResponseRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewMediaResponseRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewMediaResponseRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewMediaResponseRequest
     */
    deviceTargetId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewMediaResponseRequest
     */
    customMarkup?: string;
}

/**
 * 
 * @export
 * @interface NewModuleRequest
 */
export interface NewModuleRequest {
    /**
     * 
     * @type {string}
     * @memberof NewModuleRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewModuleRequest
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface NewNumberRangeRequest
 */
export interface NewNumberRangeRequest {
    /**
     * 
     * @type {Array<NewNumberRangeResponseRequest>}
     * @memberof NewNumberRangeRequest
     */
    responses: Array<NewNumberRangeResponseRequest>;
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeRequest
     */
    applicationId: string;
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeRequest
     */
    applicationFeatureId: string;
    /**
     * 
     * @type {number}
     * @memberof NewNumberRangeRequest
     */
    minimumValue?: number;
    /**
     * 
     * @type {number}
     * @memberof NewNumberRangeRequest
     */
    maximumValue?: number;
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewNumberRangeRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface NewNumberRangeResponseRequest
 */
export interface NewNumberRangeResponseRequest {
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeResponseRequest
     */
    content: string;
}

/**
 * 
 * @export
 * @interface NewNumberRangeStubRequest
 */
export interface NewNumberRangeStubRequest {
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeStubRequest
     */
    applicationId: string;
    /**
     * 
     * @type {Array<NewNumberRangeResponseRequest>}
     * @memberof NewNumberRangeStubRequest
     */
    responses?: Array<NewNumberRangeResponseRequest>;
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeStubRequest
     */
    applicationFeatureId: string;
    /**
     * 
     * @type {number}
     * @memberof NewNumberRangeStubRequest
     */
    minimumValue?: number;
    /**
     * 
     * @type {number}
     * @memberof NewNumberRangeStubRequest
     */
    maximumValue?: number;
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeStubRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeStubRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeStubRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeStubRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeStubRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeStubRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeStubRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeStubRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeStubRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof NewNumberRangeStubRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewNumberRangeStubRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface NewOrganizationRequest
 */
export interface NewOrganizationRequest {
    /**
     * 
     * @type {string}
     * @memberof NewOrganizationRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewOrganizationRequest
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface NewQuestionAnswerRequest
 */
export interface NewQuestionAnswerRequest {
    /**
     * 
     * @type {Array<CreateQuestionRequest>}
     * @memberof NewQuestionAnswerRequest
     */
    questions: Array<CreateQuestionRequest>;
    /**
     * 
     * @type {Array<CreateAnswerRequest>}
     * @memberof NewQuestionAnswerRequest
     */
    answers: Array<CreateAnswerRequest>;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionAnswerRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionAnswerRequest
     */
    applicationId: string;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionAnswerRequest
     */
    applicationFeatureId: string;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionAnswerRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionAnswerRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionAnswerRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionAnswerRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionAnswerRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionAnswerRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionAnswerRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionAnswerRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionAnswerRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewQuestionAnswerRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewQuestionAnswerRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface NewQuestionAnswerStubRequest
 */
export interface NewQuestionAnswerStubRequest {
    /**
     * 
     * @type {string}
     * @memberof NewQuestionAnswerStubRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionAnswerStubRequest
     */
    applicationId: string;
    /**
     * 
     * @type {Array<CreateQuestionRequest>}
     * @memberof NewQuestionAnswerStubRequest
     */
    questions?: Array<CreateQuestionRequest>;
    /**
     * 
     * @type {Array<CreateAnswerRequest>}
     * @memberof NewQuestionAnswerStubRequest
     */
    answers?: Array<CreateAnswerRequest>;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionAnswerStubRequest
     */
    applicationFeatureId: string;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionAnswerStubRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionAnswerStubRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionAnswerStubRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionAnswerStubRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionAnswerStubRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionAnswerStubRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionAnswerStubRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionAnswerStubRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof NewQuestionAnswerStubRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewQuestionAnswerStubRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewQuestionAnswerStubRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface NewResponseTemplateTypeRequest
 */
export interface NewResponseTemplateTypeRequest {
    /**
     * 
     * @type {string}
     * @memberof NewResponseTemplateTypeRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewResponseTemplateTypeRequest
     */
    nativeName: string;
    /**
     * 
     * @type {string}
     * @memberof NewResponseTemplateTypeRequest
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof NewResponseTemplateTypeRequest
     */
    assistant: string;
    /**
     * 
     * @type {string}
     * @memberof NewResponseTemplateTypeRequest
     */
    iconUrl: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewResponseTemplateTypeRequest
     */
    usesVideo: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NewResponseTemplateTypeRequest
     */
    usesAudio: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NewResponseTemplateTypeRequest
     */
    usesBackgroundImage: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NewResponseTemplateTypeRequest
     */
    usesForegroundImage: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NewResponseTemplateTypeRequest
     */
    usesDisplayText: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NewResponseTemplateTypeRequest
     */
    usesDisplayTitle: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NewResponseTemplateTypeRequest
     */
    usesReadout: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NewResponseTemplateTypeRequest
     */
    requiresVideo: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NewResponseTemplateTypeRequest
     */
    requiresAudio: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NewResponseTemplateTypeRequest
     */
    requiresBackgroundImage: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NewResponseTemplateTypeRequest
     */
    requiresForegroundImage: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NewResponseTemplateTypeRequest
     */
    requiresDisplayText: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NewResponseTemplateTypeRequest
     */
    requiresDisplayTitle: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NewResponseTemplateTypeRequest
     */
    requiresReadout: boolean;
}

/**
 * 
 * @export
 * @interface NewSimpleChoiceRequest
 */
export interface NewSimpleChoiceRequest {
    /**
     * 
     * @type {Array<NewSimpleChoiceResponseRequest>}
     * @memberof NewSimpleChoiceRequest
     */
    responses: Array<NewSimpleChoiceResponseRequest>;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceRequest
     */
    choiceType: NewSimpleChoiceRequest.ChoiceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceRequest
     */
    applicationId: string;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceRequest
     */
    applicationFeatureId: string;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewSimpleChoiceRequest
     */
    languageIds?: Array<string>;
}

/**
 * @export
 * @namespace NewSimpleChoiceRequest
 */
export namespace NewSimpleChoiceRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum ChoiceTypeEnum {
        Yes = <any> 'Yes',
        No = <any> 'No',
        Maybe = <any> 'Maybe'
    }
}

/**
 * 
 * @export
 * @interface NewSimpleChoiceResponseRequest
 */
export interface NewSimpleChoiceResponseRequest {
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceResponseRequest
     */
    content: string;
}

/**
 * 
 * @export
 * @interface NewSimpleChoiceStubRequest
 */
export interface NewSimpleChoiceStubRequest {
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceStubRequest
     */
    applicationId: string;
    /**
     * 
     * @type {Array<NewSimpleChoiceResponseRequest>}
     * @memberof NewSimpleChoiceStubRequest
     */
    responses?: Array<NewSimpleChoiceResponseRequest>;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceStubRequest
     */
    applicationFeatureId: string;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceStubRequest
     */
    choiceType?: NewSimpleChoiceStubRequest.ChoiceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceStubRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceStubRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceStubRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceStubRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceStubRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceStubRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceStubRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceStubRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceStubRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSimpleChoiceStubRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewSimpleChoiceStubRequest
     */
    languageIds?: Array<string>;
}

/**
 * @export
 * @namespace NewSimpleChoiceStubRequest
 */
export namespace NewSimpleChoiceStubRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum ChoiceTypeEnum {
        Yes = <any> 'Yes',
        No = <any> 'No',
        Maybe = <any> 'Maybe'
    }
}

/**
 * 
 * @export
 * @interface NewSkillResponse
 */
export interface NewSkillResponse {
    /**
     * 
     * @type {string}
     * @memberof NewSkillResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof NewSkillResponse
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface NewUserRequest
 */
export interface NewUserRequest {
    /**
     * 
     * @type {string}
     * @memberof NewUserRequest
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof NewUserRequest
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof NewUserRequest
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof NewUserRequest
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof NewUserRequest
     */
    confirmPassword: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewUserRequest
     */
    agreedToTerms: boolean;
}

/**
 * 
 * @export
 * @interface NewUserTermRequestModel
 */
export interface NewUserTermRequestModel {
    /**
     * 
     * @type {string}
     * @memberof NewUserTermRequestModel
     */
    termId: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewUserTermRequestModel
     */
    agreed: boolean;
}

/**
 * 
 * @export
 * @interface NewWebhookParameterRequest
 */
export interface NewWebhookParameterRequest {
    /**
     * 
     * @type {string}
     * @memberof NewWebhookParameterRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NewWebhookParameterRequest
     */
    description: string;
}

/**
 * 
 * @export
 * @interface NewWebhookRequest
 */
export interface NewWebhookRequest {
    /**
     * 
     * @type {string}
     * @memberof NewWebhookRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof NewWebhookRequest
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof NewWebhookRequest
     */
    webhookTypeId: string;
    /**
     * 
     * @type {string}
     * @memberof NewWebhookRequest
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof NewWebhookRequest
     */
    accessToken?: string;
}

/**
 * 
 * @export
 * @interface NewWelcomeMessageRequest
 */
export interface NewWelcomeMessageRequest {
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageRequest
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageRequest
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageRequest
     */
    applicationFeatureId: string;
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewWelcomeMessageRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewWelcomeMessageRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface NewWelcomeMessageStubRequest
 */
export interface NewWelcomeMessageStubRequest {
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageStubRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageStubRequest
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageStubRequest
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageStubRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageStubRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageStubRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageStubRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageStubRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageStubRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageStubRequest
     */
    applicationFeatureId: string;
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageStubRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageStubRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof NewWelcomeMessageStubRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NewWelcomeMessageStubRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof NewWelcomeMessageStubRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface NumberRangeExportModel
 */
export interface NumberRangeExportModel {
    /**
     * 
     * @type {string}
     * @memberof NumberRangeExportModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof NumberRangeExportModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof NumberRangeExportModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {string}
     * @memberof NumberRangeExportModel
     */
    title?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NumberRangeExportModel
     */
    isLive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NumberRangeExportModel
     */
    applicationModuleId?: string;
    /**
     * 
     * @type {Array<NumberRangeResponseModel>}
     * @memberof NumberRangeExportModel
     */
    responses?: Array<NumberRangeResponseModel>;
    /**
     * 
     * @type {Array<NumberRangeWebhookModel>}
     * @memberof NumberRangeExportModel
     */
    numberRangeWebhooks?: Array<NumberRangeWebhookModel>;
    /**
     * 
     * @type {number}
     * @memberof NumberRangeExportModel
     */
    hits?: number;
    /**
     * 
     * @type {Date}
     * @memberof NumberRangeExportModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof NumberRangeExportModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {number}
     * @memberof NumberRangeExportModel
     */
    minimumValue?: number;
    /**
     * 
     * @type {number}
     * @memberof NumberRangeExportModel
     */
    maximumValue?: number;
    /**
     * 
     * @type {boolean}
     * @memberof NumberRangeExportModel
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NumberRangeExportModel
     */
    isComplete?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NumberRangeExportModel
     */
    createdFromId?: string;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof NumberRangeExportModel
     */
    languages?: Array<LanguageModel>;
}

/**
 * 
 * @export
 * @interface NumberRangeModel
 */
export interface NumberRangeModel {
    /**
     * 
     * @type {string}
     * @memberof NumberRangeModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof NumberRangeModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof NumberRangeModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {string}
     * @memberof NumberRangeModel
     */
    title?: string;
    /**
     * 
     * @type {boolean}
     * @memberof NumberRangeModel
     */
    isLive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NumberRangeModel
     */
    applicationModuleId?: string;
    /**
     * 
     * @type {Array<NumberRangeResponseModel>}
     * @memberof NumberRangeModel
     */
    responses?: Array<NumberRangeResponseModel>;
    /**
     * 
     * @type {Array<NumberRangeWebhookModel>}
     * @memberof NumberRangeModel
     */
    numberRangeWebhooks?: Array<NumberRangeWebhookModel>;
    /**
     * 
     * @type {number}
     * @memberof NumberRangeModel
     */
    hits?: number;
    /**
     * 
     * @type {Date}
     * @memberof NumberRangeModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof NumberRangeModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {number}
     * @memberof NumberRangeModel
     */
    minimumValue?: number;
    /**
     * 
     * @type {number}
     * @memberof NumberRangeModel
     */
    maximumValue?: number;
    /**
     * 
     * @type {boolean}
     * @memberof NumberRangeModel
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NumberRangeModel
     */
    isComplete?: boolean;
    /**
     * 
     * @type {string}
     * @memberof NumberRangeModel
     */
    createdFromId?: string;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof NumberRangeModel
     */
    languages?: Array<LanguageModel>;
}

/**
 * 
 * @export
 * @interface NumberRangeResponseModel
 */
export interface NumberRangeResponseModel {
    /**
     * 
     * @type {string}
     * @memberof NumberRangeResponseModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof NumberRangeResponseModel
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof NumberRangeResponseModel
     */
    numberRangeId?: string;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof NumberRangeResponseModel
     */
    smallImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof NumberRangeResponseModel
     */
    largeImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof NumberRangeResponseModel
     */
    backgroundImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof NumberRangeResponseModel
     */
    audio?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof NumberRangeResponseModel
     */
    video?: MediaItemModel;
    /**
     * 
     * @type {RepromptModel}
     * @memberof NumberRangeResponseModel
     */
    reprompt?: RepromptModel;
    /**
     * 
     * @type {string}
     * @memberof NumberRangeResponseModel
     */
    repromptId?: string;
    /**
     * 
     * @type {MediaResponseContainerModel}
     * @memberof NumberRangeResponseModel
     */
    mediaResponseContainer?: MediaResponseContainerModel;
    /**
     * 
     * @type {FollowUpModel}
     * @memberof NumberRangeResponseModel
     */
    followUp?: FollowUpModel;
    /**
     * 
     * @type {Date}
     * @memberof NumberRangeResponseModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof NumberRangeResponseModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof NumberRangeResponseModel
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof NumberRangeResponseModel
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof NumberRangeResponseModel
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof NumberRangeResponseModel
     */
    followUpId?: string;
}

/**
 * 
 * @export
 * @interface NumberRangeWebhookModel
 */
export interface NumberRangeWebhookModel {
    /**
     * 
     * @type {string}
     * @memberof NumberRangeWebhookModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof NumberRangeWebhookModel
     */
    numberRangeId?: string;
    /**
     * 
     * @type {WebhookModel}
     * @memberof NumberRangeWebhookModel
     */
    webhook?: WebhookModel;
    /**
     * 
     * @type {Array<WebhookParameterValueModel>}
     * @memberof NumberRangeWebhookModel
     */
    parameterValues?: Array<WebhookParameterValueModel>;
}

/**
 * 
 * @export
 * @interface OrganizationMemberModel
 */
export interface OrganizationMemberModel {
    /**
     * 
     * @type {string}
     * @memberof OrganizationMemberModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationMemberModel
     */
    organizationId?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationMemberModel
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationMemberModel
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationMemberModel
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationMemberModel
     */
    lastName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationMemberModel
     */
    isAdmin?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrganizationMemberModel
     */
    canEdit?: boolean;
    /**
     * 
     * @type {string}
     * @memberof OrganizationMemberModel
     */
    imageUrl?: string;
}

/**
 * 
 * @export
 * @interface OrganizationModel
 */
export interface OrganizationModel {
    /**
     * 
     * @type {string}
     * @memberof OrganizationModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationModel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganizationModel
     */
    description?: string;
    /**
     * 
     * @type {Array<SubscriptionModel>}
     * @memberof OrganizationModel
     */
    subscriptions?: Array<SubscriptionModel>;
    /**
     * 
     * @type {string}
     * @memberof OrganizationModel
     */
    secret?: string;
}

/**
 * 
 * @export
 * @interface ParentContentContainerModel
 */
export interface ParentContentContainerModel {
    /**
     * 
     * @type {Array<WelcomeMessageModel>}
     * @memberof ParentContentContainerModel
     */
    welcomeMessages?: Array<WelcomeMessageModel>;
    /**
     * 
     * @type {Array<HelpMessageModel>}
     * @memberof ParentContentContainerModel
     */
    helpMessages?: Array<HelpMessageModel>;
    /**
     * 
     * @type {Array<FallbackMessageModel>}
     * @memberof ParentContentContainerModel
     */
    fallbackMessages?: Array<FallbackMessageModel>;
    /**
     * 
     * @type {Array<ExitMessageModel>}
     * @memberof ParentContentContainerModel
     */
    exitMessages?: Array<ExitMessageModel>;
    /**
     * 
     * @type {Array<QuestionAnswerModel>}
     * @memberof ParentContentContainerModel
     */
    questionAnswers?: Array<QuestionAnswerModel>;
    /**
     * 
     * @type {Array<LatestMessageModel>}
     * @memberof ParentContentContainerModel
     */
    latestMessages?: Array<LatestMessageModel>;
    /**
     * 
     * @type {Array<EventItemModel>}
     * @memberof ParentContentContainerModel
     */
    eventItems?: Array<EventItemModel>;
    /**
     * 
     * @type {Array<RecipeModel>}
     * @memberof ParentContentContainerModel
     */
    recipes?: Array<RecipeModel>;
    /**
     * 
     * @type {Array<SimpleChoiceModel>}
     * @memberof ParentContentContainerModel
     */
    simpleChoices?: Array<SimpleChoiceModel>;
    /**
     * 
     * @type {Array<NumberRangeModel>}
     * @memberof ParentContentContainerModel
     */
    numberRanges?: Array<NumberRangeModel>;
    /**
     * 
     * @type {Array<CustomRequestModel>}
     * @memberof ParentContentContainerModel
     */
    customRequests?: Array<CustomRequestModel>;
    /**
     * 
     * @type {Array<GenericContentModel>}
     * @memberof ParentContentContainerModel
     */
    contentItems?: Array<GenericContentModel>;
}

/**
 * 
 * @export
 * @interface PasswordResetModel
 */
export interface PasswordResetModel {
    /**
     * 
     * @type {string}
     * @memberof PasswordResetModel
     */
    id?: string;
    /**
     * 
     * @type {Date}
     * @memberof PasswordResetModel
     */
    createdDate?: Date;
}

/**
 * 
 * @export
 * @interface ProcessedLanguage
 */
export interface ProcessedLanguage {
    /**
     * 
     * @type {string}
     * @memberof ProcessedLanguage
     */
    intent?: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessedLanguage
     */
    intentDisplayName?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ProcessedLanguage
     */
    slots?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ProcessedLanguage
     */
    utteranceMatched?: string;
}

/**
 * 
 * @export
 * @interface QuestionAnswerExportModel
 */
export interface QuestionAnswerExportModel {
    /**
     * 
     * @type {string}
     * @memberof QuestionAnswerExportModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionAnswerExportModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionAnswerExportModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionAnswerExportModel
     */
    isLive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof QuestionAnswerExportModel
     */
    title?: string;
    /**
     * 
     * @type {Date}
     * @memberof QuestionAnswerExportModel
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof QuestionAnswerExportModel
     */
    endDate?: Date;
    /**
     * 
     * @type {Array<AnswerModel>}
     * @memberof QuestionAnswerExportModel
     */
    responses?: Array<AnswerModel>;
    /**
     * 
     * @type {Array<QuestionModel>}
     * @memberof QuestionAnswerExportModel
     */
    questionSet?: Array<QuestionModel>;
    /**
     * 
     * @type {number}
     * @memberof QuestionAnswerExportModel
     */
    hits?: number;
    /**
     * 
     * @type {Date}
     * @memberof QuestionAnswerExportModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof QuestionAnswerExportModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionAnswerExportModel
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionAnswerExportModel
     */
    isComplete?: boolean;
    /**
     * 
     * @type {string}
     * @memberof QuestionAnswerExportModel
     */
    createdFromId?: string;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof QuestionAnswerExportModel
     */
    languages?: Array<LanguageModel>;
    /**
     * 
     * @type {Array<QuestionAnswerWebhookModel>}
     * @memberof QuestionAnswerExportModel
     */
    questionAnswerWebhooks?: Array<QuestionAnswerWebhookModel>;
}

/**
 * 
 * @export
 * @interface QuestionAnswerModel
 */
export interface QuestionAnswerModel {
    /**
     * 
     * @type {string}
     * @memberof QuestionAnswerModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionAnswerModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionAnswerModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionAnswerModel
     */
    isLive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof QuestionAnswerModel
     */
    title?: string;
    /**
     * 
     * @type {Date}
     * @memberof QuestionAnswerModel
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof QuestionAnswerModel
     */
    endDate?: Date;
    /**
     * 
     * @type {Array<AnswerModel>}
     * @memberof QuestionAnswerModel
     */
    responses?: Array<AnswerModel>;
    /**
     * 
     * @type {Array<QuestionModel>}
     * @memberof QuestionAnswerModel
     */
    questionSet?: Array<QuestionModel>;
    /**
     * 
     * @type {number}
     * @memberof QuestionAnswerModel
     */
    hits?: number;
    /**
     * 
     * @type {Date}
     * @memberof QuestionAnswerModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof QuestionAnswerModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionAnswerModel
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionAnswerModel
     */
    isComplete?: boolean;
    /**
     * 
     * @type {string}
     * @memberof QuestionAnswerModel
     */
    createdFromId?: string;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof QuestionAnswerModel
     */
    languages?: Array<LanguageModel>;
    /**
     * 
     * @type {Array<QuestionAnswerWebhookModel>}
     * @memberof QuestionAnswerModel
     */
    questionAnswerWebhooks?: Array<QuestionAnswerWebhookModel>;
}

/**
 * 
 * @export
 * @interface QuestionAnswerWebhookModel
 */
export interface QuestionAnswerWebhookModel {
    /**
     * 
     * @type {string}
     * @memberof QuestionAnswerWebhookModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionAnswerWebhookModel
     */
    questionAnswerId?: string;
    /**
     * 
     * @type {WebhookModel}
     * @memberof QuestionAnswerWebhookModel
     */
    webhook?: WebhookModel;
    /**
     * 
     * @type {Array<WebhookParameterValueModel>}
     * @memberof QuestionAnswerWebhookModel
     */
    parameterValues?: Array<WebhookParameterValueModel>;
}

/**
 * 
 * @export
 * @interface QuestionModel
 */
export interface QuestionModel {
    /**
     * 
     * @type {string}
     * @memberof QuestionModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionModel
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionModel
     */
    applicationModuleId?: string;
    /**
     * 
     * @type {string}
     * @memberof QuestionModel
     */
    questionAnswerId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionModel
     */
    isLive?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionModel
     */
    isComplete?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof QuestionModel
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestionModel
     */
    languageIds?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof QuestionModel
     */
    requiredPhrases?: Array<string>;
}

/**
 * 
 * @export
 * @interface QueuedInteractionModelUpdate
 */
export interface QueuedInteractionModelUpdate {
    /**
     * 
     * @type {Date}
     * @memberof QueuedInteractionModelUpdate
     */
    createdDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof QueuedInteractionModelUpdate
     */
    platform?: string;
    /**
     * 
     * @type {string}
     * @memberof QueuedInteractionModelUpdate
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof QueuedInteractionModelUpdate
     */
    locale?: string;
    /**
     * 
     * @type {string}
     * @memberof QueuedInteractionModelUpdate
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof QueuedInteractionModelUpdate
     */
    retryCount?: number;
    /**
     * 
     * @type {string}
     * @memberof QueuedInteractionModelUpdate
     */
    actions?: string;
}

/**
 * 
 * @export
 * @interface RecipeExportModel
 */
export interface RecipeExportModel {
    /**
     * 
     * @type {string}
     * @memberof RecipeExportModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeExportModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeExportModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeExportModel
     */
    title?: string;
    /**
     * 
     * @type {number}
     * @memberof RecipeExportModel
     */
    hits?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeExportModel
     */
    isLive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RecipeExportModel
     */
    applicationModuleId?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeExportModel
     */
    recipeName?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeExportModel
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeExportModel
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeExportModel
     */
    mealType?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeExportModel
     */
    servings?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeExportModel
     */
    totalTime?: string;
    /**
     * 
     * @type {number}
     * @memberof RecipeExportModel
     */
    calories?: number;
    /**
     * 
     * @type {Date}
     * @memberof RecipeExportModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof RecipeExportModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof RecipeExportModel
     */
    smallImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof RecipeExportModel
     */
    largeImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof RecipeExportModel
     */
    backgroundImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof RecipeExportModel
     */
    audio?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof RecipeExportModel
     */
    video?: MediaItemModel;
    /**
     * 
     * @type {MediaResponseContainerModel}
     * @memberof RecipeExportModel
     */
    mediaResponseContainer?: MediaResponseContainerModel;
    /**
     * 
     * @type {string}
     * @memberof RecipeExportModel
     */
    content?: string;
    /**
     * 
     * @type {Array<RecipeIngredientModel>}
     * @memberof RecipeExportModel
     */
    ingredients?: Array<RecipeIngredientModel>;
    /**
     * 
     * @type {Array<RecipeStepModel>}
     * @memberof RecipeExportModel
     */
    steps?: Array<RecipeStepModel>;
    /**
     * 
     * @type {Array<RecipeWebhookModel>}
     * @memberof RecipeExportModel
     */
    recipeWebhooks?: Array<RecipeWebhookModel>;
    /**
     * 
     * @type {string}
     * @memberof RecipeExportModel
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeExportModel
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeExportModel
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeExportModel
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeExportModel
     */
    isComplete?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RecipeExportModel
     */
    createdFromId?: string;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof RecipeExportModel
     */
    languages?: Array<LanguageModel>;
}

/**
 * 
 * @export
 * @interface RecipeIngredientModel
 */
export interface RecipeIngredientModel {
    /**
     * 
     * @type {string}
     * @memberof RecipeIngredientModel
     */
    id?: string;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof RecipeIngredientModel
     */
    smallImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof RecipeIngredientModel
     */
    largeImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof RecipeIngredientModel
     */
    backgroundImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof RecipeIngredientModel
     */
    audio?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof RecipeIngredientModel
     */
    video?: MediaItemModel;
    /**
     * 
     * @type {MediaResponseContainerModel}
     * @memberof RecipeIngredientModel
     */
    mediaResponseContainer?: MediaResponseContainerModel;
    /**
     * 
     * @type {string}
     * @memberof RecipeIngredientModel
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeIngredientModel
     */
    recipeId?: string;
    /**
     * 
     * @type {RepromptModel}
     * @memberof RecipeIngredientModel
     */
    reprompt?: RepromptModel;
    /**
     * 
     * @type {Date}
     * @memberof RecipeIngredientModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof RecipeIngredientModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof RecipeIngredientModel
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeIngredientModel
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeIngredientModel
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeIngredientModel
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeIngredientModel
     */
    followUpId?: string;
    /**
     * 
     * @type {number}
     * @memberof RecipeIngredientModel
     */
    position?: number;
}

/**
 * 
 * @export
 * @interface RecipeModel
 */
export interface RecipeModel {
    /**
     * 
     * @type {string}
     * @memberof RecipeModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeModel
     */
    title?: string;
    /**
     * 
     * @type {number}
     * @memberof RecipeModel
     */
    hits?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeModel
     */
    isLive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RecipeModel
     */
    applicationModuleId?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeModel
     */
    recipeName?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeModel
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeModel
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeModel
     */
    mealType?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeModel
     */
    servings?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeModel
     */
    totalTime?: string;
    /**
     * 
     * @type {number}
     * @memberof RecipeModel
     */
    calories?: number;
    /**
     * 
     * @type {Date}
     * @memberof RecipeModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof RecipeModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof RecipeModel
     */
    smallImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof RecipeModel
     */
    largeImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof RecipeModel
     */
    backgroundImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof RecipeModel
     */
    audio?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof RecipeModel
     */
    video?: MediaItemModel;
    /**
     * 
     * @type {MediaResponseContainerModel}
     * @memberof RecipeModel
     */
    mediaResponseContainer?: MediaResponseContainerModel;
    /**
     * 
     * @type {string}
     * @memberof RecipeModel
     */
    content?: string;
    /**
     * 
     * @type {Array<RecipeIngredientModel>}
     * @memberof RecipeModel
     */
    ingredients?: Array<RecipeIngredientModel>;
    /**
     * 
     * @type {Array<RecipeStepModel>}
     * @memberof RecipeModel
     */
    steps?: Array<RecipeStepModel>;
    /**
     * 
     * @type {Array<RecipeWebhookModel>}
     * @memberof RecipeModel
     */
    recipeWebhooks?: Array<RecipeWebhookModel>;
    /**
     * 
     * @type {string}
     * @memberof RecipeModel
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeModel
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeModel
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeModel
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeModel
     */
    isComplete?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RecipeModel
     */
    createdFromId?: string;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof RecipeModel
     */
    languages?: Array<LanguageModel>;
}

/**
 * 
 * @export
 * @interface RecipeStepModel
 */
export interface RecipeStepModel {
    /**
     * 
     * @type {string}
     * @memberof RecipeStepModel
     */
    id?: string;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof RecipeStepModel
     */
    smallImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof RecipeStepModel
     */
    largeImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof RecipeStepModel
     */
    backgroundImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof RecipeStepModel
     */
    audio?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof RecipeStepModel
     */
    video?: MediaItemModel;
    /**
     * 
     * @type {MediaResponseContainerModel}
     * @memberof RecipeStepModel
     */
    mediaResponseContainer?: MediaResponseContainerModel;
    /**
     * 
     * @type {string}
     * @memberof RecipeStepModel
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeStepModel
     */
    recipeId?: string;
    /**
     * 
     * @type {number}
     * @memberof RecipeStepModel
     */
    stepNumber?: number;
    /**
     * 
     * @type {RepromptModel}
     * @memberof RecipeStepModel
     */
    reprompt?: RepromptModel;
    /**
     * 
     * @type {Date}
     * @memberof RecipeStepModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof RecipeStepModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof RecipeStepModel
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeStepModel
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeStepModel
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeStepModel
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeStepModel
     */
    followUpId?: string;
}

/**
 * 
 * @export
 * @interface RecipeWebhookModel
 */
export interface RecipeWebhookModel {
    /**
     * 
     * @type {string}
     * @memberof RecipeWebhookModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeWebhookModel
     */
    recipeId?: string;
    /**
     * 
     * @type {WebhookModel}
     * @memberof RecipeWebhookModel
     */
    webhook?: WebhookModel;
    /**
     * 
     * @type {Array<WebhookParameterValueModel>}
     * @memberof RecipeWebhookModel
     */
    parameterValues?: Array<WebhookParameterValueModel>;
}

/**
 * 
 * @export
 * @interface RepromptModel
 */
export interface RepromptModel {
    /**
     * 
     * @type {string}
     * @memberof RepromptModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof RepromptModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof RepromptModel
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof RepromptModel
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RepromptModel
     */
    includeFollowUp?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RepromptModel
     */
    createdFromId?: string;
}

/**
 * 
 * @export
 * @interface RequiredPhrasesRequest
 */
export interface RequiredPhrasesRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof RequiredPhrasesRequest
     */
    phrases: Array<string>;
}

/**
 * 
 * @export
 * @interface ResetRequest
 */
export interface ResetRequest {
    /**
     * 
     * @type {string}
     * @memberof ResetRequest
     */
    email: string;
}

/**
 * 
 * @export
 * @interface ResponseTemplateTypeModel
 */
export interface ResponseTemplateTypeModel {
    /**
     * 
     * @type {string}
     * @memberof ResponseTemplateTypeModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseTemplateTypeModel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseTemplateTypeModel
     */
    nativeName?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseTemplateTypeModel
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseTemplateTypeModel
     */
    assistant?: string;
    /**
     * 
     * @type {string}
     * @memberof ResponseTemplateTypeModel
     */
    iconUrl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseTemplateTypeModel
     */
    isDisabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseTemplateTypeModel
     */
    usesVideo?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseTemplateTypeModel
     */
    usesAudio?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseTemplateTypeModel
     */
    usesBackgroundImage?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseTemplateTypeModel
     */
    usesForegroundImage?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseTemplateTypeModel
     */
    usesDisplayText?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseTemplateTypeModel
     */
    usesDisplayTitle?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseTemplateTypeModel
     */
    usesReadout?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseTemplateTypeModel
     */
    usesCustomMarkup?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseTemplateTypeModel
     */
    requiresVideo?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseTemplateTypeModel
     */
    requiresAudio?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseTemplateTypeModel
     */
    requiresBackgroundImage?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseTemplateTypeModel
     */
    requiresForegroundImage?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseTemplateTypeModel
     */
    requiresDisplayText?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseTemplateTypeModel
     */
    requiresDisplayTitle?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseTemplateTypeModel
     */
    requiresReadout?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResponseTemplateTypeModel
     */
    requiresCustomMarkup?: boolean;
}

/**
 * 
 * @export
 * @interface SharedReferencesExportModel
 */
export interface SharedReferencesExportModel {
    /**
     * 
     * @type {Array<MediaItemModel>}
     * @memberof SharedReferencesExportModel
     */
    mediaItems?: Array<MediaItemModel>;
    /**
     * 
     * @type {Array<MediaResponseModel>}
     * @memberof SharedReferencesExportModel
     */
    mediaResponses?: Array<MediaResponseModel>;
    /**
     * 
     * @type {Array<MediaResponseContainerModel>}
     * @memberof SharedReferencesExportModel
     */
    mediaResponseContainers?: Array<MediaResponseContainerModel>;
    /**
     * 
     * @type {Array<FollowUpModel>}
     * @memberof SharedReferencesExportModel
     */
    followUps?: Array<FollowUpModel>;
    /**
     * 
     * @type {Array<RepromptModel>}
     * @memberof SharedReferencesExportModel
     */
    reprompts?: Array<RepromptModel>;
    /**
     * 
     * @type {Array<WebhookParameterModel>}
     * @memberof SharedReferencesExportModel
     */
    webhookParameters?: Array<WebhookParameterModel>;
    /**
     * 
     * @type {Array<WebhookModel>}
     * @memberof SharedReferencesExportModel
     */
    webhooks?: Array<WebhookModel>;
}

/**
 * 
 * @export
 * @interface SimpleChoiceExportModel
 */
export interface SimpleChoiceExportModel {
    /**
     * 
     * @type {string}
     * @memberof SimpleChoiceExportModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleChoiceExportModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleChoiceExportModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleChoiceExportModel
     */
    title?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleChoiceExportModel
     */
    isLive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SimpleChoiceExportModel
     */
    applicationModuleId?: string;
    /**
     * 
     * @type {Array<SimpleChoiceResponseModel>}
     * @memberof SimpleChoiceExportModel
     */
    responses?: Array<SimpleChoiceResponseModel>;
    /**
     * 
     * @type {number}
     * @memberof SimpleChoiceExportModel
     */
    hits?: number;
    /**
     * 
     * @type {Date}
     * @memberof SimpleChoiceExportModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SimpleChoiceExportModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof SimpleChoiceExportModel
     */
    choiceType?: SimpleChoiceExportModel.ChoiceTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleChoiceExportModel
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleChoiceExportModel
     */
    isComplete?: boolean;
    /**
     * 
     * @type {Array<SimpleChoiceWebhookModel>}
     * @memberof SimpleChoiceExportModel
     */
    simpleChoiceWebhooks?: Array<SimpleChoiceWebhookModel>;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof SimpleChoiceExportModel
     */
    languages?: Array<LanguageModel>;
    /**
     * 
     * @type {string}
     * @memberof SimpleChoiceExportModel
     */
    createdFromId?: string;
}

/**
 * @export
 * @namespace SimpleChoiceExportModel
 */
export namespace SimpleChoiceExportModel {
    /**
     * @export
     * @enum {string}
     */
    export enum ChoiceTypeEnum {
        Yes = <any> 'Yes',
        No = <any> 'No',
        Maybe = <any> 'Maybe'
    }
}

/**
 * 
 * @export
 * @interface SimpleChoiceModel
 */
export interface SimpleChoiceModel {
    /**
     * 
     * @type {string}
     * @memberof SimpleChoiceModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleChoiceModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleChoiceModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleChoiceModel
     */
    title?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleChoiceModel
     */
    isLive?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SimpleChoiceModel
     */
    applicationModuleId?: string;
    /**
     * 
     * @type {Array<SimpleChoiceResponseModel>}
     * @memberof SimpleChoiceModel
     */
    responses?: Array<SimpleChoiceResponseModel>;
    /**
     * 
     * @type {number}
     * @memberof SimpleChoiceModel
     */
    hits?: number;
    /**
     * 
     * @type {Date}
     * @memberof SimpleChoiceModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SimpleChoiceModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof SimpleChoiceModel
     */
    choiceType?: SimpleChoiceModel.ChoiceTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleChoiceModel
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SimpleChoiceModel
     */
    isComplete?: boolean;
    /**
     * 
     * @type {Array<SimpleChoiceWebhookModel>}
     * @memberof SimpleChoiceModel
     */
    simpleChoiceWebhooks?: Array<SimpleChoiceWebhookModel>;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof SimpleChoiceModel
     */
    languages?: Array<LanguageModel>;
    /**
     * 
     * @type {string}
     * @memberof SimpleChoiceModel
     */
    createdFromId?: string;
}

/**
 * @export
 * @namespace SimpleChoiceModel
 */
export namespace SimpleChoiceModel {
    /**
     * @export
     * @enum {string}
     */
    export enum ChoiceTypeEnum {
        Yes = <any> 'Yes',
        No = <any> 'No',
        Maybe = <any> 'Maybe'
    }
}

/**
 * 
 * @export
 * @interface SimpleChoiceResponseModel
 */
export interface SimpleChoiceResponseModel {
    /**
     * 
     * @type {string}
     * @memberof SimpleChoiceResponseModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleChoiceResponseModel
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleChoiceResponseModel
     */
    simpleChoiceId?: string;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof SimpleChoiceResponseModel
     */
    smallImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof SimpleChoiceResponseModel
     */
    largeImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof SimpleChoiceResponseModel
     */
    backgroundImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof SimpleChoiceResponseModel
     */
    audio?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof SimpleChoiceResponseModel
     */
    video?: MediaItemModel;
    /**
     * 
     * @type {MediaResponseContainerModel}
     * @memberof SimpleChoiceResponseModel
     */
    mediaResponseContainer?: MediaResponseContainerModel;
    /**
     * 
     * @type {RepromptModel}
     * @memberof SimpleChoiceResponseModel
     */
    reprompt?: RepromptModel;
    /**
     * 
     * @type {FollowUpModel}
     * @memberof SimpleChoiceResponseModel
     */
    followUp?: FollowUpModel;
    /**
     * 
     * @type {Date}
     * @memberof SimpleChoiceResponseModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SimpleChoiceResponseModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof SimpleChoiceResponseModel
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleChoiceResponseModel
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleChoiceResponseModel
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleChoiceResponseModel
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleChoiceResponseModel
     */
    repromptId?: string;
}

/**
 * 
 * @export
 * @interface SimpleChoiceWebhookModel
 */
export interface SimpleChoiceWebhookModel {
    /**
     * 
     * @type {string}
     * @memberof SimpleChoiceWebhookModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SimpleChoiceWebhookModel
     */
    simpleChoiceId?: string;
    /**
     * 
     * @type {WebhookModel}
     * @memberof SimpleChoiceWebhookModel
     */
    webhook?: WebhookModel;
    /**
     * 
     * @type {Array<WebhookParameterValueModel>}
     * @memberof SimpleChoiceWebhookModel
     */
    parameterValues?: Array<WebhookParameterValueModel>;
}

/**
 * 
 * @export
 * @interface SingleSignOnRequest
 */
export interface SingleSignOnRequest {
    /**
     * 
     * @type {string}
     * @memberof SingleSignOnRequest
     */
    clientId: string;
    /**
     * 
     * @type {string}
     * @memberof SingleSignOnRequest
     */
    clientSecret: string;
    /**
     * 
     * @type {string}
     * @memberof SingleSignOnRequest
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof SingleSignOnRequest
     */
    loginCompleteUrl: string;
    /**
     * 
     * @type {string}
     * @memberof SingleSignOnRequest
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof SingleSignOnRequest
     */
    lastName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SingleSignOnRequest
     */
    agreedToTerms?: boolean;
}

/**
 * 
 * @export
 * @interface SingleSignOnResponse
 */
export interface SingleSignOnResponse {
    /**
     * 
     * @type {string}
     * @memberof SingleSignOnResponse
     */
    redirectUrl?: string;
}

/**
 * 
 * @export
 * @interface SkillSummary
 */
export interface SkillSummary {
    /**
     * 
     * @type {Date}
     * @memberof SkillSummary
     */
    lastUpdated?: Date;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SkillSummary
     */
    nameByLocale?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof SkillSummary
     */
    stage?: SkillSummary.StageEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof SkillSummary
     */
    apis?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SkillSummary
     */
    publicationStatus?: SkillSummary.PublicationStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof SkillSummary
     */
    skillId?: string;
    /**
     * 
     * @type {{ [key: string]: SkillSummaryLink; }}
     * @memberof SkillSummary
     */
    links?: { [key: string]: SkillSummaryLink; };
}

/**
 * @export
 * @namespace SkillSummary
 */
export namespace SkillSummary {
    /**
     * @export
     * @enum {string}
     */
    export enum StageEnum {
        Development = <any> 'development',
        Live = <any> 'live'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum PublicationStatusEnum {
        DEVELOPMENT = <any> 'DEVELOPMENT',
        CERTIFICATION = <any> 'CERTIFICATION',
        PUBLISHED = <any> 'PUBLISHED',
        SUPPRESSED = <any> 'SUPPRESSED',
        PULLED = <any> 'PULLED',
        HIDDEN = <any> 'HIDDEN',
        REMOVED = <any> 'REMOVED'
    }
}

/**
 * 
 * @export
 * @interface SkillSummaryLink
 */
export interface SkillSummaryLink {
    /**
     * 
     * @type {string}
     * @memberof SkillSummaryLink
     */
    href?: string;
}

/**
 * 
 * @export
 * @interface Slot
 */
export interface Slot {
    /**
     * 
     * @type {string}
     * @memberof Slot
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    required?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Slot
     */
    type?: { [key: string]: string; };
    /**
     * 
     * @type {boolean}
     * @memberof Slot
     */
    isNonIsolatable?: boolean;
}

/**
 * 
 * @export
 * @interface SpeechOutput
 */
export interface SpeechOutput {
    /**
     * 
     * @type {string}
     * @memberof SpeechOutput
     */
    rootElementType?: string;
    /**
     * 
     * @type {string}
     * @memberof SpeechOutput
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface SsmlAttribute
 */
export interface SsmlAttribute {
    /**
     * 
     * @type {string}
     * @memberof SsmlAttribute
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SsmlAttribute
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface SsmlElement
 */
export interface SsmlElement {
    /**
     * 
     * @type {string}
     * @memberof SsmlElement
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SsmlElement
     */
    name?: string;
    /**
     * 
     * @type {Array<SsmlAttribute>}
     * @memberof SsmlElement
     */
    attributes?: Array<SsmlAttribute>;
    /**
     * 
     * @type {Array<SsmlElement>}
     * @memberof SsmlElement
     */
    children?: Array<SsmlElement>;
    /**
     * 
     * @type {string}
     * @memberof SsmlElement
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface SsmlRequest
 */
export interface SsmlRequest {
    /**
     * 
     * @type {string}
     * @memberof SsmlRequest
     */
    ssml: string;
    /**
     * 
     * @type {string}
     * @memberof SsmlRequest
     */
    locale?: string;
}

/**
 * 
 * @export
 * @interface SubscriptionModel
 */
export interface SubscriptionModel {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionModel
     */
    organizationId?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionModel
     */
    subscriptionTypeId?: string;
    /**
     * 
     * @type {Date}
     * @memberof SubscriptionModel
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof SubscriptionModel
     */
    expirationDate?: Date;
    /**
     * 
     * @type {SubscriptionTypeModel}
     * @memberof SubscriptionModel
     */
    subscriptionType?: SubscriptionTypeModel;
}

/**
 * 
 * @export
 * @interface SubscriptionTypeModel
 */
export interface SubscriptionTypeModel {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionTypeModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionTypeModel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionTypeModel
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionTypeModel
     */
    maxApps?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionTypeModel
     */
    maxMembers?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionTypeModel
     */
    maxSandboxes?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionTypeModel
     */
    maxRequests?: number;
    /**
     * 
     * @type {number}
     * @memberof SubscriptionTypeModel
     */
    maxFileUploadMegabytes?: number;
    /**
     * 
     * @type {string}
     * @memberof SubscriptionTypeModel
     */
    length?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SubscriptionTypeModel
     */
    isCustom?: boolean;
}

/**
 * 
 * @export
 * @interface TemplateConfigurationModel
 */
export interface TemplateConfigurationModel {
    /**
     * 
     * @type {string}
     * @memberof TemplateConfigurationModel
     */
    id?: string;
    /**
     * 
     * @type {Date}
     * @memberof TemplateConfigurationModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof TemplateConfigurationModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof TemplateConfigurationModel
     */
    templateApplicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateConfigurationModel
     */
    templateFormId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TemplateConfigurationModel
     */
    isPublic?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TemplateConfigurationModel
     */
    isDisabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TemplateConfigurationModel
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateConfigurationModel
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateConfigurationModel
     */
    imageUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateConfigurationModel
     */
    organizationId: string;
    /**
     * 
     * @type {TemplateFormModel}
     * @memberof TemplateConfigurationModel
     */
    templateForm?: TemplateFormModel;
    /**
     * 
     * @type {ApplicationModel}
     * @memberof TemplateConfigurationModel
     */
    templateApplication?: ApplicationModel;
}

/**
 * 
 * @export
 * @interface TemplateFormFieldModel
 */
export interface TemplateFormFieldModel {
    /**
     * 
     * @type {string}
     * @memberof TemplateFormFieldModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateFormFieldModel
     */
    templateFormSectionId?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateFormFieldModel
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateFormFieldModel
     */
    fieldType: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateFormFieldModel
     */
    placeholder?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateFormFieldModel
     */
    defaultValue?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateFormFieldModel
     */
    tip?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TemplateFormFieldModel
     */
    isRequired?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TemplateFormFieldModel
     */
    instructionsMarkdown?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateFormFieldModel
     */
    title: string;
    /**
     * 
     * @type {number}
     * @memberof TemplateFormFieldModel
     */
    priority?: number;
    /**
     * 
     * @type {string}
     * @memberof TemplateFormFieldModel
     */
    associatedVariable?: string;
    /**
     * 
     * @type {Array<TemplateFormFieldOptionModel>}
     * @memberof TemplateFormFieldModel
     */
    options?: Array<TemplateFormFieldOptionModel>;
}

/**
 * 
 * @export
 * @interface TemplateFormFieldOptionModel
 */
export interface TemplateFormFieldOptionModel {
    /**
     * 
     * @type {string}
     * @memberof TemplateFormFieldOptionModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateFormFieldOptionModel
     */
    templateFormFieldId?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateFormFieldOptionModel
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateFormFieldOptionModel
     */
    value?: string;
    /**
     * 
     * @type {number}
     * @memberof TemplateFormFieldOptionModel
     */
    priority?: number;
}

/**
 * 
 * @export
 * @interface TemplateFormFieldValueModel
 */
export interface TemplateFormFieldValueModel {
    /**
     * 
     * @type {string}
     * @memberof TemplateFormFieldValueModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateFormFieldValueModel
     */
    templateFormFieldId?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateFormFieldValueModel
     */
    value?: string;
}

/**
 * 
 * @export
 * @interface TemplateFormModel
 */
export interface TemplateFormModel {
    /**
     * 
     * @type {string}
     * @memberof TemplateFormModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateFormModel
     */
    templateConfigurationId?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateFormModel
     */
    instructionsMarkdown?: string;
    /**
     * 
     * @type {Array<TemplateFormSectionModel>}
     * @memberof TemplateFormModel
     */
    templateFormSections?: Array<TemplateFormSectionModel>;
}

/**
 * 
 * @export
 * @interface TemplateFormSectionModel
 */
export interface TemplateFormSectionModel {
    /**
     * 
     * @type {string}
     * @memberof TemplateFormSectionModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateFormSectionModel
     */
    templateFormId?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateFormSectionModel
     */
    instructionsMarkdown?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateFormSectionModel
     */
    title: string;
    /**
     * 
     * @type {number}
     * @memberof TemplateFormSectionModel
     */
    priority?: number;
    /**
     * 
     * @type {Array<TemplateFormFieldModel>}
     * @memberof TemplateFormSectionModel
     */
    templateFormFields?: Array<TemplateFormFieldModel>;
}

/**
 * 
 * @export
 * @interface TemplateFormWithConfigurationModel
 */
export interface TemplateFormWithConfigurationModel {
    /**
     * 
     * @type {string}
     * @memberof TemplateFormWithConfigurationModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TemplateFormWithConfigurationModel
     */
    templateConfigurationId?: string;
    /**
     * 
     * @type {TemplateConfigurationModel}
     * @memberof TemplateFormWithConfigurationModel
     */
    templateConfiguration?: TemplateConfigurationModel;
    /**
     * 
     * @type {Array<TemplateFormSectionModel>}
     * @memberof TemplateFormWithConfigurationModel
     */
    templateFormSections?: Array<TemplateFormSectionModel>;
}

/**
 * 
 * @export
 * @interface TermModel
 */
export interface TermModel {
    /**
     * 
     * @type {string}
     * @memberof TermModel
     */
    id?: string;
    /**
     * 
     * @type {Date}
     * @memberof TermModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof TermModel
     */
    url?: string;
}

/**
 * 
 * @export
 * @interface ToggleLiveRequest
 */
export interface ToggleLiveRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ToggleLiveRequest
     */
    isLive: boolean;
}

/**
 * 
 * @export
 * @interface ToggleTemplateRequest
 */
export interface ToggleTemplateRequest {
    /**
     * 
     * @type {boolean}
     * @memberof ToggleTemplateRequest
     */
    isTemplate: boolean;
}

/**
 * 
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenResponse
     */
    userName?: string;
}

/**
 * 
 * @export
 * @interface UpdateAnswerRequest
 */
export interface UpdateAnswerRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateAnswerRequest
     */
    answerId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAnswerRequest
     */
    content: string;
}

/**
 * 
 * @export
 * @interface UpdateApplicationFeatureRequest
 */
export interface UpdateApplicationFeatureRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationFeatureRequest
     */
    name: string;
}

/**
 * 
 * @export
 * @interface UpdateApplicationInformationByLanguageRequest
 */
export interface UpdateApplicationInformationByLanguageRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationInformationByLanguageRequest
     */
    languageId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationInformationByLanguageRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationInformationByLanguageRequest
     */
    shortDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationInformationByLanguageRequest
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationInformationByLanguageRequest
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationInformationByLanguageRequest
     */
    invocationPhrase?: string;
}

/**
 * 
 * @export
 * @interface UpdateApplicationModuleRequest
 */
export interface UpdateApplicationModuleRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationModuleRequest
     */
    name: string;
}

/**
 * 
 * @export
 * @interface UpdateApplicationRequest
 */
export interface UpdateApplicationRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationRequest
     */
    shortDescription?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationRequest
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationRequest
     */
    keywords?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationRequest
     */
    invocationPhrase?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateApplicationRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {Array<UpdateApplicationInformationByLanguageRequest>}
     * @memberof UpdateApplicationRequest
     */
    applicationInformationItems?: Array<UpdateApplicationInformationByLanguageRequest>;
}

/**
 * 
 * @export
 * @interface UpdateAppliedApplicationTemplateFormRequest
 */
export interface UpdateAppliedApplicationTemplateFormRequest {
    /**
     * 
     * @type {Array<TemplateFormFieldValueModel>}
     * @memberof UpdateAppliedApplicationTemplateFormRequest
     */
    templateFormFieldValues?: Array<TemplateFormFieldValueModel>;
}

/**
 * 
 * @export
 * @interface UpdateBulkMediaResponseContainerRequest
 */
export interface UpdateBulkMediaResponseContainerRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateBulkMediaResponseContainerRequest
     */
    additionalMediaItemIds: Array<string>;
    /**
     * 
     * @type {Array<UpdateMediaResponseRequest>}
     * @memberof UpdateBulkMediaResponseContainerRequest
     */
    responses: Array<UpdateMediaResponseRequest>;
}

/**
 * 
 * @export
 * @interface UpdateChildContentContainerRequest
 */
export interface UpdateChildContentContainerRequest {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateChildContentContainerRequest
     */
    isLimitedToChildren?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateChildContentContainerRequest
     */
    applicationId?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateChildContentContainerRequest
     */
    questionAnswerIds?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateChildContentContainerRequest
     */
    latestMessageIds?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateChildContentContainerRequest
     */
    eventItemIds?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateChildContentContainerRequest
     */
    recipeIds?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateChildContentContainerRequest
     */
    simpleChoiceIds?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateChildContentContainerRequest
     */
    numberRangeIds?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateChildContentContainerRequest
     */
    customRequestIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface UpdateCustomRequestRequest
 */
export interface UpdateCustomRequestRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomRequestRequest
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomRequestRequest
     */
    requestTypes?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomRequestRequest
     */
    requestNames?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomRequestRequest
     */
    platformFilter?: string;
    /**
     * 
     * @type {Date}
     * @memberof UpdateCustomRequestRequest
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UpdateCustomRequestRequest
     */
    endDate?: Date;
}

/**
 * 
 * @export
 * @interface UpdateCustomRequestResponseRequest
 */
export interface UpdateCustomRequestResponseRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomRequestResponseRequest
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCustomRequestResponseRequest
     */
    responseId?: string;
}

/**
 * 
 * @export
 * @interface UpdateEventResponseRequest
 */
export interface UpdateEventResponseRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateEventResponseRequest
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEventResponseRequest
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEventResponseRequest
     */
    eventQueryType?: UpdateEventResponseRequest.EventQueryTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UpdateEventResponseRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEventResponseRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEventResponseRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEventResponseRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEventResponseRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEventResponseRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEventResponseRequest
     */
    displayTitleOverride?: string;
}

/**
 * @export
 * @namespace UpdateEventResponseRequest
 */
export namespace UpdateEventResponseRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum EventQueryTypeEnum {
        General = <any> 'General',
        Location = <any> 'Location',
        StartDate = <any> 'StartDate',
        Status = <any> 'Status'
    }
}

/**
 * 
 * @export
 * @interface UpdateExitMessageRequest
 */
export interface UpdateExitMessageRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateExitMessageRequest
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateExitMessageRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateExitMessageRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateExitMessageRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateExitMessageRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateExitMessageRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateExitMessageRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateExitMessageRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateExitMessageRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateExitMessageRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateExitMessageRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface UpdateExitMessageStubRequest
 */
export interface UpdateExitMessageStubRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateExitMessageStubRequest
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateExitMessageStubRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateExitMessageStubRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateExitMessageStubRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateExitMessageStubRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateExitMessageStubRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateExitMessageStubRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateExitMessageStubRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateExitMessageStubRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateExitMessageStubRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateExitMessageStubRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface UpdateFallbackMessageRequest
 */
export interface UpdateFallbackMessageRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateFallbackMessageRequest
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFallbackMessageRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFallbackMessageRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFallbackMessageRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFallbackMessageRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFallbackMessageRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFallbackMessageRequest
     */
    categoryId: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFallbackMessageRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFallbackMessageRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFallbackMessageRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFallbackMessageRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFallbackMessageRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateFallbackMessageRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateFallbackMessageRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface UpdateFallbackMessageStubRequest
 */
export interface UpdateFallbackMessageStubRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateFallbackMessageStubRequest
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFallbackMessageStubRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFallbackMessageStubRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFallbackMessageStubRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFallbackMessageStubRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFallbackMessageStubRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFallbackMessageStubRequest
     */
    categoryId: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFallbackMessageStubRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFallbackMessageStubRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFallbackMessageStubRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFallbackMessageStubRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFallbackMessageStubRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateFallbackMessageStubRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateFallbackMessageStubRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface UpdateFollowUpHintRequest
 */
export interface UpdateFollowUpHintRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateFollowUpHintRequest
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFollowUpHintRequest
     */
    content: string;
}

/**
 * 
 * @export
 * @interface UpdateFollowUpRequest
 */
export interface UpdateFollowUpRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateFollowUpRequest
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFollowUpRequest
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFollowUpRequest
     */
    name?: string;
    /**
     * 
     * @type {Array<UpdateFollowUpHintRequest>}
     * @memberof UpdateFollowUpRequest
     */
    followUpHints?: Array<UpdateFollowUpHintRequest>;
    /**
     * 
     * @type {UpdateChildContentContainerRequest}
     * @memberof UpdateFollowUpRequest
     */
    childContentContainer?: UpdateChildContentContainerRequest;
    /**
     * 
     * @type {string}
     * @memberof UpdateFollowUpRequest
     */
    fallbackMessageId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFollowUpRequest
     */
    helpMessageId?: string;
}

/**
 * 
 * @export
 * @interface UpdateHelpMessageRequest
 */
export interface UpdateHelpMessageRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateHelpMessageRequest
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateHelpMessageRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateHelpMessageRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateHelpMessageRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateHelpMessageRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateHelpMessageRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateHelpMessageRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateHelpMessageRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateHelpMessageRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateHelpMessageRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateHelpMessageRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateHelpMessageRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateHelpMessageRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface UpdateHelpMessageStubRequest
 */
export interface UpdateHelpMessageStubRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateHelpMessageStubRequest
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateHelpMessageStubRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateHelpMessageStubRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateHelpMessageStubRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateHelpMessageStubRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateHelpMessageStubRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateHelpMessageStubRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateHelpMessageStubRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateHelpMessageStubRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateHelpMessageStubRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateHelpMessageStubRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateHelpMessageStubRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateHelpMessageStubRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface UpdateIngredientRequest
 */
export interface UpdateIngredientRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateIngredientRequest
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateIngredientRequest
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateIngredientRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateIngredientRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateIngredientRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateIngredientRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateIngredientRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateIngredientRequest
     */
    displayTitleOverride?: string;
}

/**
 * 
 * @export
 * @interface UpdateLatestMessageRequest
 */
export interface UpdateLatestMessageRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateLatestMessageRequest
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateLatestMessageRequest
     */
    category?: string;
    /**
     * 
     * @type {Date}
     * @memberof UpdateLatestMessageRequest
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UpdateLatestMessageRequest
     */
    endDate?: Date;
}

/**
 * 
 * @export
 * @interface UpdateLatestMessageResponseRequest
 */
export interface UpdateLatestMessageResponseRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateLatestMessageResponseRequest
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateLatestMessageResponseRequest
     */
    responseId?: string;
}

/**
 * 
 * @export
 * @interface UpdateMediaItemRequest
 */
export interface UpdateMediaItemRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateMediaItemRequest
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMediaItemRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMediaItemRequest
     */
    mediaType?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMediaItemRequest
     */
    caption?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMediaItemRequest
     */
    fileExtension?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateMediaItemRequest
     */
    isDisabled?: boolean;
}

/**
 * 
 * @export
 * @interface UpdateMediaResponseContainerRequest
 */
export interface UpdateMediaResponseContainerRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateMediaResponseContainerRequest
     */
    defaultResponseId: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateMediaResponseContainerRequest
     */
    additionalMediaItemIds: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateMediaResponseContainerRequest
     */
    responseIds: Array<string>;
}

/**
 * 
 * @export
 * @interface UpdateMediaResponseRequest
 */
export interface UpdateMediaResponseRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateMediaResponseRequest
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMediaResponseRequest
     */
    responseTemplateTypeId: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMediaResponseRequest
     */
    applicationId: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMediaResponseRequest
     */
    displayTitle?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMediaResponseRequest
     */
    displayText?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMediaResponseRequest
     */
    readoutOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMediaResponseRequest
     */
    foregroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMediaResponseRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMediaResponseRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMediaResponseRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMediaResponseRequest
     */
    deviceTargetId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMediaResponseRequest
     */
    customMarkup?: string;
}

/**
 * 
 * @export
 * @interface UpdateMicrosoftAppInfoRequest
 */
export interface UpdateMicrosoftAppInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateMicrosoftAppInfoRequest
     */
    botServiceName?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMicrosoftAppInfoRequest
     */
    microsoftAppId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateMicrosoftAppInfoRequest
     */
    microsoftAppPassword?: string;
}

/**
 * 
 * @export
 * @interface UpdateNumberRangeRequest
 */
export interface UpdateNumberRangeRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateNumberRangeRequest
     */
    title?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateNumberRangeRequest
     */
    minimumValue?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateNumberRangeRequest
     */
    maximumValue?: number;
}

/**
 * 
 * @export
 * @interface UpdateNumberRangeResponseRequest
 */
export interface UpdateNumberRangeResponseRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateNumberRangeResponseRequest
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateNumberRangeResponseRequest
     */
    responseId?: string;
}

/**
 * 
 * @export
 * @interface UpdateOrganizationRequest
 */
export interface UpdateOrganizationRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateOrganizationRequest
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface UpdateQuestionRequest
 */
export interface UpdateQuestionRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateQuestionRequest
     */
    questionId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateQuestionRequest
     */
    content: string;
}

/**
 * 
 * @export
 * @interface UpdateRepromptRequest
 */
export interface UpdateRepromptRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateRepromptRequest
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRepromptRequest
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateRepromptRequest
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateRepromptRequest
     */
    includeFollowUp?: boolean;
}

/**
 * 
 * @export
 * @interface UpdateResponseTemplateTypeRequest
 */
export interface UpdateResponseTemplateTypeRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateResponseTemplateTypeRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateResponseTemplateTypeRequest
     */
    nativeName: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateResponseTemplateTypeRequest
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateResponseTemplateTypeRequest
     */
    assistant: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateResponseTemplateTypeRequest
     */
    iconUrl: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateResponseTemplateTypeRequest
     */
    usesVideo: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateResponseTemplateTypeRequest
     */
    usesAudio: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateResponseTemplateTypeRequest
     */
    usesBackgroundImage: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateResponseTemplateTypeRequest
     */
    usesForegroundImage: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateResponseTemplateTypeRequest
     */
    usesDisplayText: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateResponseTemplateTypeRequest
     */
    usesDisplayTitle: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateResponseTemplateTypeRequest
     */
    usesReadout: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateResponseTemplateTypeRequest
     */
    requiresVideo: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateResponseTemplateTypeRequest
     */
    requiresAudio: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateResponseTemplateTypeRequest
     */
    requiresBackgroundImage: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateResponseTemplateTypeRequest
     */
    requiresForegroundImage: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateResponseTemplateTypeRequest
     */
    requiresDisplayText: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateResponseTemplateTypeRequest
     */
    requiresDisplayTitle: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateResponseTemplateTypeRequest
     */
    requiresReadout: boolean;
}

/**
 * 
 * @export
 * @interface UpdateSimpleChoiceRequest
 */
export interface UpdateSimpleChoiceRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateSimpleChoiceRequest
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSimpleChoiceRequest
     */
    choiceType?: UpdateSimpleChoiceRequest.ChoiceTypeEnum;
}

/**
 * @export
 * @namespace UpdateSimpleChoiceRequest
 */
export namespace UpdateSimpleChoiceRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum ChoiceTypeEnum {
        Yes = <any> 'Yes',
        No = <any> 'No',
        Maybe = <any> 'Maybe'
    }
}

/**
 * 
 * @export
 * @interface UpdateSimpleChoiceResponseRequest
 */
export interface UpdateSimpleChoiceResponseRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateSimpleChoiceResponseRequest
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateSimpleChoiceResponseRequest
     */
    responseId?: string;
}

/**
 * 
 * @export
 * @interface UpdateStepRequest
 */
export interface UpdateStepRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateStepRequest
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateStepRequest
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateStepRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateStepRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateStepRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateStepRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateStepRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateStepRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateStepRequest
     */
    displayTitleOverride?: string;
}

/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    firstName: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    lastName: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    changePassword?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    confirmPassword?: string;
}

/**
 * 
 * @export
 * @interface UpdateWebhookRequest
 */
export interface UpdateWebhookRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookRequest
     */
    description: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookRequest
     */
    url: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateWebhookRequest
     */
    isPublic: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateWebhookRequest
     */
    isDisabled: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookRequest
     */
    webhookTypeId: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWebhookRequest
     */
    accessToken?: string;
}

/**
 * 
 * @export
 * @interface UpdateWelcomeMessageRequest
 */
export interface UpdateWelcomeMessageRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateWelcomeMessageRequest
     */
    content: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWelcomeMessageRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWelcomeMessageRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWelcomeMessageRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWelcomeMessageRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWelcomeMessageRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWelcomeMessageRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWelcomeMessageRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWelcomeMessageRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWelcomeMessageRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWelcomeMessageRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateWelcomeMessageRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateWelcomeMessageRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface UpdateWelcomeMessageStubRequest
 */
export interface UpdateWelcomeMessageStubRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateWelcomeMessageStubRequest
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWelcomeMessageStubRequest
     */
    content?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWelcomeMessageStubRequest
     */
    imageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWelcomeMessageStubRequest
     */
    backgroundImageItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWelcomeMessageStubRequest
     */
    audioItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWelcomeMessageStubRequest
     */
    videoItemId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWelcomeMessageStubRequest
     */
    followUpId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWelcomeMessageStubRequest
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWelcomeMessageStubRequest
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWelcomeMessageStubRequest
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateWelcomeMessageStubRequest
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateWelcomeMessageStubRequest
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateWelcomeMessageStubRequest
     */
    languageIds?: Array<string>;
}

/**
 * 
 * @export
 * @interface UserDefinedWebhookParameterCreateRequest
 */
export interface UserDefinedWebhookParameterCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof UserDefinedWebhookParameterCreateRequest
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof UserDefinedWebhookParameterCreateRequest
     */
    value: string;
}

/**
 * 
 * @export
 * @interface UserDefinedWebhookParameterUpdateRequest
 */
export interface UserDefinedWebhookParameterUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof UserDefinedWebhookParameterUpdateRequest
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof UserDefinedWebhookParameterUpdateRequest
     */
    value: string;
}

/**
 * 
 * @export
 * @interface UserModel
 */
export interface UserModel {
    /**
     * 
     * @type {string}
     * @memberof UserModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserModel
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UserModel
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserModel
     */
    lastName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserModel
     */
    isAdmin?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserModel
     */
    imageUrl?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserModel
     */
    isApiUser?: boolean;
}

/**
 * 
 * @export
 * @interface UserRoleModel
 */
export interface UserRoleModel {
    /**
     * 
     * @type {string}
     * @memberof UserRoleModel
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserRoleModel
     */
    isAdmin?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserRoleModel
     */
    canEdit?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserRoleModel
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserRoleModel
     */
    isCustom?: boolean;
}

/**
 * 
 * @export
 * @interface UserTermAgreementModel
 */
export interface UserTermAgreementModel {
    /**
     * 
     * @type {Array<UserTermModel>}
     * @memberof UserTermAgreementModel
     */
    userTerms?: Array<UserTermModel>;
    /**
     * 
     * @type {boolean}
     * @memberof UserTermAgreementModel
     */
    hasAgreedToLatest?: boolean;
    /**
     * 
     * @type {TermModel}
     * @memberof UserTermAgreementModel
     */
    latestTerm?: TermModel;
}

/**
 * 
 * @export
 * @interface UserTermModel
 */
export interface UserTermModel {
    /**
     * 
     * @type {TermModel}
     * @memberof UserTermModel
     */
    term?: TermModel;
    /**
     * 
     * @type {string}
     * @memberof UserTermModel
     */
    id?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserTermModel
     */
    agreed?: boolean;
}

/**
 * 
 * @export
 * @interface UserVoicifyNotificationModel
 */
export interface UserVoicifyNotificationModel {
    /**
     * 
     * @type {boolean}
     * @memberof UserVoicifyNotificationModel
     */
    isRead?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserVoicifyNotificationModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserVoicifyNotificationModel
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof UserVoicifyNotificationModel
     */
    subtitle: string;
    /**
     * 
     * @type {string}
     * @memberof UserVoicifyNotificationModel
     */
    markdown: string;
    /**
     * 
     * @type {string}
     * @memberof UserVoicifyNotificationModel
     */
    notificationType: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserVoicifyNotificationModel
     */
    isDisabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserVoicifyNotificationModel
     */
    enforceRead?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserVoicifyNotificationModel
     */
    isSystemWide?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserVoicifyNotificationModel
     */
    imageUrl?: string;
    /**
     * 
     * @type {Date}
     * @memberof UserVoicifyNotificationModel
     */
    expirationDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof UserVoicifyNotificationModel
     */
    startDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof UserVoicifyNotificationModel
     */
    priority?: UserVoicifyNotificationModel.PriorityEnum;
}

/**
 * @export
 * @namespace UserVoicifyNotificationModel
 */
export namespace UserVoicifyNotificationModel {
    /**
     * @export
     * @enum {string}
     */
    export enum PriorityEnum {
        Low = <any> 'Low',
        Medium = <any> 'Medium',
        High = <any> 'High',
        Urgent = <any> 'Urgent'
    }
}

/**
 * 
 * @export
 * @interface WebhookModel
 */
export interface WebhookModel {
    /**
     * 
     * @type {string}
     * @memberof WebhookModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookModel
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookModel
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookModel
     */
    url?: string;
    /**
     * 
     * @type {WebhookTypeModel}
     * @memberof WebhookModel
     */
    webhookType?: WebhookTypeModel;
    /**
     * 
     * @type {string}
     * @memberof WebhookModel
     */
    organizationId?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookModel
     */
    isPublic?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WebhookModel
     */
    isDisabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WebhookModel
     */
    accessToken?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookModel
     */
    createdFromId?: string;
    /**
     * 
     * @type {Array<WebhookParameterModel>}
     * @memberof WebhookModel
     */
    parameters?: Array<WebhookParameterModel>;
}

/**
 * 
 * @export
 * @interface WebhookParameterModel
 */
export interface WebhookParameterModel {
    /**
     * 
     * @type {string}
     * @memberof WebhookParameterModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookParameterModel
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookParameterModel
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookParameterModel
     */
    webhookId?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookParameterModel
     */
    createdFromId?: string;
}

/**
 * 
 * @export
 * @interface WebhookParameterUpdateRequest
 */
export interface WebhookParameterUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof WebhookParameterUpdateRequest
     */
    webhookParameterInstanceId: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookParameterUpdateRequest
     */
    value: string;
}

/**
 * 
 * @export
 * @interface WebhookParameterValueModel
 */
export interface WebhookParameterValueModel {
    /**
     * 
     * @type {string}
     * @memberof WebhookParameterValueModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookParameterValueModel
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookParameterValueModel
     */
    userDefinedKey?: string;
    /**
     * 
     * @type {WebhookParameterModel}
     * @memberof WebhookParameterValueModel
     */
    webhookParameter?: WebhookParameterModel;
}

/**
 * 
 * @export
 * @interface WebhookParametersRequest
 */
export interface WebhookParametersRequest {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof WebhookParametersRequest
     */
    values?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof WebhookParametersRequest
     */
    userDefinedParameters?: { [key: string]: string; };
}

/**
 * 
 * @export
 * @interface WebhookScopeModel
 */
export interface WebhookScopeModel {
    /**
     * 
     * @type {string}
     * @memberof WebhookScopeModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookScopeModel
     */
    name?: string;
}

/**
 * 
 * @export
 * @interface WebhookTypeModel
 */
export interface WebhookTypeModel {
    /**
     * 
     * @type {string}
     * @memberof WebhookTypeModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookTypeModel
     */
    typeName?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookTypeModel
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof WebhookTypeModel
     */
    description?: string;
    /**
     * 
     * @type {Array<WebhookScopeModel>}
     * @memberof WebhookTypeModel
     */
    webhookScopes?: Array<WebhookScopeModel>;
}

/**
 * 
 * @export
 * @interface WelcomeMessageExportModel
 */
export interface WelcomeMessageExportModel {
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageExportModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageExportModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageExportModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageExportModel
     */
    title?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WelcomeMessageExportModel
     */
    isLive?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof WelcomeMessageExportModel
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof WelcomeMessageExportModel
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageExportModel
     */
    content?: string;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof WelcomeMessageExportModel
     */
    smallImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof WelcomeMessageExportModel
     */
    largeImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof WelcomeMessageExportModel
     */
    backgroundImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof WelcomeMessageExportModel
     */
    audio?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof WelcomeMessageExportModel
     */
    video?: MediaItemModel;
    /**
     * 
     * @type {Array<WelcomeMessageWebhookModel>}
     * @memberof WelcomeMessageExportModel
     */
    welcomeMessageWebhooks?: Array<WelcomeMessageWebhookModel>;
    /**
     * 
     * @type {MediaResponseContainerModel}
     * @memberof WelcomeMessageExportModel
     */
    mediaResponseContainer?: MediaResponseContainerModel;
    /**
     * 
     * @type {FollowUpModel}
     * @memberof WelcomeMessageExportModel
     */
    followUp?: FollowUpModel;
    /**
     * 
     * @type {number}
     * @memberof WelcomeMessageExportModel
     */
    hits?: number;
    /**
     * 
     * @type {RepromptModel}
     * @memberof WelcomeMessageExportModel
     */
    reprompt?: RepromptModel;
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageExportModel
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageExportModel
     */
    followUpId?: string;
    /**
     * 
     * @type {Date}
     * @memberof WelcomeMessageExportModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof WelcomeMessageExportModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageExportModel
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageExportModel
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageExportModel
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WelcomeMessageExportModel
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WelcomeMessageExportModel
     */
    isComplete?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageExportModel
     */
    createdFromId?: string;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof WelcomeMessageExportModel
     */
    languages?: Array<LanguageModel>;
}

/**
 * 
 * @export
 * @interface WelcomeMessageModel
 */
export interface WelcomeMessageModel {
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageModel
     */
    applicationId?: string;
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageModel
     */
    applicationFeatureId?: string;
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageModel
     */
    title?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WelcomeMessageModel
     */
    isLive?: boolean;
    /**
     * 
     * @type {Date}
     * @memberof WelcomeMessageModel
     */
    startDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof WelcomeMessageModel
     */
    endDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageModel
     */
    content?: string;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof WelcomeMessageModel
     */
    smallImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof WelcomeMessageModel
     */
    largeImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof WelcomeMessageModel
     */
    backgroundImage?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof WelcomeMessageModel
     */
    audio?: MediaItemModel;
    /**
     * 
     * @type {MediaItemModel}
     * @memberof WelcomeMessageModel
     */
    video?: MediaItemModel;
    /**
     * 
     * @type {Array<WelcomeMessageWebhookModel>}
     * @memberof WelcomeMessageModel
     */
    welcomeMessageWebhooks?: Array<WelcomeMessageWebhookModel>;
    /**
     * 
     * @type {MediaResponseContainerModel}
     * @memberof WelcomeMessageModel
     */
    mediaResponseContainer?: MediaResponseContainerModel;
    /**
     * 
     * @type {FollowUpModel}
     * @memberof WelcomeMessageModel
     */
    followUp?: FollowUpModel;
    /**
     * 
     * @type {number}
     * @memberof WelcomeMessageModel
     */
    hits?: number;
    /**
     * 
     * @type {RepromptModel}
     * @memberof WelcomeMessageModel
     */
    reprompt?: RepromptModel;
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageModel
     */
    repromptId?: string;
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageModel
     */
    followUpId?: string;
    /**
     * 
     * @type {Date}
     * @memberof WelcomeMessageModel
     */
    createdDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof WelcomeMessageModel
     */
    modifiedDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageModel
     */
    mediaResponseContainerId?: string;
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageModel
     */
    displayTextOverride?: string;
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageModel
     */
    displayTitleOverride?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WelcomeMessageModel
     */
    requiresParent?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof WelcomeMessageModel
     */
    isComplete?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageModel
     */
    createdFromId?: string;
    /**
     * 
     * @type {Array<LanguageModel>}
     * @memberof WelcomeMessageModel
     */
    languages?: Array<LanguageModel>;
}

/**
 * 
 * @export
 * @interface WelcomeMessageWebhookModel
 */
export interface WelcomeMessageWebhookModel {
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageWebhookModel
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WelcomeMessageWebhookModel
     */
    welcomeMessageId?: string;
    /**
     * 
     * @type {WebhookModel}
     * @memberof WelcomeMessageWebhookModel
     */
    webhook?: WebhookModel;
    /**
     * 
     * @type {Array<WebhookParameterValueModel>}
     * @memberof WelcomeMessageWebhookModel
     */
    parameterValues?: Array<WebhookParameterValueModel>;
}


/**
 * AlexaSkillApi - fetch parameter creator
 * @export
 */
export const AlexaSkillApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the list of alexa skills for the given vendor
         * @param {string} tokenId 
         * @param {string} vendorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlexaSkills(tokenId: string, vendorId: string, options: any = {}): FetchArgs {
            // verify required parameter 'tokenId' is not null or undefined
            if (tokenId === null || tokenId === undefined) {
                throw new RequiredError('tokenId','Required parameter tokenId was null or undefined when calling listAlexaSkills.');
            }
            // verify required parameter 'vendorId' is not null or undefined
            if (vendorId === null || vendorId === undefined) {
                throw new RequiredError('vendorId','Required parameter vendorId was null or undefined when calling listAlexaSkills.');
            }
            const localVarPath = `/api/AlexaSkill/Skills/{vendorId}/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)))
                .replace(`{${"vendorId"}}`, encodeURIComponent(String(vendorId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlexaSkillApi - functional programming interface
 * @export
 */
export const AlexaSkillApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the list of alexa skills for the given vendor
         * @param {string} tokenId 
         * @param {string} vendorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlexaSkills(tokenId: string, vendorId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SkillSummary>> {
            const localVarFetchArgs = AlexaSkillApiFetchParamCreator(configuration).listAlexaSkills(tokenId, vendorId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AlexaSkillApi - factory interface
 * @export
 */
export const AlexaSkillApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Gets the list of alexa skills for the given vendor
         * @param {string} tokenId 
         * @param {string} vendorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlexaSkills(tokenId: string, vendorId: string, options?: any) {
            return AlexaSkillApiFp(configuration).listAlexaSkills(tokenId, vendorId, options)(fetch, basePath);
        },
    };
};

/**
 * AlexaSkillApi - interface
 * @export
 * @interface AlexaSkillApi
 */
export interface AlexaSkillApiInterface {
    /**
     * 
     * @summary Gets the list of alexa skills for the given vendor
     * @param {string} tokenId 
     * @param {string} vendorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlexaSkillApiInterface
     */
    listAlexaSkills(tokenId: string, vendorId: string, options?: any): Promise<Array<SkillSummary>>;

}

/**
 * AlexaSkillApi - object-oriented interface
 * @export
 * @class AlexaSkillApi
 * @extends {BaseAPI}
 */
export class AlexaSkillApi extends BaseAPI implements AlexaSkillApiInterface {
    /**
     * 
     * @summary Gets the list of alexa skills for the given vendor
     * @param {string} tokenId 
     * @param {string} vendorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlexaSkillApi
     */
    public listAlexaSkills(tokenId: string, vendorId: string, options?: any) {
        return AlexaSkillApiFp(this.configuration).listAlexaSkills(tokenId, vendorId, options)(this.fetch, this.basePath);
    }

}

/**
 * AmazonAuthorizationApi - fetch parameter creator
 * @export
 */
export const AmazonAuthorizationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Handles the callback for amazon OAuth
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {string} [error] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amazonAuthCallbackAsync(code?: string, state?: string, error?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/AmazonAuthorization/Callback`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (error !== undefined) {
                localVarQueryParameter['error'] = error;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the available amazon credential information for a given organization
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableCredentials(organizationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling getAvailableCredentials.');
            }
            const localVarPath = `/api/AmazonAuthorization/Credentials/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes an amazon credential
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCredential(tokenId: string, options: any = {}): FetchArgs {
            // verify required parameter 'tokenId' is not null or undefined
            if (tokenId === null || tokenId === undefined) {
                throw new RequiredError('tokenId','Required parameter tokenId was null or undefined when calling removeCredential.');
            }
            const localVarPath = `/api/AmazonAuthorization/Credentials/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the authentication url for amazon authorization
         * @param {string} [organizationId] 
         * @param {string} [applicationId] 
         * @param {string} [salt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestAuthenticationUrl(organizationId?: string, applicationId?: string, salt?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/AmazonAuthorization/AuthorizationUrl`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (salt !== undefined) {
                localVarQueryParameter['salt'] = salt;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AmazonAuthorizationApi - functional programming interface
 * @export
 */
export const AmazonAuthorizationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Handles the callback for amazon OAuth
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {string} [error] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amazonAuthCallbackAsync(code?: string, state?: string, error?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = AmazonAuthorizationApiFetchParamCreator(configuration).amazonAuthCallbackAsync(code, state, error, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the available amazon credential information for a given organization
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableCredentials(organizationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TokenResponse>> {
            const localVarFetchArgs = AmazonAuthorizationApiFetchParamCreator(configuration).getAvailableCredentials(organizationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Removes an amazon credential
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCredential(tokenId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = AmazonAuthorizationApiFetchParamCreator(configuration).removeCredential(tokenId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the authentication url for amazon authorization
         * @param {string} [organizationId] 
         * @param {string} [applicationId] 
         * @param {string} [salt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestAuthenticationUrl(organizationId?: string, applicationId?: string, salt?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = AmazonAuthorizationApiFetchParamCreator(configuration).requestAuthenticationUrl(organizationId, applicationId, salt, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AmazonAuthorizationApi - factory interface
 * @export
 */
export const AmazonAuthorizationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Handles the callback for amazon OAuth
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {string} [error] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        amazonAuthCallbackAsync(code?: string, state?: string, error?: string, options?: any) {
            return AmazonAuthorizationApiFp(configuration).amazonAuthCallbackAsync(code, state, error, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the available amazon credential information for a given organization
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableCredentials(organizationId: string, options?: any) {
            return AmazonAuthorizationApiFp(configuration).getAvailableCredentials(organizationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Removes an amazon credential
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCredential(tokenId: string, options?: any) {
            return AmazonAuthorizationApiFp(configuration).removeCredential(tokenId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the authentication url for amazon authorization
         * @param {string} [organizationId] 
         * @param {string} [applicationId] 
         * @param {string} [salt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestAuthenticationUrl(organizationId?: string, applicationId?: string, salt?: string, options?: any) {
            return AmazonAuthorizationApiFp(configuration).requestAuthenticationUrl(organizationId, applicationId, salt, options)(fetch, basePath);
        },
    };
};

/**
 * AmazonAuthorizationApi - interface
 * @export
 * @interface AmazonAuthorizationApi
 */
export interface AmazonAuthorizationApiInterface {
    /**
     * 
     * @summary Handles the callback for amazon OAuth
     * @param {string} [code] 
     * @param {string} [state] 
     * @param {string} [error] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AmazonAuthorizationApiInterface
     */
    amazonAuthCallbackAsync(code?: string, state?: string, error?: string, options?: any): Promise<boolean>;

    /**
     * 
     * @summary Gets the available amazon credential information for a given organization
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AmazonAuthorizationApiInterface
     */
    getAvailableCredentials(organizationId: string, options?: any): Promise<Array<TokenResponse>>;

    /**
     * 
     * @summary Removes an amazon credential
     * @param {string} tokenId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AmazonAuthorizationApiInterface
     */
    removeCredential(tokenId: string, options?: any): Promise<boolean>;

    /**
     * 
     * @summary Gets the authentication url for amazon authorization
     * @param {string} [organizationId] 
     * @param {string} [applicationId] 
     * @param {string} [salt] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AmazonAuthorizationApiInterface
     */
    requestAuthenticationUrl(organizationId?: string, applicationId?: string, salt?: string, options?: any): Promise<string>;

}

/**
 * AmazonAuthorizationApi - object-oriented interface
 * @export
 * @class AmazonAuthorizationApi
 * @extends {BaseAPI}
 */
export class AmazonAuthorizationApi extends BaseAPI implements AmazonAuthorizationApiInterface {
    /**
     * 
     * @summary Handles the callback for amazon OAuth
     * @param {string} [code] 
     * @param {string} [state] 
     * @param {string} [error] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AmazonAuthorizationApi
     */
    public amazonAuthCallbackAsync(code?: string, state?: string, error?: string, options?: any) {
        return AmazonAuthorizationApiFp(this.configuration).amazonAuthCallbackAsync(code, state, error, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the available amazon credential information for a given organization
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AmazonAuthorizationApi
     */
    public getAvailableCredentials(organizationId: string, options?: any) {
        return AmazonAuthorizationApiFp(this.configuration).getAvailableCredentials(organizationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Removes an amazon credential
     * @param {string} tokenId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AmazonAuthorizationApi
     */
    public removeCredential(tokenId: string, options?: any) {
        return AmazonAuthorizationApiFp(this.configuration).removeCredential(tokenId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the authentication url for amazon authorization
     * @param {string} [organizationId] 
     * @param {string} [applicationId] 
     * @param {string} [salt] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AmazonAuthorizationApi
     */
    public requestAuthenticationUrl(organizationId?: string, applicationId?: string, salt?: string, options?: any) {
        return AmazonAuthorizationApiFp(this.configuration).requestAuthenticationUrl(organizationId, applicationId, salt, options)(this.fetch, this.basePath);
    }

}

/**
 * ApplicationApi - fetch parameter creator
 * @export
 */
export const ApplicationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a member to the given application
         * @param {string} applicationId 
         * @param {NewApplicationMemberRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMemberAsync(applicationId: string, model?: NewApplicationMemberRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling addMemberAsync.');
            }
            const localVarPath = `/api/Application/{applicationId}/members`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewApplicationMemberRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(applicationId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling addWebhook.');
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId','Required parameter webhookId was null or undefined when calling addWebhook.');
            }
            const localVarPath = `/api/Application/{applicationId}/webhooks/{webhookId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a member to the given application
         * @param {string} applicationId 
         * @param {NewBulkApplicationMemberRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkAddMemberAsync(applicationId: string, model?: NewBulkApplicationMemberRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling bulkAddMemberAsync.');
            }
            const localVarPath = `/api/Application/{applicationId}/members/bulkAdd`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewBulkApplicationMemberRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new Application with some sample content for the given organization
         * @param {string} organizationId Organization ID
         * @param {NewApplicationRequest} [model] request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationWithSampleContent(organizationId: string, model?: NewApplicationRequest, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling createApplicationWithSampleContent.');
            }
            const localVarPath = `/api/Application/{organizationId}/withSamples`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewApplicationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new Application for the given organization
         * @param {string} organizationId Organization ID
         * @param {NewApplicationRequest} [model] request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmptyApplication(organizationId: string, model?: NewApplicationRequest, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling createEmptyApplication.');
            }
            const localVarPath = `/api/Application/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewApplicationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling createUserDefinedParameter.');
            }
            const localVarPath = `/api/Application/webhook/{instanceWebhookId}/userParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDefinedWebhookParameterCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling deleteApplication.');
            }
            const localVarPath = `/api/Application/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableApplication(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling disableApplication.');
            }
            const localVarPath = `/api/Application/{applicationId}/disable`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableApplication(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling enableApplication.');
            }
            const localVarPath = `/api/Application/{applicationId}/enable`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a single application by id
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findApplication(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling findApplication.');
            }
            const localVarPath = `/api/Application/find/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets a single application with all its features by id
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findApplicationWithFeatures(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling findApplicationWithFeatures.');
            }
            const localVarPath = `/api/Application/find/{applicationId}/withFeatures`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppConversationCount(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getAppConversationCount.');
            }
            const localVarPath = `/api/Application/{applicationId}/conversationCount`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppConversationCounts(organizationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling getAppConversationCounts.');
            }
            const localVarPath = `/api/Application/{organizationId}/apps/conversationCounts`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the members of the application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppMembers(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getAppMembers.');
            }
            const localVarPath = `/api/Application/{applicationId}/members`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the applications from the given organization
         * @param {string} organizationId The organization Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationsForOrganization(organizationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling getApplicationsForOrganization.');
            }
            const localVarPath = `/api/Application/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the applications from the given organization
         * @param {string} organizationId The organization Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationsWithFeaturesForOrganization(organizationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling getApplicationsWithFeaturesForOrganization.');
            }
            const localVarPath = `/api/Application/{organizationId}/withFeatures`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFulfillmentEndpoints(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getFulfillmentEndpoints.');
            }
            const localVarPath = `/api/Application/{applicationId}/fulfillmentEndpoints`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getWebhooks.');
            }
            const localVarPath = `/api/Application/{applicationId}/webhooks`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes the given user from the app
         * @param {string} applicationMemberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMember(applicationMemberId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationMemberId' is not null or undefined
            if (applicationMemberId === null || applicationMemberId === undefined) {
                throw new RequiredError('applicationMemberId','Required parameter applicationMemberId was null or undefined when calling removeMember.');
            }
            const localVarPath = `/api/Application/members/{applicationMemberId}`
                .replace(`{${"applicationMemberId"}}`, encodeURIComponent(String(applicationMemberId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling removeUserDefinedParameter.');
            }
            // verify required parameter 'parameterName' is not null or undefined
            if (parameterName === null || parameterName === undefined) {
                throw new RequiredError('parameterName','Required parameter parameterName was null or undefined when calling removeUserDefinedParameter.');
            }
            const localVarPath = `/api/Application/webhook/{instanceWebhookId}/userParameters/{parameterName}`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)))
                .replace(`{${"parameterName"}}`, encodeURIComponent(String(parameterName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(applicationWebhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationWebhookId' is not null or undefined
            if (applicationWebhookId === null || applicationWebhookId === undefined) {
                throw new RequiredError('applicationWebhookId','Required parameter applicationWebhookId was null or undefined when calling removeWebhook.');
            }
            const localVarPath = `/api/Application/webhook/{applicationWebhookId}`
                .replace(`{${"applicationWebhookId"}}`, encodeURIComponent(String(applicationWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} imageItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setImage(applicationId: string, imageItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling setImage.');
            }
            // verify required parameter 'imageItemId' is not null or undefined
            if (imageItemId === null || imageItemId === undefined) {
                throw new RequiredError('imageItemId','Required parameter imageItemId was null or undefined when calling setImage.');
            }
            const localVarPath = `/api/Application/{applicationId}/setImage/{imageItemId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"imageItemId"}}`, encodeURIComponent(String(imageItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInitialPriority(options: any = {}): FetchArgs {
            const localVarPath = `/api/Application/setInitialPriority`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggles the template status of an application
         * @param {string} applicationId 
         * @param {ToggleTemplateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleAllowsTemplate(applicationId: string, request?: ToggleTemplateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling toggleAllowsTemplate.');
            }
            const localVarPath = `/api/Application/{applicationId}/toggleAllowsTemplate`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ToggleTemplateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {'LOW' | 'MEDIUM' | 'HIGH'} sensitivityLevel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlexaFallbackSensitivity(applicationId: string, sensitivityLevel: 'LOW' | 'MEDIUM' | 'HIGH', options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling updateAlexaFallbackSensitivity.');
            }
            // verify required parameter 'sensitivityLevel' is not null or undefined
            if (sensitivityLevel === null || sensitivityLevel === undefined) {
                throw new RequiredError('sensitivityLevel','Required parameter sensitivityLevel was null or undefined when calling updateAlexaFallbackSensitivity.');
            }
            const localVarPath = `/api/Application/{applicationId}/alexaFallbackSensitivity/{sensitivityLevel}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"sensitivityLevel"}}`, encodeURIComponent(String(sensitivityLevel)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates an application's information
         * @param {string} applicationId The application id
         * @param {UpdateApplicationRequest} [model] Information to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationInformation(applicationId: string, model?: UpdateApplicationRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling updateApplicationInformation.');
            }
            const localVarPath = `/api/Application/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateApplicationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(applicationId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling updateAttachedWebhook.');
            }
            // verify required parameter 'webhookInstanceId' is not null or undefined
            if (webhookInstanceId === null || webhookInstanceId === undefined) {
                throw new RequiredError('webhookInstanceId','Required parameter webhookInstanceId was null or undefined when calling updateAttachedWebhook.');
            }
            const localVarPath = `/api/Application/{applicationId}/webhooks/{webhookInstanceId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"webhookInstanceId"}}`, encodeURIComponent(String(webhookInstanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} languageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDefaultLangauge(applicationId: string, languageId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling updateDefaultLangauge.');
            }
            // verify required parameter 'languageId' is not null or undefined
            if (languageId === null || languageId === undefined) {
                throw new RequiredError('languageId','Required parameter languageId was null or undefined when calling updateDefaultLangauge.');
            }
            const localVarPath = `/api/Application/{applicationId}/defaultLanguage/{languageId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"languageId"}}`, encodeURIComponent(String(languageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {Array<string>} [languageIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLangauges(applicationId: string, languageIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling updateLangauges.');
            }
            const localVarPath = `/api/Application/{applicationId}/languages`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(languageIds || {}) : (languageIds || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the given member's role
         * @param {string} applicationMemberId 
         * @param {MemberRoleUpdateRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMemberRole(applicationMemberId: string, model?: MemberRoleUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationMemberId' is not null or undefined
            if (applicationMemberId === null || applicationMemberId === undefined) {
                throw new RequiredError('applicationMemberId','Required parameter applicationMemberId was null or undefined when calling updateMemberRole.');
            }
            const localVarPath = `/api/Application/members/{applicationMemberId}`
                .replace(`{${"applicationMemberId"}}`, encodeURIComponent(String(applicationMemberId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MemberRoleUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateUserDefinedParameter.');
            }
            const localVarPath = `/api/Application/webhook/{instanceWebhookId}/userParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDefinedWebhookParameterUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateWebhookParameter.');
            }
            const localVarPath = `/api/Application/webhook/{instanceWebhookId}/webhookParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParameterUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationApi - functional programming interface
 * @export
 */
export const ApplicationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a member to the given application
         * @param {string} applicationId 
         * @param {NewApplicationMemberRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMemberAsync(applicationId: string, model?: NewApplicationMemberRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationMemberModel> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).addMemberAsync(applicationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(applicationId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationWebhookModel> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).addWebhook(applicationId, webhookId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a member to the given application
         * @param {string} applicationId 
         * @param {NewBulkApplicationMemberRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkAddMemberAsync(applicationId: string, model?: NewBulkApplicationMemberRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ApplicationMemberModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).bulkAddMemberAsync(applicationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new Application with some sample content for the given organization
         * @param {string} organizationId Organization ID
         * @param {NewApplicationRequest} [model] request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationWithSampleContent(organizationId: string, model?: NewApplicationRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationModel> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).createApplicationWithSampleContent(organizationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new Application for the given organization
         * @param {string} organizationId Organization ID
         * @param {NewApplicationRequest} [model] request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmptyApplication(organizationId: string, model?: NewApplicationRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationModel> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).createEmptyApplication(organizationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).createUserDefinedParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationModel> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).deleteApplication(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableApplication(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationModel> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).disableApplication(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableApplication(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationModel> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).enableApplication(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets a single application by id
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findApplication(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationModel> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).findApplication(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets a single application with all its features by id
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findApplicationWithFeatures(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationWithFeaturesModel> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).findApplicationWithFeatures(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppConversationCount(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationConversationCountModel> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getAppConversationCount(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppConversationCounts(organizationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ApplicationConversationCountModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getAppConversationCounts(organizationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the members of the application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppMembers(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ApplicationMemberModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getAppMembers(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the applications from the given organization
         * @param {string} organizationId The organization Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationsForOrganization(organizationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ApplicationModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getApplicationsForOrganization(organizationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the applications from the given organization
         * @param {string} organizationId The organization Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationsWithFeaturesForOrganization(organizationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ApplicationWithFeaturesModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getApplicationsWithFeaturesForOrganization(organizationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFulfillmentEndpoints(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationFulfillmentEndpoints> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getFulfillmentEndpoints(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ApplicationWebhookModel>> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).getWebhooks(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Removes the given user from the app
         * @param {string} applicationMemberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMember(applicationMemberId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationMemberModel> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).removeMember(applicationMemberId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(applicationWebhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationWebhookModel> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).removeWebhook(applicationWebhookId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} imageItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setImage(applicationId: string, imageItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationModel> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).setImage(applicationId, imageItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInitialPriority(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).setInitialPriority(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Toggles the template status of an application
         * @param {string} applicationId 
         * @param {ToggleTemplateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleAllowsTemplate(applicationId: string, request?: ToggleTemplateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationModel> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).toggleAllowsTemplate(applicationId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {'LOW' | 'MEDIUM' | 'HIGH'} sensitivityLevel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlexaFallbackSensitivity(applicationId: string, sensitivityLevel: 'LOW' | 'MEDIUM' | 'HIGH', options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).updateAlexaFallbackSensitivity(applicationId, sensitivityLevel, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates an application's information
         * @param {string} applicationId The application id
         * @param {UpdateApplicationRequest} [model] Information to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationInformation(applicationId: string, model?: UpdateApplicationRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationModel> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).updateApplicationInformation(applicationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(applicationId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationWebhookModel> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).updateAttachedWebhook(applicationId, webhookInstanceId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} languageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDefaultLangauge(applicationId: string, languageId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationModel> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).updateDefaultLangauge(applicationId, languageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {Array<string>} [languageIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLangauges(applicationId: string, languageIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationModel> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).updateLangauges(applicationId, languageIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the given member's role
         * @param {string} applicationMemberId 
         * @param {MemberRoleUpdateRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMemberRole(applicationMemberId: string, model?: MemberRoleUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationMemberModel> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).updateMemberRole(applicationMemberId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).updateUserDefinedParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ApplicationApiFetchParamCreator(configuration).updateWebhookParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ApplicationApi - factory interface
 * @export
 */
export const ApplicationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Adds a member to the given application
         * @param {string} applicationId 
         * @param {NewApplicationMemberRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMemberAsync(applicationId: string, model?: NewApplicationMemberRequest, options?: any) {
            return ApplicationApiFp(configuration).addMemberAsync(applicationId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(applicationId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
            return ApplicationApiFp(configuration).addWebhook(applicationId, webhookId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a member to the given application
         * @param {string} applicationId 
         * @param {NewBulkApplicationMemberRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkAddMemberAsync(applicationId: string, model?: NewBulkApplicationMemberRequest, options?: any) {
            return ApplicationApiFp(configuration).bulkAddMemberAsync(applicationId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new Application with some sample content for the given organization
         * @param {string} organizationId Organization ID
         * @param {NewApplicationRequest} [model] request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationWithSampleContent(organizationId: string, model?: NewApplicationRequest, options?: any) {
            return ApplicationApiFp(configuration).createApplicationWithSampleContent(organizationId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new Application for the given organization
         * @param {string} organizationId Organization ID
         * @param {NewApplicationRequest} [model] request model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmptyApplication(organizationId: string, model?: NewApplicationRequest, options?: any) {
            return ApplicationApiFp(configuration).createEmptyApplication(organizationId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any) {
            return ApplicationApiFp(configuration).createUserDefinedParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApplication(applicationId: string, options?: any) {
            return ApplicationApiFp(configuration).deleteApplication(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableApplication(applicationId: string, options?: any) {
            return ApplicationApiFp(configuration).disableApplication(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableApplication(applicationId: string, options?: any) {
            return ApplicationApiFp(configuration).enableApplication(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets a single application by id
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findApplication(applicationId: string, options?: any) {
            return ApplicationApiFp(configuration).findApplication(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets a single application with all its features by id
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findApplicationWithFeatures(applicationId: string, options?: any) {
            return ApplicationApiFp(configuration).findApplicationWithFeatures(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppConversationCount(applicationId: string, options?: any) {
            return ApplicationApiFp(configuration).getAppConversationCount(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppConversationCounts(organizationId: string, options?: any) {
            return ApplicationApiFp(configuration).getAppConversationCounts(organizationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the members of the application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppMembers(applicationId: string, options?: any) {
            return ApplicationApiFp(configuration).getAppMembers(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the applications from the given organization
         * @param {string} organizationId The organization Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationsForOrganization(organizationId: string, options?: any) {
            return ApplicationApiFp(configuration).getApplicationsForOrganization(organizationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the applications from the given organization
         * @param {string} organizationId The organization Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationsWithFeaturesForOrganization(organizationId: string, options?: any) {
            return ApplicationApiFp(configuration).getApplicationsWithFeaturesForOrganization(organizationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFulfillmentEndpoints(applicationId: string, options?: any) {
            return ApplicationApiFp(configuration).getFulfillmentEndpoints(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(applicationId: string, options?: any) {
            return ApplicationApiFp(configuration).getWebhooks(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Removes the given user from the app
         * @param {string} applicationMemberId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMember(applicationMemberId: string, options?: any) {
            return ApplicationApiFp(configuration).removeMember(applicationMemberId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any) {
            return ApplicationApiFp(configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(applicationWebhookId: string, options?: any) {
            return ApplicationApiFp(configuration).removeWebhook(applicationWebhookId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} imageItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setImage(applicationId: string, imageItemId: string, options?: any) {
            return ApplicationApiFp(configuration).setImage(applicationId, imageItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setInitialPriority(options?: any) {
            return ApplicationApiFp(configuration).setInitialPriority(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Toggles the template status of an application
         * @param {string} applicationId 
         * @param {ToggleTemplateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleAllowsTemplate(applicationId: string, request?: ToggleTemplateRequest, options?: any) {
            return ApplicationApiFp(configuration).toggleAllowsTemplate(applicationId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {'LOW' | 'MEDIUM' | 'HIGH'} sensitivityLevel 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAlexaFallbackSensitivity(applicationId: string, sensitivityLevel: 'LOW' | 'MEDIUM' | 'HIGH', options?: any) {
            return ApplicationApiFp(configuration).updateAlexaFallbackSensitivity(applicationId, sensitivityLevel, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates an application's information
         * @param {string} applicationId The application id
         * @param {UpdateApplicationRequest} [model] Information to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationInformation(applicationId: string, model?: UpdateApplicationRequest, options?: any) {
            return ApplicationApiFp(configuration).updateApplicationInformation(applicationId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(applicationId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any) {
            return ApplicationApiFp(configuration).updateAttachedWebhook(applicationId, webhookInstanceId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} languageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDefaultLangauge(applicationId: string, languageId: string, options?: any) {
            return ApplicationApiFp(configuration).updateDefaultLangauge(applicationId, languageId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {Array<string>} [languageIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLangauges(applicationId: string, languageIds?: Array<string>, options?: any) {
            return ApplicationApiFp(configuration).updateLangauges(applicationId, languageIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the given member's role
         * @param {string} applicationMemberId 
         * @param {MemberRoleUpdateRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMemberRole(applicationMemberId: string, model?: MemberRoleUpdateRequest, options?: any) {
            return ApplicationApiFp(configuration).updateMemberRole(applicationMemberId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any) {
            return ApplicationApiFp(configuration).updateUserDefinedParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any) {
            return ApplicationApiFp(configuration).updateWebhookParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
    };
};

/**
 * ApplicationApi - interface
 * @export
 * @interface ApplicationApi
 */
export interface ApplicationApiInterface {
    /**
     * 
     * @summary Adds a member to the given application
     * @param {string} applicationId 
     * @param {NewApplicationMemberRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    addMemberAsync(applicationId: string, model?: NewApplicationMemberRequest, options?: any): Promise<ApplicationMemberModel>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    addWebhook(applicationId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): Promise<ApplicationWebhookModel>;

    /**
     * 
     * @summary Adds a member to the given application
     * @param {string} applicationId 
     * @param {NewBulkApplicationMemberRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    bulkAddMemberAsync(applicationId: string, model?: NewBulkApplicationMemberRequest, options?: any): Promise<Array<ApplicationMemberModel>>;

    /**
     * 
     * @summary Creates a new Application with some sample content for the given organization
     * @param {string} organizationId Organization ID
     * @param {NewApplicationRequest} [model] request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    createApplicationWithSampleContent(organizationId: string, model?: NewApplicationRequest, options?: any): Promise<ApplicationModel>;

    /**
     * 
     * @summary Creates a new Application for the given organization
     * @param {string} organizationId Organization ID
     * @param {NewApplicationRequest} [model] request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    createEmptyApplication(organizationId: string, model?: NewApplicationRequest, options?: any): Promise<ApplicationModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterCreateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    deleteApplication(applicationId: string, options?: any): Promise<ApplicationModel>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    disableApplication(applicationId: string, options?: any): Promise<ApplicationModel>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    enableApplication(applicationId: string, options?: any): Promise<ApplicationModel>;

    /**
     * 
     * @summary Gets a single application by id
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    findApplication(applicationId: string, options?: any): Promise<ApplicationModel>;

    /**
     * 
     * @summary Gets a single application with all its features by id
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    findApplicationWithFeatures(applicationId: string, options?: any): Promise<ApplicationWithFeaturesModel>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getAppConversationCount(applicationId: string, options?: any): Promise<ApplicationConversationCountModel>;

    /**
     * 
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getAppConversationCounts(organizationId: string, options?: any): Promise<Array<ApplicationConversationCountModel>>;

    /**
     * 
     * @summary Gets the members of the application
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getAppMembers(applicationId: string, options?: any): Promise<Array<ApplicationMemberModel>>;

    /**
     * 
     * @summary Gets the applications from the given organization
     * @param {string} organizationId The organization Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getApplicationsForOrganization(organizationId: string, options?: any): Promise<Array<ApplicationModel>>;

    /**
     * 
     * @summary Gets the applications from the given organization
     * @param {string} organizationId The organization Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getApplicationsWithFeaturesForOrganization(organizationId: string, options?: any): Promise<Array<ApplicationWithFeaturesModel>>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getFulfillmentEndpoints(applicationId: string, options?: any): Promise<ApplicationFulfillmentEndpoints>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    getWebhooks(applicationId: string, options?: any): Promise<Array<ApplicationWebhookModel>>;

    /**
     * 
     * @summary Removes the given user from the app
     * @param {string} applicationMemberId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    removeMember(applicationMemberId: string, options?: any): Promise<ApplicationMemberModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {string} parameterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} applicationWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    removeWebhook(applicationWebhookId: string, options?: any): Promise<ApplicationWebhookModel>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} imageItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    setImage(applicationId: string, imageItemId: string, options?: any): Promise<ApplicationModel>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    setInitialPriority(options?: any): Promise<boolean>;

    /**
     * 
     * @summary Toggles the template status of an application
     * @param {string} applicationId 
     * @param {ToggleTemplateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    toggleAllowsTemplate(applicationId: string, request?: ToggleTemplateRequest, options?: any): Promise<ApplicationModel>;

    /**
     * 
     * @param {string} applicationId 
     * @param {'LOW' | 'MEDIUM' | 'HIGH'} sensitivityLevel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    updateAlexaFallbackSensitivity(applicationId: string, sensitivityLevel: 'LOW' | 'MEDIUM' | 'HIGH', options?: any): Promise<boolean>;

    /**
     * 
     * @summary Updates an application's information
     * @param {string} applicationId The application id
     * @param {UpdateApplicationRequest} [model] Information to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    updateApplicationInformation(applicationId: string, model?: UpdateApplicationRequest, options?: any): Promise<ApplicationModel>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} webhookInstanceId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    updateAttachedWebhook(applicationId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any): Promise<ApplicationWebhookModel>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} languageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    updateDefaultLangauge(applicationId: string, languageId: string, options?: any): Promise<ApplicationModel>;

    /**
     * 
     * @param {string} applicationId 
     * @param {Array<string>} [languageIds] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    updateLangauges(applicationId: string, languageIds?: Array<string>, options?: any): Promise<ApplicationModel>;

    /**
     * 
     * @summary Updates the given member's role
     * @param {string} applicationMemberId 
     * @param {MemberRoleUpdateRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    updateMemberRole(applicationMemberId: string, model?: MemberRoleUpdateRequest, options?: any): Promise<ApplicationMemberModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {WebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApiInterface
     */
    updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any): Promise<boolean>;

}

/**
 * ApplicationApi - object-oriented interface
 * @export
 * @class ApplicationApi
 * @extends {BaseAPI}
 */
export class ApplicationApi extends BaseAPI implements ApplicationApiInterface {
    /**
     * 
     * @summary Adds a member to the given application
     * @param {string} applicationId 
     * @param {NewApplicationMemberRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public addMemberAsync(applicationId: string, model?: NewApplicationMemberRequest, options?: any) {
        return ApplicationApiFp(this.configuration).addMemberAsync(applicationId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public addWebhook(applicationId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
        return ApplicationApiFp(this.configuration).addWebhook(applicationId, webhookId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a member to the given application
     * @param {string} applicationId 
     * @param {NewBulkApplicationMemberRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public bulkAddMemberAsync(applicationId: string, model?: NewBulkApplicationMemberRequest, options?: any) {
        return ApplicationApiFp(this.configuration).bulkAddMemberAsync(applicationId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new Application with some sample content for the given organization
     * @param {string} organizationId Organization ID
     * @param {NewApplicationRequest} [model] request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public createApplicationWithSampleContent(organizationId: string, model?: NewApplicationRequest, options?: any) {
        return ApplicationApiFp(this.configuration).createApplicationWithSampleContent(organizationId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new Application for the given organization
     * @param {string} organizationId Organization ID
     * @param {NewApplicationRequest} [model] request model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public createEmptyApplication(organizationId: string, model?: NewApplicationRequest, options?: any) {
        return ApplicationApiFp(this.configuration).createEmptyApplication(organizationId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterCreateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any) {
        return ApplicationApiFp(this.configuration).createUserDefinedParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public deleteApplication(applicationId: string, options?: any) {
        return ApplicationApiFp(this.configuration).deleteApplication(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public disableApplication(applicationId: string, options?: any) {
        return ApplicationApiFp(this.configuration).disableApplication(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public enableApplication(applicationId: string, options?: any) {
        return ApplicationApiFp(this.configuration).enableApplication(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets a single application by id
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public findApplication(applicationId: string, options?: any) {
        return ApplicationApiFp(this.configuration).findApplication(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets a single application with all its features by id
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public findApplicationWithFeatures(applicationId: string, options?: any) {
        return ApplicationApiFp(this.configuration).findApplicationWithFeatures(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getAppConversationCount(applicationId: string, options?: any) {
        return ApplicationApiFp(this.configuration).getAppConversationCount(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getAppConversationCounts(organizationId: string, options?: any) {
        return ApplicationApiFp(this.configuration).getAppConversationCounts(organizationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the members of the application
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getAppMembers(applicationId: string, options?: any) {
        return ApplicationApiFp(this.configuration).getAppMembers(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the applications from the given organization
     * @param {string} organizationId The organization Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getApplicationsForOrganization(organizationId: string, options?: any) {
        return ApplicationApiFp(this.configuration).getApplicationsForOrganization(organizationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the applications from the given organization
     * @param {string} organizationId The organization Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getApplicationsWithFeaturesForOrganization(organizationId: string, options?: any) {
        return ApplicationApiFp(this.configuration).getApplicationsWithFeaturesForOrganization(organizationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getFulfillmentEndpoints(applicationId: string, options?: any) {
        return ApplicationApiFp(this.configuration).getFulfillmentEndpoints(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public getWebhooks(applicationId: string, options?: any) {
        return ApplicationApiFp(this.configuration).getWebhooks(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Removes the given user from the app
     * @param {string} applicationMemberId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public removeMember(applicationMemberId: string, options?: any) {
        return ApplicationApiFp(this.configuration).removeMember(applicationMemberId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {string} parameterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any) {
        return ApplicationApiFp(this.configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public removeWebhook(applicationWebhookId: string, options?: any) {
        return ApplicationApiFp(this.configuration).removeWebhook(applicationWebhookId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} imageItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public setImage(applicationId: string, imageItemId: string, options?: any) {
        return ApplicationApiFp(this.configuration).setImage(applicationId, imageItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public setInitialPriority(options?: any) {
        return ApplicationApiFp(this.configuration).setInitialPriority(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Toggles the template status of an application
     * @param {string} applicationId 
     * @param {ToggleTemplateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public toggleAllowsTemplate(applicationId: string, request?: ToggleTemplateRequest, options?: any) {
        return ApplicationApiFp(this.configuration).toggleAllowsTemplate(applicationId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {'LOW' | 'MEDIUM' | 'HIGH'} sensitivityLevel 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public updateAlexaFallbackSensitivity(applicationId: string, sensitivityLevel: 'LOW' | 'MEDIUM' | 'HIGH', options?: any) {
        return ApplicationApiFp(this.configuration).updateAlexaFallbackSensitivity(applicationId, sensitivityLevel, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates an application's information
     * @param {string} applicationId The application id
     * @param {UpdateApplicationRequest} [model] Information to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public updateApplicationInformation(applicationId: string, model?: UpdateApplicationRequest, options?: any) {
        return ApplicationApiFp(this.configuration).updateApplicationInformation(applicationId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} webhookInstanceId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public updateAttachedWebhook(applicationId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any) {
        return ApplicationApiFp(this.configuration).updateAttachedWebhook(applicationId, webhookInstanceId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} languageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public updateDefaultLangauge(applicationId: string, languageId: string, options?: any) {
        return ApplicationApiFp(this.configuration).updateDefaultLangauge(applicationId, languageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {Array<string>} [languageIds] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public updateLangauges(applicationId: string, languageIds?: Array<string>, options?: any) {
        return ApplicationApiFp(this.configuration).updateLangauges(applicationId, languageIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the given member's role
     * @param {string} applicationMemberId 
     * @param {MemberRoleUpdateRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public updateMemberRole(applicationMemberId: string, model?: MemberRoleUpdateRequest, options?: any) {
        return ApplicationApiFp(this.configuration).updateMemberRole(applicationMemberId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any) {
        return ApplicationApiFp(this.configuration).updateUserDefinedParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {WebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationApi
     */
    public updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any) {
        return ApplicationApiFp(this.configuration).updateWebhookParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

}

/**
 * ApplicationDeploymentApi - fetch parameter creator
 * @export
 */
export const ApplicationDeploymentApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [luisRegion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployNewLuisApp(applicationId: string, luisRegion?: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling deployNewLuisApp.');
            }
            const localVarPath = `/api/ApplicationDeployment/{applicationId}/luisApp/CreateAndDeploy`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (luisRegion !== undefined) {
                localVarQueryParameter['luisRegion'] = luisRegion;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployNewSkill(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling deployNewSkill.');
            }
            const localVarPath = `/api/ApplicationDeployment/{applicationId}/alexaSkill/CreateAndDeploy`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlexaVendors(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getAlexaVendors.');
            }
            const localVarPath = `/api/ApplicationDeployment/{applicationId}/alexaVendors`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationLinkToAmazon(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationLinkToAmazon.');
            }
            const localVarPath = `/api/ApplicationDeployment/{applicationId}/linkToAmazon`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationLinkToGoogle(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationLinkToGoogle.');
            }
            const localVarPath = `/api/ApplicationDeployment/{applicationId}/linkToGoogle`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationLinkToMicrosoft(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationLinkToMicrosoft.');
            }
            const localVarPath = `/api/ApplicationDeployment/{applicationId}/linkToMicrosoft`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationsLinkedToAmazon(organizationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling getApplicationsLinkedToAmazon.');
            }
            const localVarPath = `/api/ApplicationDeployment/organizationLinksToAmazon/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationsLinkedToGoogle(organizationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling getApplicationsLinkedToGoogle.');
            }
            const localVarPath = `/api/ApplicationDeployment/organizationLinksToGoogle/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationsLinkedToMicrosoft(organizationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling getApplicationsLinkedToMicrosoft.');
            }
            const localVarPath = `/api/ApplicationDeployment/organizationLinksToMicrosoft/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} alexaSkillId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAlexaSkillId(applicationId: string, alexaSkillId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling linkAlexaSkillId.');
            }
            // verify required parameter 'alexaSkillId' is not null or undefined
            if (alexaSkillId === null || alexaSkillId === undefined) {
                throw new RequiredError('alexaSkillId','Required parameter alexaSkillId was null or undefined when calling linkAlexaSkillId.');
            }
            const localVarPath = `/api/ApplicationDeployment/{applicationId}/alexaSkill/{alexaSkillId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"alexaSkillId"}}`, encodeURIComponent(String(alexaSkillId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} vendorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAlexaVendor(applicationId: string, vendorId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling linkAlexaVendor.');
            }
            // verify required parameter 'vendorId' is not null or undefined
            if (vendorId === null || vendorId === undefined) {
                throw new RequiredError('vendorId','Required parameter vendorId was null or undefined when calling linkAlexaVendor.');
            }
            const localVarPath = `/api/ApplicationDeployment/{applicationId}/alexaVendor/{vendorId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"vendorId"}}`, encodeURIComponent(String(vendorId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} amazonTokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAmazonAuthToken(applicationId: string, amazonTokenId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling linkAmazonAuthToken.');
            }
            // verify required parameter 'amazonTokenId' is not null or undefined
            if (amazonTokenId === null || amazonTokenId === undefined) {
                throw new RequiredError('amazonTokenId','Required parameter amazonTokenId was null or undefined when calling linkAmazonAuthToken.');
            }
            const localVarPath = `/api/ApplicationDeployment/{applicationId}/amazonAuthToken/{amazonTokenId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"amazonTokenId"}}`, encodeURIComponent(String(amazonTokenId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAzureSubscription(applicationId: string, subscriptionId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling linkAzureSubscription.');
            }
            // verify required parameter 'subscriptionId' is not null or undefined
            if (subscriptionId === null || subscriptionId === undefined) {
                throw new RequiredError('subscriptionId','Required parameter subscriptionId was null or undefined when calling linkAzureSubscription.');
            }
            const localVarPath = `/api/ApplicationDeployment/{applicationId}/azureSubscriptions/{subscriptionId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [dialogflowAgentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDialogflowAgentId(applicationId: string, dialogflowAgentId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling linkDialogflowAgentId.');
            }
            const localVarPath = `/api/ApplicationDeployment/{applicationId}/dialogflowAgent`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (dialogflowAgentId !== undefined) {
                localVarQueryParameter['dialogflowAgentId'] = dialogflowAgentId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} googleTokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkGoogleAuthToken(applicationId: string, googleTokenId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling linkGoogleAuthToken.');
            }
            // verify required parameter 'googleTokenId' is not null or undefined
            if (googleTokenId === null || googleTokenId === undefined) {
                throw new RequiredError('googleTokenId','Required parameter googleTokenId was null or undefined when calling linkGoogleAuthToken.');
            }
            const localVarPath = `/api/ApplicationDeployment/{applicationId}/googleAuthToken/{googleTokenId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"googleTokenId"}}`, encodeURIComponent(String(googleTokenId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} luisAppId 
         * @param {string} [luisRegion] 
         * @param {string} [locale] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkLuisApp(applicationId: string, luisAppId: string, luisRegion?: string, locale?: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling linkLuisApp.');
            }
            // verify required parameter 'luisAppId' is not null or undefined
            if (luisAppId === null || luisAppId === undefined) {
                throw new RequiredError('luisAppId','Required parameter luisAppId was null or undefined when calling linkLuisApp.');
            }
            const localVarPath = `/api/ApplicationDeployment/{applicationId}/luisApp/{luisAppId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"luisAppId"}}`, encodeURIComponent(String(luisAppId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (luisRegion !== undefined) {
                localVarQueryParameter['luisRegion'] = luisRegion;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} luisKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkLuisAuthoringKey(applicationId: string, luisKey: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling linkLuisAuthoringKey.');
            }
            // verify required parameter 'luisKey' is not null or undefined
            if (luisKey === null || luisKey === undefined) {
                throw new RequiredError('luisKey','Required parameter luisKey was null or undefined when calling linkLuisAuthoringKey.');
            }
            const localVarPath = `/api/ApplicationDeployment/{applicationId}/luisKey/{luisKey}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"luisKey"}}`, encodeURIComponent(String(luisKey)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {UpdateMicrosoftAppInfoRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkMicrosoftApp(applicationId: string, model?: UpdateMicrosoftAppInfoRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling linkMicrosoftApp.');
            }
            const localVarPath = `/api/ApplicationDeployment/{applicationId}/microsoftProject`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateMicrosoftAppInfoRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} microsoftTokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkMicrosoftAuthToken(applicationId: string, microsoftTokenId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling linkMicrosoftAuthToken.');
            }
            // verify required parameter 'microsoftTokenId' is not null or undefined
            if (microsoftTokenId === null || microsoftTokenId === undefined) {
                throw new RequiredError('microsoftTokenId','Required parameter microsoftTokenId was null or undefined when calling linkMicrosoftAuthToken.');
            }
            const localVarPath = `/api/ApplicationDeployment/{applicationId}/microsoftAuthToken/{microsoftTokenId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"microsoftTokenId"}}`, encodeURIComponent(String(microsoftTokenId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAlexaVendor(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling removeAlexaVendor.');
            }
            const localVarPath = `/api/ApplicationDeployment/{applicationId}/alexaVendor`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAmazonAuthToken(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling removeAmazonAuthToken.');
            }
            const localVarPath = `/api/ApplicationDeployment/{applicationId}/amazonAuthToken`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAzureSubscription(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling removeAzureSubscription.');
            }
            const localVarPath = `/api/ApplicationDeployment/{applicationId}/azureSubscription`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeGoogleAuthToken(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling removeGoogleAuthToken.');
            }
            const localVarPath = `/api/ApplicationDeployment/{applicationId}/googleAuthToken`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkAlexaSkill(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling unlinkAlexaSkill.');
            }
            const localVarPath = `/api/ApplicationDeployment/{applicationId}/alexaSkill`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkDialogflowAgent(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling unlinkDialogflowAgent.');
            }
            const localVarPath = `/api/ApplicationDeployment/{applicationId}/dialogflowAgent`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkLuisApp(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling unlinkLuisApp.');
            }
            const localVarPath = `/api/ApplicationDeployment/{applicationId}/luisApp`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkMicrosoftProject(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling unlinkMicrosoftProject.');
            }
            const localVarPath = `/api/ApplicationDeployment/{applicationId}/microsoftProject`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationDeploymentApi - functional programming interface
 * @export
 */
export const ApplicationDeploymentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [luisRegion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployNewLuisApp(applicationId: string, luisRegion?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NewLuisAppResponse> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).deployNewLuisApp(applicationId, luisRegion, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployNewSkill(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NewSkillResponse> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).deployNewSkill(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlexaVendors(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AlexaVendorResponse> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).getAlexaVendors(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationLinkToAmazon(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeploymentLink> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).getApplicationLinkToAmazon(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationLinkToGoogle(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeploymentLink> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).getApplicationLinkToGoogle(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationLinkToMicrosoft(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MicrosoftDeploymentLink> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).getApplicationLinkToMicrosoft(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationsLinkedToAmazon(organizationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ApplicationsByAmazonAccount>> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).getApplicationsLinkedToAmazon(organizationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationsLinkedToGoogle(organizationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ApplicationsByGoogleAccount>> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).getApplicationsLinkedToGoogle(organizationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationsLinkedToMicrosoft(organizationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ApplicationsByMicrosoftAccount>> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).getApplicationsLinkedToMicrosoft(organizationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} alexaSkillId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAlexaSkillId(applicationId: string, alexaSkillId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).linkAlexaSkillId(applicationId, alexaSkillId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} vendorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAlexaVendor(applicationId: string, vendorId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).linkAlexaVendor(applicationId, vendorId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} amazonTokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAmazonAuthToken(applicationId: string, amazonTokenId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).linkAmazonAuthToken(applicationId, amazonTokenId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAzureSubscription(applicationId: string, subscriptionId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).linkAzureSubscription(applicationId, subscriptionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [dialogflowAgentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDialogflowAgentId(applicationId: string, dialogflowAgentId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).linkDialogflowAgentId(applicationId, dialogflowAgentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} googleTokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkGoogleAuthToken(applicationId: string, googleTokenId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).linkGoogleAuthToken(applicationId, googleTokenId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} luisAppId 
         * @param {string} [luisRegion] 
         * @param {string} [locale] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkLuisApp(applicationId: string, luisAppId: string, luisRegion?: string, locale?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).linkLuisApp(applicationId, luisAppId, luisRegion, locale, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} luisKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkLuisAuthoringKey(applicationId: string, luisKey: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).linkLuisAuthoringKey(applicationId, luisKey, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {UpdateMicrosoftAppInfoRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkMicrosoftApp(applicationId: string, model?: UpdateMicrosoftAppInfoRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).linkMicrosoftApp(applicationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} microsoftTokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkMicrosoftAuthToken(applicationId: string, microsoftTokenId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).linkMicrosoftAuthToken(applicationId, microsoftTokenId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAlexaVendor(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).removeAlexaVendor(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAmazonAuthToken(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).removeAmazonAuthToken(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAzureSubscription(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).removeAzureSubscription(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeGoogleAuthToken(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).removeGoogleAuthToken(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkAlexaSkill(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).unlinkAlexaSkill(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkDialogflowAgent(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).unlinkDialogflowAgent(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkLuisApp(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).unlinkLuisApp(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkMicrosoftProject(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ApplicationDeploymentApiFetchParamCreator(configuration).unlinkMicrosoftProject(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ApplicationDeploymentApi - factory interface
 * @export
 */
export const ApplicationDeploymentApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [luisRegion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployNewLuisApp(applicationId: string, luisRegion?: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).deployNewLuisApp(applicationId, luisRegion, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deployNewSkill(applicationId: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).deployNewSkill(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlexaVendors(applicationId: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).getAlexaVendors(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationLinkToAmazon(applicationId: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).getApplicationLinkToAmazon(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationLinkToGoogle(applicationId: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).getApplicationLinkToGoogle(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationLinkToMicrosoft(applicationId: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).getApplicationLinkToMicrosoft(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationsLinkedToAmazon(organizationId: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).getApplicationsLinkedToAmazon(organizationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationsLinkedToGoogle(organizationId: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).getApplicationsLinkedToGoogle(organizationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationsLinkedToMicrosoft(organizationId: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).getApplicationsLinkedToMicrosoft(organizationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} alexaSkillId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAlexaSkillId(applicationId: string, alexaSkillId: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).linkAlexaSkillId(applicationId, alexaSkillId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} vendorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAlexaVendor(applicationId: string, vendorId: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).linkAlexaVendor(applicationId, vendorId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} amazonTokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAmazonAuthToken(applicationId: string, amazonTokenId: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).linkAmazonAuthToken(applicationId, amazonTokenId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} subscriptionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkAzureSubscription(applicationId: string, subscriptionId: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).linkAzureSubscription(applicationId, subscriptionId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [dialogflowAgentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkDialogflowAgentId(applicationId: string, dialogflowAgentId?: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).linkDialogflowAgentId(applicationId, dialogflowAgentId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} googleTokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkGoogleAuthToken(applicationId: string, googleTokenId: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).linkGoogleAuthToken(applicationId, googleTokenId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} luisAppId 
         * @param {string} [luisRegion] 
         * @param {string} [locale] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkLuisApp(applicationId: string, luisAppId: string, luisRegion?: string, locale?: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).linkLuisApp(applicationId, luisAppId, luisRegion, locale, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} luisKey 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkLuisAuthoringKey(applicationId: string, luisKey: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).linkLuisAuthoringKey(applicationId, luisKey, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {UpdateMicrosoftAppInfoRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkMicrosoftApp(applicationId: string, model?: UpdateMicrosoftAppInfoRequest, options?: any) {
            return ApplicationDeploymentApiFp(configuration).linkMicrosoftApp(applicationId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} microsoftTokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkMicrosoftAuthToken(applicationId: string, microsoftTokenId: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).linkMicrosoftAuthToken(applicationId, microsoftTokenId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAlexaVendor(applicationId: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).removeAlexaVendor(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAmazonAuthToken(applicationId: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).removeAmazonAuthToken(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAzureSubscription(applicationId: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).removeAzureSubscription(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeGoogleAuthToken(applicationId: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).removeGoogleAuthToken(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkAlexaSkill(applicationId: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).unlinkAlexaSkill(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkDialogflowAgent(applicationId: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).unlinkDialogflowAgent(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkLuisApp(applicationId: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).unlinkLuisApp(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlinkMicrosoftProject(applicationId: string, options?: any) {
            return ApplicationDeploymentApiFp(configuration).unlinkMicrosoftProject(applicationId, options)(fetch, basePath);
        },
    };
};

/**
 * ApplicationDeploymentApi - interface
 * @export
 * @interface ApplicationDeploymentApi
 */
export interface ApplicationDeploymentApiInterface {
    /**
     * 
     * @param {string} applicationId 
     * @param {string} [luisRegion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    deployNewLuisApp(applicationId: string, luisRegion?: string, options?: any): Promise<NewLuisAppResponse>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    deployNewSkill(applicationId: string, options?: any): Promise<NewSkillResponse>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    getAlexaVendors(applicationId: string, options?: any): Promise<AlexaVendorResponse>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    getApplicationLinkToAmazon(applicationId: string, options?: any): Promise<DeploymentLink>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    getApplicationLinkToGoogle(applicationId: string, options?: any): Promise<DeploymentLink>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    getApplicationLinkToMicrosoft(applicationId: string, options?: any): Promise<MicrosoftDeploymentLink>;

    /**
     * 
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    getApplicationsLinkedToAmazon(organizationId: string, options?: any): Promise<Array<ApplicationsByAmazonAccount>>;

    /**
     * 
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    getApplicationsLinkedToGoogle(organizationId: string, options?: any): Promise<Array<ApplicationsByGoogleAccount>>;

    /**
     * 
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    getApplicationsLinkedToMicrosoft(organizationId: string, options?: any): Promise<Array<ApplicationsByMicrosoftAccount>>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} alexaSkillId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    linkAlexaSkillId(applicationId: string, alexaSkillId: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} vendorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    linkAlexaVendor(applicationId: string, vendorId: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} amazonTokenId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    linkAmazonAuthToken(applicationId: string, amazonTokenId: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} subscriptionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    linkAzureSubscription(applicationId: string, subscriptionId: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} [dialogflowAgentId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    linkDialogflowAgentId(applicationId: string, dialogflowAgentId?: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} googleTokenId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    linkGoogleAuthToken(applicationId: string, googleTokenId: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} luisAppId 
     * @param {string} [luisRegion] 
     * @param {string} [locale] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    linkLuisApp(applicationId: string, luisAppId: string, luisRegion?: string, locale?: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} luisKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    linkLuisAuthoringKey(applicationId: string, luisKey: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} applicationId 
     * @param {UpdateMicrosoftAppInfoRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    linkMicrosoftApp(applicationId: string, model?: UpdateMicrosoftAppInfoRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} microsoftTokenId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    linkMicrosoftAuthToken(applicationId: string, microsoftTokenId: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    removeAlexaVendor(applicationId: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    removeAmazonAuthToken(applicationId: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    removeAzureSubscription(applicationId: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    removeGoogleAuthToken(applicationId: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    unlinkAlexaSkill(applicationId: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    unlinkDialogflowAgent(applicationId: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    unlinkLuisApp(applicationId: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApiInterface
     */
    unlinkMicrosoftProject(applicationId: string, options?: any): Promise<boolean>;

}

/**
 * ApplicationDeploymentApi - object-oriented interface
 * @export
 * @class ApplicationDeploymentApi
 * @extends {BaseAPI}
 */
export class ApplicationDeploymentApi extends BaseAPI implements ApplicationDeploymentApiInterface {
    /**
     * 
     * @param {string} applicationId 
     * @param {string} [luisRegion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public deployNewLuisApp(applicationId: string, luisRegion?: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).deployNewLuisApp(applicationId, luisRegion, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public deployNewSkill(applicationId: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).deployNewSkill(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public getAlexaVendors(applicationId: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).getAlexaVendors(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public getApplicationLinkToAmazon(applicationId: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).getApplicationLinkToAmazon(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public getApplicationLinkToGoogle(applicationId: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).getApplicationLinkToGoogle(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public getApplicationLinkToMicrosoft(applicationId: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).getApplicationLinkToMicrosoft(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public getApplicationsLinkedToAmazon(organizationId: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).getApplicationsLinkedToAmazon(organizationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public getApplicationsLinkedToGoogle(organizationId: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).getApplicationsLinkedToGoogle(organizationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public getApplicationsLinkedToMicrosoft(organizationId: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).getApplicationsLinkedToMicrosoft(organizationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} alexaSkillId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public linkAlexaSkillId(applicationId: string, alexaSkillId: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).linkAlexaSkillId(applicationId, alexaSkillId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} vendorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public linkAlexaVendor(applicationId: string, vendorId: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).linkAlexaVendor(applicationId, vendorId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} amazonTokenId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public linkAmazonAuthToken(applicationId: string, amazonTokenId: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).linkAmazonAuthToken(applicationId, amazonTokenId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} subscriptionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public linkAzureSubscription(applicationId: string, subscriptionId: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).linkAzureSubscription(applicationId, subscriptionId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} [dialogflowAgentId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public linkDialogflowAgentId(applicationId: string, dialogflowAgentId?: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).linkDialogflowAgentId(applicationId, dialogflowAgentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} googleTokenId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public linkGoogleAuthToken(applicationId: string, googleTokenId: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).linkGoogleAuthToken(applicationId, googleTokenId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} luisAppId 
     * @param {string} [luisRegion] 
     * @param {string} [locale] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public linkLuisApp(applicationId: string, luisAppId: string, luisRegion?: string, locale?: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).linkLuisApp(applicationId, luisAppId, luisRegion, locale, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} luisKey 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public linkLuisAuthoringKey(applicationId: string, luisKey: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).linkLuisAuthoringKey(applicationId, luisKey, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {UpdateMicrosoftAppInfoRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public linkMicrosoftApp(applicationId: string, model?: UpdateMicrosoftAppInfoRequest, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).linkMicrosoftApp(applicationId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} microsoftTokenId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public linkMicrosoftAuthToken(applicationId: string, microsoftTokenId: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).linkMicrosoftAuthToken(applicationId, microsoftTokenId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public removeAlexaVendor(applicationId: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).removeAlexaVendor(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public removeAmazonAuthToken(applicationId: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).removeAmazonAuthToken(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public removeAzureSubscription(applicationId: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).removeAzureSubscription(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public removeGoogleAuthToken(applicationId: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).removeGoogleAuthToken(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public unlinkAlexaSkill(applicationId: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).unlinkAlexaSkill(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public unlinkDialogflowAgent(applicationId: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).unlinkDialogflowAgent(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public unlinkLuisApp(applicationId: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).unlinkLuisApp(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationDeploymentApi
     */
    public unlinkMicrosoftProject(applicationId: string, options?: any) {
        return ApplicationDeploymentApiFp(this.configuration).unlinkMicrosoftProject(applicationId, options)(this.fetch, this.basePath);
    }

}

/**
 * ApplicationTemplatingApi - fetch parameter creator
 * @export
 */
export const ApplicationTemplatingApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {CompleteTemplateFormModel} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAppliedApplicationTemplateForm(applicationId: string, request?: CompleteTemplateFormModel, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling addAppliedApplicationTemplateForm.');
            }
            const localVarPath = `/api/ApplicationTemplating/{applicationId}/addAppliedApplicationTemplateForm`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CompleteTemplateFormModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateApplicationFromCompletedFormsRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationFromForms(request?: CreateApplicationFromCompletedFormsRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/ApplicationTemplating/CreateFromForm`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateApplicationFromCompletedFormsRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} applicationTemplateFormId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAppliedApplicationTemplateForm(applicationId: string, applicationTemplateFormId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling removeAppliedApplicationTemplateForm.');
            }
            // verify required parameter 'applicationTemplateFormId' is not null or undefined
            if (applicationTemplateFormId === null || applicationTemplateFormId === undefined) {
                throw new RequiredError('applicationTemplateFormId','Required parameter applicationTemplateFormId was null or undefined when calling removeAppliedApplicationTemplateForm.');
            }
            const localVarPath = `/api/ApplicationTemplating/{applicationId}/RemoveAppliedApplicationTemplateForm/{applicationTemplateFormId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"applicationTemplateFormId"}}`, encodeURIComponent(String(applicationTemplateFormId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} applicationTemplateFormId 
         * @param {UpdateAppliedApplicationTemplateFormRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAppliedApplicationTemplateForm(applicationId: string, applicationTemplateFormId: string, request?: UpdateAppliedApplicationTemplateFormRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling updateAppliedApplicationTemplateForm.');
            }
            // verify required parameter 'applicationTemplateFormId' is not null or undefined
            if (applicationTemplateFormId === null || applicationTemplateFormId === undefined) {
                throw new RequiredError('applicationTemplateFormId','Required parameter applicationTemplateFormId was null or undefined when calling updateAppliedApplicationTemplateForm.');
            }
            const localVarPath = `/api/ApplicationTemplating/{applicationId}/UpdateAppliedApplicationTemplateForm/{applicationTemplateFormId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"applicationTemplateFormId"}}`, encodeURIComponent(String(applicationTemplateFormId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateAppliedApplicationTemplateFormRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApplicationTemplatingApi - functional programming interface
 * @export
 */
export const ApplicationTemplatingApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {CompleteTemplateFormModel} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAppliedApplicationTemplateForm(applicationId: string, request?: CompleteTemplateFormModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AppliedApplicationTemplateFormModel> {
            const localVarFetchArgs = ApplicationTemplatingApiFetchParamCreator(configuration).addAppliedApplicationTemplateForm(applicationId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CreateApplicationFromCompletedFormsRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationFromForms(request?: CreateApplicationFromCompletedFormsRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationModel> {
            const localVarFetchArgs = ApplicationTemplatingApiFetchParamCreator(configuration).createApplicationFromForms(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} applicationTemplateFormId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAppliedApplicationTemplateForm(applicationId: string, applicationTemplateFormId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AppliedApplicationTemplateFormModel> {
            const localVarFetchArgs = ApplicationTemplatingApiFetchParamCreator(configuration).removeAppliedApplicationTemplateForm(applicationId, applicationTemplateFormId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} applicationTemplateFormId 
         * @param {UpdateAppliedApplicationTemplateFormRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAppliedApplicationTemplateForm(applicationId: string, applicationTemplateFormId: string, request?: UpdateAppliedApplicationTemplateFormRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AppliedApplicationTemplateFormModel> {
            const localVarFetchArgs = ApplicationTemplatingApiFetchParamCreator(configuration).updateAppliedApplicationTemplateForm(applicationId, applicationTemplateFormId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ApplicationTemplatingApi - factory interface
 * @export
 */
export const ApplicationTemplatingApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {CompleteTemplateFormModel} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAppliedApplicationTemplateForm(applicationId: string, request?: CompleteTemplateFormModel, options?: any) {
            return ApplicationTemplatingApiFp(configuration).addAppliedApplicationTemplateForm(applicationId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CreateApplicationFromCompletedFormsRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApplicationFromForms(request?: CreateApplicationFromCompletedFormsRequest, options?: any) {
            return ApplicationTemplatingApiFp(configuration).createApplicationFromForms(request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} applicationTemplateFormId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeAppliedApplicationTemplateForm(applicationId: string, applicationTemplateFormId: string, options?: any) {
            return ApplicationTemplatingApiFp(configuration).removeAppliedApplicationTemplateForm(applicationId, applicationTemplateFormId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} applicationTemplateFormId 
         * @param {UpdateAppliedApplicationTemplateFormRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAppliedApplicationTemplateForm(applicationId: string, applicationTemplateFormId: string, request?: UpdateAppliedApplicationTemplateFormRequest, options?: any) {
            return ApplicationTemplatingApiFp(configuration).updateAppliedApplicationTemplateForm(applicationId, applicationTemplateFormId, request, options)(fetch, basePath);
        },
    };
};

/**
 * ApplicationTemplatingApi - interface
 * @export
 * @interface ApplicationTemplatingApi
 */
export interface ApplicationTemplatingApiInterface {
    /**
     * 
     * @param {string} applicationId 
     * @param {CompleteTemplateFormModel} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationTemplatingApiInterface
     */
    addAppliedApplicationTemplateForm(applicationId: string, request?: CompleteTemplateFormModel, options?: any): Promise<AppliedApplicationTemplateFormModel>;

    /**
     * 
     * @param {CreateApplicationFromCompletedFormsRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationTemplatingApiInterface
     */
    createApplicationFromForms(request?: CreateApplicationFromCompletedFormsRequest, options?: any): Promise<ApplicationModel>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} applicationTemplateFormId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationTemplatingApiInterface
     */
    removeAppliedApplicationTemplateForm(applicationId: string, applicationTemplateFormId: string, options?: any): Promise<AppliedApplicationTemplateFormModel>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} applicationTemplateFormId 
     * @param {UpdateAppliedApplicationTemplateFormRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationTemplatingApiInterface
     */
    updateAppliedApplicationTemplateForm(applicationId: string, applicationTemplateFormId: string, request?: UpdateAppliedApplicationTemplateFormRequest, options?: any): Promise<AppliedApplicationTemplateFormModel>;

}

/**
 * ApplicationTemplatingApi - object-oriented interface
 * @export
 * @class ApplicationTemplatingApi
 * @extends {BaseAPI}
 */
export class ApplicationTemplatingApi extends BaseAPI implements ApplicationTemplatingApiInterface {
    /**
     * 
     * @param {string} applicationId 
     * @param {CompleteTemplateFormModel} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationTemplatingApi
     */
    public addAppliedApplicationTemplateForm(applicationId: string, request?: CompleteTemplateFormModel, options?: any) {
        return ApplicationTemplatingApiFp(this.configuration).addAppliedApplicationTemplateForm(applicationId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CreateApplicationFromCompletedFormsRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationTemplatingApi
     */
    public createApplicationFromForms(request?: CreateApplicationFromCompletedFormsRequest, options?: any) {
        return ApplicationTemplatingApiFp(this.configuration).createApplicationFromForms(request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} applicationTemplateFormId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationTemplatingApi
     */
    public removeAppliedApplicationTemplateForm(applicationId: string, applicationTemplateFormId: string, options?: any) {
        return ApplicationTemplatingApiFp(this.configuration).removeAppliedApplicationTemplateForm(applicationId, applicationTemplateFormId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} applicationTemplateFormId 
     * @param {UpdateAppliedApplicationTemplateFormRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApplicationTemplatingApi
     */
    public updateAppliedApplicationTemplateForm(applicationId: string, applicationTemplateFormId: string, request?: UpdateAppliedApplicationTemplateFormRequest, options?: any) {
        return ApplicationTemplatingApiFp(this.configuration).updateAppliedApplicationTemplateForm(applicationId, applicationTemplateFormId, request, options)(this.fetch, this.basePath);
    }

}

/**
 * AppliedApplicationTemplateApi - fetch parameter creator
 * @export
 */
export const AppliedApplicationTemplateApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {string} templateConfigurationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAppliedTemplateToApp(applicationId: string, templateConfigurationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling addAppliedTemplateToApp.');
            }
            // verify required parameter 'templateConfigurationId' is not null or undefined
            if (templateConfigurationId === null || templateConfigurationId === undefined) {
                throw new RequiredError('templateConfigurationId','Required parameter templateConfigurationId was null or undefined when calling addAppliedTemplateToApp.');
            }
            const localVarPath = `/api/AppliedApplicationTemplate/{applicationId}/add/{templateConfigurationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"templateConfigurationId"}}`, encodeURIComponent(String(templateConfigurationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appliedApplicationTemplateFormId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAppliedTemplate(appliedApplicationTemplateFormId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appliedApplicationTemplateFormId' is not null or undefined
            if (appliedApplicationTemplateFormId === null || appliedApplicationTemplateFormId === undefined) {
                throw new RequiredError('appliedApplicationTemplateFormId','Required parameter appliedApplicationTemplateFormId was null or undefined when calling deleteAppliedTemplate.');
            }
            const localVarPath = `/api/AppliedApplicationTemplate/{appliedApplicationTemplateFormId}`
                .replace(`{${"appliedApplicationTemplateFormId"}}`, encodeURIComponent(String(appliedApplicationTemplateFormId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appliedApplicationTemplateFormId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAppliedTemplateById(appliedApplicationTemplateFormId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appliedApplicationTemplateFormId' is not null or undefined
            if (appliedApplicationTemplateFormId === null || appliedApplicationTemplateFormId === undefined) {
                throw new RequiredError('appliedApplicationTemplateFormId','Required parameter appliedApplicationTemplateFormId was null or undefined when calling findAppliedTemplateById.');
            }
            const localVarPath = `/api/AppliedApplicationTemplate/{appliedApplicationTemplateFormId}`
                .replace(`{${"appliedApplicationTemplateFormId"}}`, encodeURIComponent(String(appliedApplicationTemplateFormId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppliedTemplatesForApplication(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getAppliedTemplatesForApplication.');
            }
            const localVarPath = `/api/AppliedApplicationTemplate/forApp/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} appliedApplicationTemplateFormId 
         * @param {UpdateAppliedApplicationTemplateFormRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAppliedTemplate(appliedApplicationTemplateFormId: string, model?: UpdateAppliedApplicationTemplateFormRequest, options: any = {}): FetchArgs {
            // verify required parameter 'appliedApplicationTemplateFormId' is not null or undefined
            if (appliedApplicationTemplateFormId === null || appliedApplicationTemplateFormId === undefined) {
                throw new RequiredError('appliedApplicationTemplateFormId','Required parameter appliedApplicationTemplateFormId was null or undefined when calling updateAppliedTemplate.');
            }
            const localVarPath = `/api/AppliedApplicationTemplate/{appliedApplicationTemplateFormId}`
                .replace(`{${"appliedApplicationTemplateFormId"}}`, encodeURIComponent(String(appliedApplicationTemplateFormId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateAppliedApplicationTemplateFormRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppliedApplicationTemplateApi - functional programming interface
 * @export
 */
export const AppliedApplicationTemplateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {string} templateConfigurationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAppliedTemplateToApp(applicationId: string, templateConfigurationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AppliedApplicationTemplateFormModel> {
            const localVarFetchArgs = AppliedApplicationTemplateApiFetchParamCreator(configuration).addAppliedTemplateToApp(applicationId, templateConfigurationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} appliedApplicationTemplateFormId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAppliedTemplate(appliedApplicationTemplateFormId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AppliedApplicationTemplateFormModel> {
            const localVarFetchArgs = AppliedApplicationTemplateApiFetchParamCreator(configuration).deleteAppliedTemplate(appliedApplicationTemplateFormId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} appliedApplicationTemplateFormId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAppliedTemplateById(appliedApplicationTemplateFormId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AppliedApplicationTemplateFormModel> {
            const localVarFetchArgs = AppliedApplicationTemplateApiFetchParamCreator(configuration).findAppliedTemplateById(appliedApplicationTemplateFormId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppliedTemplatesForApplication(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AppliedApplicationTemplateFormModel>> {
            const localVarFetchArgs = AppliedApplicationTemplateApiFetchParamCreator(configuration).getAppliedTemplatesForApplication(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} appliedApplicationTemplateFormId 
         * @param {UpdateAppliedApplicationTemplateFormRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAppliedTemplate(appliedApplicationTemplateFormId: string, model?: UpdateAppliedApplicationTemplateFormRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AppliedApplicationTemplateFormModel> {
            const localVarFetchArgs = AppliedApplicationTemplateApiFetchParamCreator(configuration).updateAppliedTemplate(appliedApplicationTemplateFormId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AppliedApplicationTemplateApi - factory interface
 * @export
 */
export const AppliedApplicationTemplateApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {string} templateConfigurationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAppliedTemplateToApp(applicationId: string, templateConfigurationId: string, options?: any) {
            return AppliedApplicationTemplateApiFp(configuration).addAppliedTemplateToApp(applicationId, templateConfigurationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} appliedApplicationTemplateFormId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAppliedTemplate(appliedApplicationTemplateFormId: string, options?: any) {
            return AppliedApplicationTemplateApiFp(configuration).deleteAppliedTemplate(appliedApplicationTemplateFormId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} appliedApplicationTemplateFormId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAppliedTemplateById(appliedApplicationTemplateFormId: string, options?: any) {
            return AppliedApplicationTemplateApiFp(configuration).findAppliedTemplateById(appliedApplicationTemplateFormId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppliedTemplatesForApplication(applicationId: string, options?: any) {
            return AppliedApplicationTemplateApiFp(configuration).getAppliedTemplatesForApplication(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} appliedApplicationTemplateFormId 
         * @param {UpdateAppliedApplicationTemplateFormRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAppliedTemplate(appliedApplicationTemplateFormId: string, model?: UpdateAppliedApplicationTemplateFormRequest, options?: any) {
            return AppliedApplicationTemplateApiFp(configuration).updateAppliedTemplate(appliedApplicationTemplateFormId, model, options)(fetch, basePath);
        },
    };
};

/**
 * AppliedApplicationTemplateApi - interface
 * @export
 * @interface AppliedApplicationTemplateApi
 */
export interface AppliedApplicationTemplateApiInterface {
    /**
     * 
     * @param {string} applicationId 
     * @param {string} templateConfigurationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppliedApplicationTemplateApiInterface
     */
    addAppliedTemplateToApp(applicationId: string, templateConfigurationId: string, options?: any): Promise<AppliedApplicationTemplateFormModel>;

    /**
     * 
     * @param {string} appliedApplicationTemplateFormId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppliedApplicationTemplateApiInterface
     */
    deleteAppliedTemplate(appliedApplicationTemplateFormId: string, options?: any): Promise<AppliedApplicationTemplateFormModel>;

    /**
     * 
     * @param {string} appliedApplicationTemplateFormId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppliedApplicationTemplateApiInterface
     */
    findAppliedTemplateById(appliedApplicationTemplateFormId: string, options?: any): Promise<AppliedApplicationTemplateFormModel>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppliedApplicationTemplateApiInterface
     */
    getAppliedTemplatesForApplication(applicationId: string, options?: any): Promise<Array<AppliedApplicationTemplateFormModel>>;

    /**
     * 
     * @param {string} appliedApplicationTemplateFormId 
     * @param {UpdateAppliedApplicationTemplateFormRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppliedApplicationTemplateApiInterface
     */
    updateAppliedTemplate(appliedApplicationTemplateFormId: string, model?: UpdateAppliedApplicationTemplateFormRequest, options?: any): Promise<AppliedApplicationTemplateFormModel>;

}

/**
 * AppliedApplicationTemplateApi - object-oriented interface
 * @export
 * @class AppliedApplicationTemplateApi
 * @extends {BaseAPI}
 */
export class AppliedApplicationTemplateApi extends BaseAPI implements AppliedApplicationTemplateApiInterface {
    /**
     * 
     * @param {string} applicationId 
     * @param {string} templateConfigurationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppliedApplicationTemplateApi
     */
    public addAppliedTemplateToApp(applicationId: string, templateConfigurationId: string, options?: any) {
        return AppliedApplicationTemplateApiFp(this.configuration).addAppliedTemplateToApp(applicationId, templateConfigurationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} appliedApplicationTemplateFormId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppliedApplicationTemplateApi
     */
    public deleteAppliedTemplate(appliedApplicationTemplateFormId: string, options?: any) {
        return AppliedApplicationTemplateApiFp(this.configuration).deleteAppliedTemplate(appliedApplicationTemplateFormId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} appliedApplicationTemplateFormId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppliedApplicationTemplateApi
     */
    public findAppliedTemplateById(appliedApplicationTemplateFormId: string, options?: any) {
        return AppliedApplicationTemplateApiFp(this.configuration).findAppliedTemplateById(appliedApplicationTemplateFormId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppliedApplicationTemplateApi
     */
    public getAppliedTemplatesForApplication(applicationId: string, options?: any) {
        return AppliedApplicationTemplateApiFp(this.configuration).getAppliedTemplatesForApplication(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} appliedApplicationTemplateFormId 
     * @param {UpdateAppliedApplicationTemplateFormRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppliedApplicationTemplateApi
     */
    public updateAppliedTemplate(appliedApplicationTemplateFormId: string, model?: UpdateAppliedApplicationTemplateFormRequest, options?: any) {
        return AppliedApplicationTemplateApiFp(this.configuration).updateAppliedTemplate(appliedApplicationTemplateFormId, model, options)(this.fetch, this.basePath);
    }

}

/**
 * AuthenticationApi - fetch parameter creator
 * @export
 */
export const AuthenticationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authenticate the specified model.  Model is from query string to ensure oauth standards
         * @param {string} clientId 
         * @param {string} clientSecret 
         * @param {string} grantType 
         * @param {string} username 
         * @param {string} [password] 
         * @param {string} [refreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(clientId: string, clientSecret: string, grantType: string, username: string, password?: string, refreshToken?: string, options: any = {}): FetchArgs {
            // verify required parameter 'clientId' is not null or undefined
            if (clientId === null || clientId === undefined) {
                throw new RequiredError('clientId','Required parameter clientId was null or undefined when calling authenticate.');
            }
            // verify required parameter 'clientSecret' is not null or undefined
            if (clientSecret === null || clientSecret === undefined) {
                throw new RequiredError('clientSecret','Required parameter clientSecret was null or undefined when calling authenticate.');
            }
            // verify required parameter 'grantType' is not null or undefined
            if (grantType === null || grantType === undefined) {
                throw new RequiredError('grantType','Required parameter grantType was null or undefined when calling authenticate.');
            }
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username','Required parameter username was null or undefined when calling authenticate.');
            }
            const localVarPath = `/api/Authentication`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['ClientId'] = clientId;
            }

            if (clientSecret !== undefined) {
                localVarQueryParameter['ClientSecret'] = clientSecret;
            }

            if (grantType !== undefined) {
                localVarQueryParameter['GrantType'] = grantType;
            }

            if (username !== undefined) {
                localVarQueryParameter['Username'] = username;
            }

            if (password !== undefined) {
                localVarQueryParameter['Password'] = password;
            }

            if (refreshToken !== undefined) {
                localVarQueryParameter['RefreshToken'] = refreshToken;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Endpoint for testing if the user is authenticated and an admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAdminAuth(options: any = {}): FetchArgs {
            const localVarPath = `/api/Authentication/test/admin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Endpoint for testing if a user is authenticated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAuth(options: any = {}): FetchArgs {
            const localVarPath = `/api/Authentication/test`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};
/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Authenticate the specified model.  Model is from query string to ensure oauth standards
         * @param {string} clientId 
         * @param {string} clientSecret 
         * @param {string} grantType 
         * @param {string} username 
         * @param {string} [password] 
         * @param {string} [refreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(clientId: string, clientSecret: string, grantType: string, username: string, password?: string, refreshToken?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AuthenticationResponse> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).authenticate(clientId, clientSecret, grantType, username, password, refreshToken, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Endpoint for testing if the user is authenticated and an admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAdminAuth(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).testAdminAuth(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Endpoint for testing if a user is authenticated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAuth(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AuthenticationApiFetchParamCreator(configuration).testAuth(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Authenticate the specified model.  Model is from query string to ensure oauth standards
         * @param {string} clientId 
         * @param {string} clientSecret 
         * @param {string} grantType 
         * @param {string} username 
         * @param {string} [password] 
         * @param {string} [refreshToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticate(clientId: string, clientSecret: string, grantType: string, username: string, password?: string, refreshToken?: string, options?: any) {
            return AuthenticationApiFp(configuration).authenticate(clientId, clientSecret, grantType, username, password, refreshToken, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Endpoint for testing if the user is authenticated and an admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAdminAuth(options?: any) {
            return AuthenticationApiFp(configuration).testAdminAuth(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Endpoint for testing if a user is authenticated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAuth(options?: any) {
            return AuthenticationApiFp(configuration).testAuth(options)(fetch, basePath);
        },
    };
};

/**
 * AuthenticationApi - interface
 * @export
 * @interface AuthenticationApi
 */
export interface AuthenticationApiInterface {
    /**
     * 
     * @summary Authenticate the specified model.  Model is from query string to ensure oauth standards
     * @param {string} clientId 
     * @param {string} clientSecret 
     * @param {string} grantType 
     * @param {string} username 
     * @param {string} [password] 
     * @param {string} [refreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authenticate(clientId: string, clientSecret: string, grantType: string, username: string, password?: string, refreshToken?: string, options?: any): Promise<AuthenticationResponse>;

    /**
     * 
     * @summary Endpoint for testing if the user is authenticated and an admin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    testAdminAuth(options?: any): Promise<{}>;

    /**
     * 
     * @summary Endpoint for testing if a user is authenticated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    testAuth(options?: any): Promise<{}>;

}

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI implements AuthenticationApiInterface {
    /**
     * 
     * @summary Authenticate the specified model.  Model is from query string to ensure oauth standards
     * @param {string} clientId 
     * @param {string} clientSecret 
     * @param {string} grantType 
     * @param {string} username 
     * @param {string} [password] 
     * @param {string} [refreshToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authenticate(clientId: string, clientSecret: string, grantType: string, username: string, password?: string, refreshToken?: string, options?: any) {
        return AuthenticationApiFp(this.configuration).authenticate(clientId, clientSecret, grantType, username, password, refreshToken, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Endpoint for testing if the user is authenticated and an admin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public testAdminAuth(options?: any) {
        return AuthenticationApiFp(this.configuration).testAdminAuth(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Endpoint for testing if a user is authenticated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public testAuth(options?: any) {
        return AuthenticationApiFp(this.configuration).testAuth(options)(this.fetch, this.basePath);
    }

}

/**
 * AzureApplicationApi - fetch parameter creator
 * @export
 */
export const AzureApplicationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAzureSubscriptions(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getAzureSubscriptions.');
            }
            const localVarPath = `/api/AzureApplication/{applicationId}/azureSubscriptions`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotServiceApps(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getBotServiceApps.');
            }
            const localVarPath = `/api/AzureApplication/{applicationId}/botServiceApps`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLuisApps(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getLuisApps.');
            }
            const localVarPath = `/api/AzureApplication/{applicationId}/luisApps`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AzureApplicationApi - functional programming interface
 * @export
 */
export const AzureApplicationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAzureSubscriptions(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AzureSubscriptionInformation>> {
            const localVarFetchArgs = AzureApplicationApiFetchParamCreator(configuration).getAzureSubscriptions(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotServiceApps(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AzureBotServiceInformation>> {
            const localVarFetchArgs = AzureApplicationApiFetchParamCreator(configuration).getBotServiceApps(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLuisApps(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LuisApplicationInformation>> {
            const localVarFetchArgs = AzureApplicationApiFetchParamCreator(configuration).getLuisApps(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AzureApplicationApi - factory interface
 * @export
 */
export const AzureApplicationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAzureSubscriptions(applicationId: string, options?: any) {
            return AzureApplicationApiFp(configuration).getAzureSubscriptions(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBotServiceApps(applicationId: string, options?: any) {
            return AzureApplicationApiFp(configuration).getBotServiceApps(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLuisApps(applicationId: string, options?: any) {
            return AzureApplicationApiFp(configuration).getLuisApps(applicationId, options)(fetch, basePath);
        },
    };
};

/**
 * AzureApplicationApi - interface
 * @export
 * @interface AzureApplicationApi
 */
export interface AzureApplicationApiInterface {
    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AzureApplicationApiInterface
     */
    getAzureSubscriptions(applicationId: string, options?: any): Promise<Array<AzureSubscriptionInformation>>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AzureApplicationApiInterface
     */
    getBotServiceApps(applicationId: string, options?: any): Promise<Array<AzureBotServiceInformation>>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AzureApplicationApiInterface
     */
    getLuisApps(applicationId: string, options?: any): Promise<Array<LuisApplicationInformation>>;

}

/**
 * AzureApplicationApi - object-oriented interface
 * @export
 * @class AzureApplicationApi
 * @extends {BaseAPI}
 */
export class AzureApplicationApi extends BaseAPI implements AzureApplicationApiInterface {
    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AzureApplicationApi
     */
    public getAzureSubscriptions(applicationId: string, options?: any) {
        return AzureApplicationApiFp(this.configuration).getAzureSubscriptions(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AzureApplicationApi
     */
    public getBotServiceApps(applicationId: string, options?: any) {
        return AzureApplicationApiFp(this.configuration).getBotServiceApps(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AzureApplicationApi
     */
    public getLuisApps(applicationId: string, options?: any) {
        return AzureApplicationApiFp(this.configuration).getLuisApps(applicationId, options)(this.fetch, this.basePath);
    }

}

/**
 * BixbyCapsuleApi - fetch parameter creator
 * @export
 */
export const BixbyCapsuleApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationBixbyProperties(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getApplicationBixbyProperties.');
            }
            const localVarPath = `/api/BixbyCapsule/capsuleProperties/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaseBixbyCapsuleTemplate(options: any = {}): FetchArgs {
            const localVarPath = `/api/BixbyCapsule/baseCapsuleTemplate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BixbyCapsuleApi - functional programming interface
 * @export
 */
export const BixbyCapsuleApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationBixbyProperties(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = BixbyCapsuleApiFetchParamCreator(configuration).getApplicationBixbyProperties(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaseBixbyCapsuleTemplate(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = BixbyCapsuleApiFetchParamCreator(configuration).getBaseBixbyCapsuleTemplate(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BixbyCapsuleApi - factory interface
 * @export
 */
export const BixbyCapsuleApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApplicationBixbyProperties(applicationId: string, options?: any) {
            return BixbyCapsuleApiFp(configuration).getApplicationBixbyProperties(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaseBixbyCapsuleTemplate(options?: any) {
            return BixbyCapsuleApiFp(configuration).getBaseBixbyCapsuleTemplate(options)(fetch, basePath);
        },
    };
};

/**
 * BixbyCapsuleApi - interface
 * @export
 * @interface BixbyCapsuleApi
 */
export interface BixbyCapsuleApiInterface {
    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyCapsuleApiInterface
     */
    getApplicationBixbyProperties(applicationId: string, options?: any): Promise<string>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyCapsuleApiInterface
     */
    getBaseBixbyCapsuleTemplate(options?: any): Promise<string>;

}

/**
 * BixbyCapsuleApi - object-oriented interface
 * @export
 * @class BixbyCapsuleApi
 * @extends {BaseAPI}
 */
export class BixbyCapsuleApi extends BaseAPI implements BixbyCapsuleApiInterface {
    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyCapsuleApi
     */
    public getApplicationBixbyProperties(applicationId: string, options?: any) {
        return BixbyCapsuleApiFp(this.configuration).getApplicationBixbyProperties(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BixbyCapsuleApi
     */
    public getBaseBixbyCapsuleTemplate(options?: any) {
        return BixbyCapsuleApiFp(this.configuration).getBaseBixbyCapsuleTemplate(options)(this.fetch, this.basePath);
    }

}

/**
 * BulkContentApi - fetch parameter creator
 * @export
 */
export const BulkContentApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {BulkContentRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCopyContentToApplicationFeature(applicationFeatureId: string, request?: BulkContentRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling bulkCopyContentToApplicationFeature.');
            }
            const localVarPath = `/api/BulkContent/CopyToFeature/{applicationFeatureId}`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkContentRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {BulkContentRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkMoveContentToApplicationFeature(applicationFeatureId: string, request?: BulkContentRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling bulkMoveContentToApplicationFeature.');
            }
            const localVarPath = `/api/BulkContent/MoveToFeature/{applicationFeatureId}`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkContentRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BulkContentRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContentInBulk(request?: BulkContentRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/BulkContent/Delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkContentRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BulkContentApi - functional programming interface
 * @export
 */
export const BulkContentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {BulkContentRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCopyContentToApplicationFeature(applicationFeatureId: string, request?: BulkContentRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = BulkContentApiFetchParamCreator(configuration).bulkCopyContentToApplicationFeature(applicationFeatureId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {BulkContentRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkMoveContentToApplicationFeature(applicationFeatureId: string, request?: BulkContentRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = BulkContentApiFetchParamCreator(configuration).bulkMoveContentToApplicationFeature(applicationFeatureId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {BulkContentRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContentInBulk(request?: BulkContentRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = BulkContentApiFetchParamCreator(configuration).deleteContentInBulk(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * BulkContentApi - factory interface
 * @export
 */
export const BulkContentApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {BulkContentRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkCopyContentToApplicationFeature(applicationFeatureId: string, request?: BulkContentRequest, options?: any) {
            return BulkContentApiFp(configuration).bulkCopyContentToApplicationFeature(applicationFeatureId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {BulkContentRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkMoveContentToApplicationFeature(applicationFeatureId: string, request?: BulkContentRequest, options?: any) {
            return BulkContentApiFp(configuration).bulkMoveContentToApplicationFeature(applicationFeatureId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {BulkContentRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContentInBulk(request?: BulkContentRequest, options?: any) {
            return BulkContentApiFp(configuration).deleteContentInBulk(request, options)(fetch, basePath);
        },
    };
};

/**
 * BulkContentApi - interface
 * @export
 * @interface BulkContentApi
 */
export interface BulkContentApiInterface {
    /**
     * 
     * @param {string} applicationFeatureId 
     * @param {BulkContentRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkContentApiInterface
     */
    bulkCopyContentToApplicationFeature(applicationFeatureId: string, request?: BulkContentRequest, options?: any): Promise<string>;

    /**
     * 
     * @param {string} applicationFeatureId 
     * @param {BulkContentRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkContentApiInterface
     */
    bulkMoveContentToApplicationFeature(applicationFeatureId: string, request?: BulkContentRequest, options?: any): Promise<string>;

    /**
     * 
     * @param {BulkContentRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkContentApiInterface
     */
    deleteContentInBulk(request?: BulkContentRequest, options?: any): Promise<string>;

}

/**
 * BulkContentApi - object-oriented interface
 * @export
 * @class BulkContentApi
 * @extends {BaseAPI}
 */
export class BulkContentApi extends BaseAPI implements BulkContentApiInterface {
    /**
     * 
     * @param {string} applicationFeatureId 
     * @param {BulkContentRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkContentApi
     */
    public bulkCopyContentToApplicationFeature(applicationFeatureId: string, request?: BulkContentRequest, options?: any) {
        return BulkContentApiFp(this.configuration).bulkCopyContentToApplicationFeature(applicationFeatureId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationFeatureId 
     * @param {BulkContentRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkContentApi
     */
    public bulkMoveContentToApplicationFeature(applicationFeatureId: string, request?: BulkContentRequest, options?: any) {
        return BulkContentApiFp(this.configuration).bulkMoveContentToApplicationFeature(applicationFeatureId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {BulkContentRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkContentApi
     */
    public deleteContentInBulk(request?: BulkContentRequest, options?: any) {
        return BulkContentApiFp(this.configuration).deleteContentInBulk(request, options)(this.fetch, this.basePath);
    }

}

/**
 * ContentLanguageApi - fetch parameter creator
 * @export
 */
export const ContentLanguageApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLanguages(options: any = {}): FetchArgs {
            const localVarPath = `/api/ContentLanguage/All`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentLanguageApi - functional programming interface
 * @export
 */
export const ContentLanguageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLanguages(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LanguageModel>> {
            const localVarFetchArgs = ContentLanguageApiFetchParamCreator(configuration).getAllLanguages(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ContentLanguageApi - factory interface
 * @export
 */
export const ContentLanguageApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllLanguages(options?: any) {
            return ContentLanguageApiFp(configuration).getAllLanguages(options)(fetch, basePath);
        },
    };
};

/**
 * ContentLanguageApi - interface
 * @export
 * @interface ContentLanguageApi
 */
export interface ContentLanguageApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentLanguageApiInterface
     */
    getAllLanguages(options?: any): Promise<Array<LanguageModel>>;

}

/**
 * ContentLanguageApi - object-oriented interface
 * @export
 * @class ContentLanguageApi
 * @extends {BaseAPI}
 */
export class ContentLanguageApi extends BaseAPI implements ContentLanguageApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentLanguageApi
     */
    public getAllLanguages(options?: any) {
        return ContentLanguageApiFp(this.configuration).getAllLanguages(options)(this.fetch, this.basePath);
    }

}

/**
 * CustomRequestApi - fetch parameter creator
 * @export
 */
export const CustomRequestApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds an audio file to the given response
         * @param {string} customRequestResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFile(customRequestResponseId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'customRequestResponseId' is not null or undefined
            if (customRequestResponseId === null || customRequestResponseId === undefined) {
                throw new RequiredError('customRequestResponseId','Required parameter customRequestResponseId was null or undefined when calling addAudioFile.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addAudioFile.');
            }
            const localVarPath = `/api/CustomRequest/{customRequestResponseId}/addAudioFile/{mediaItemId}`
                .replace(`{${"customRequestResponseId"}}`, encodeURIComponent(String(customRequestResponseId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a large image to the given response
         * @param {string} customRequestResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(customRequestResponseId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'customRequestResponseId' is not null or undefined
            if (customRequestResponseId === null || customRequestResponseId === undefined) {
                throw new RequiredError('customRequestResponseId','Required parameter customRequestResponseId was null or undefined when calling addLargeImage.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addLargeImage.');
            }
            const localVarPath = `/api/CustomRequest/{customRequestResponseId}/addLargeImage/{mediaItemId}`
                .replace(`{${"customRequestResponseId"}}`, encodeURIComponent(String(customRequestResponseId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a small image item to the given response
         * @param {string} customRequestResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(customRequestResponseId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'customRequestResponseId' is not null or undefined
            if (customRequestResponseId === null || customRequestResponseId === undefined) {
                throw new RequiredError('customRequestResponseId','Required parameter customRequestResponseId was null or undefined when calling addSmallImage.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addSmallImage.');
            }
            const localVarPath = `/api/CustomRequest/{customRequestResponseId}/addSmallImage/{mediaItemId}`
                .replace(`{${"customRequestResponseId"}}`, encodeURIComponent(String(customRequestResponseId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a video file to the given response
         * @param {string} customRequestResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(customRequestResponseId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'customRequestResponseId' is not null or undefined
            if (customRequestResponseId === null || customRequestResponseId === undefined) {
                throw new RequiredError('customRequestResponseId','Required parameter customRequestResponseId was null or undefined when calling addVideoFile.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addVideoFile.');
            }
            const localVarPath = `/api/CustomRequest/{customRequestResponseId}/addVideoFile/{mediaItemId}`
                .replace(`{${"customRequestResponseId"}}`, encodeURIComponent(String(customRequestResponseId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} customRequestId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(customRequestId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'customRequestId' is not null or undefined
            if (customRequestId === null || customRequestId === undefined) {
                throw new RequiredError('customRequestId','Required parameter customRequestId was null or undefined when calling addWebhook.');
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId','Required parameter webhookId was null or undefined when calling addWebhook.');
            }
            const localVarPath = `/api/CustomRequest/{customRequestId}/webhooks/{webhookId}`
                .replace(`{${"customRequestId"}}`, encodeURIComponent(String(customRequestId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} customRequestId 
         * @param {BulkUpdateCustomRequestRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateCustomRequest(customRequestId: string, model?: BulkUpdateCustomRequestRequest, options: any = {}): FetchArgs {
            // verify required parameter 'customRequestId' is not null or undefined
            if (customRequestId === null || customRequestId === undefined) {
                throw new RequiredError('customRequestId','Required parameter customRequestId was null or undefined when calling bulkUpdateCustomRequest.');
            }
            const localVarPath = `/api/CustomRequest/{customRequestId}/bulkUpdate`
                .replace(`{${"customRequestId"}}`, encodeURIComponent(String(customRequestId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkUpdateCustomRequestRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} customRequestId 
         * @param {BulkUpdateCustomRequestStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateCustomRequestStub(customRequestId: string, model?: BulkUpdateCustomRequestStubRequest, options: any = {}): FetchArgs {
            // verify required parameter 'customRequestId' is not null or undefined
            if (customRequestId === null || customRequestId === undefined) {
                throw new RequiredError('customRequestId','Required parameter customRequestId was null or undefined when calling bulkUpdateCustomRequestStub.');
            }
            const localVarPath = `/api/CustomRequest/{customRequestId}/bulkUpdate/stub`
                .replace(`{${"customRequestId"}}`, encodeURIComponent(String(customRequestId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkUpdateCustomRequestStubRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} customRequestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(customRequestId: string, options: any = {}): FetchArgs {
            // verify required parameter 'customRequestId' is not null or undefined
            if (customRequestId === null || customRequestId === undefined) {
                throw new RequiredError('customRequestId','Required parameter customRequestId was null or undefined when calling copyContentItem.');
            }
            const localVarPath = `/api/CustomRequest/{customRequestId}/copy`
                .replace(`{${"customRequestId"}}`, encodeURIComponent(String(customRequestId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new custom request entity
         * @param {NewCustomRequestRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomRequest(model?: NewCustomRequestRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/CustomRequest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewCustomRequestRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new custom request entity
         * @param {NewCustomRequestStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomRequestStub(model?: NewCustomRequestStubRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/CustomRequest/stub`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewCustomRequestStubRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {CustomRequestModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: CustomRequestModel, options: any = {}): FetchArgs {
            const localVarPath = `/api/CustomRequest/full`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomRequestModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new response varation for the given message
         * @param {string} customRequestId 
         * @param {NewCustomRequestResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResponse(customRequestId: string, model?: NewCustomRequestResponseRequest, options: any = {}): FetchArgs {
            // verify required parameter 'customRequestId' is not null or undefined
            if (customRequestId === null || customRequestId === undefined) {
                throw new RequiredError('customRequestId','Required parameter customRequestId was null or undefined when calling createResponse.');
            }
            const localVarPath = `/api/CustomRequest/{customRequestId}/response`
                .replace(`{${"customRequestId"}}`, encodeURIComponent(String(customRequestId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewCustomRequestResponseRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the given custom request
         * @param {string} customRequestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomRequest(customRequestId: string, options: any = {}): FetchArgs {
            // verify required parameter 'customRequestId' is not null or undefined
            if (customRequestId === null || customRequestId === undefined) {
                throw new RequiredError('customRequestId','Required parameter customRequestId was null or undefined when calling deleteCustomRequest.');
            }
            const localVarPath = `/api/CustomRequest/{customRequestId}`
                .replace(`{${"customRequestId"}}`, encodeURIComponent(String(customRequestId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes the given response
         * @param {string} customRequestResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResponse(customRequestResponseId: string, options: any = {}): FetchArgs {
            // verify required parameter 'customRequestResponseId' is not null or undefined
            if (customRequestResponseId === null || customRequestResponseId === undefined) {
                throw new RequiredError('customRequestResponseId','Required parameter customRequestResponseId was null or undefined when calling deleteResponse.');
            }
            const localVarPath = `/api/CustomRequest/response/{customRequestResponseId}`
                .replace(`{${"customRequestResponseId"}}`, encodeURIComponent(String(customRequestResponseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling findFullById.');
            }
            const localVarPath = `/api/CustomRequest/full/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling getByApplicationFeature.');
            }
            const localVarPath = `/api/CustomRequest/byFeature/{applicationFeatureId}`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} customRequestResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaItemsForCustomRequest(customRequestResponseId: string, options: any = {}): FetchArgs {
            // verify required parameter 'customRequestResponseId' is not null or undefined
            if (customRequestResponseId === null || customRequestResponseId === undefined) {
                throw new RequiredError('customRequestResponseId','Required parameter customRequestResponseId was null or undefined when calling getMediaItemsForCustomRequest.');
            }
            const localVarPath = `/api/CustomRequest/response/{customRequestResponseId}/media`
                .replace(`{${"customRequestResponseId"}}`, encodeURIComponent(String(customRequestResponseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the custom requests content for the given application  regardless of module
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesForApplication(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getMessagesForApplication.');
            }
            const localVarPath = `/api/CustomRequest/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the custom requests for the given application module
         * @param {string} applicationModuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesForModule(applicationModuleId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationModuleId' is not null or undefined
            if (applicationModuleId === null || applicationModuleId === undefined) {
                throw new RequiredError('applicationModuleId','Required parameter applicationModuleId was null or undefined when calling getMessagesForModule.');
            }
            const localVarPath = `/api/CustomRequest/module/{applicationModuleId}`
                .replace(`{${"applicationModuleId"}}`, encodeURIComponent(String(applicationModuleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} customRequestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(customRequestId: string, options: any = {}): FetchArgs {
            // verify required parameter 'customRequestId' is not null or undefined
            if (customRequestId === null || customRequestId === undefined) {
                throw new RequiredError('customRequestId','Required parameter customRequestId was null or undefined when calling getWebhooks.');
            }
            const localVarPath = `/api/CustomRequest/{customRequestId}/webhooks`
                .replace(`{${"customRequestId"}}`, encodeURIComponent(String(customRequestId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'contentItemId' is not null or undefined
            if (contentItemId === null || contentItemId === undefined) {
                throw new RequiredError('contentItemId','Required parameter contentItemId was null or undefined when calling moveContentItemToApplicationFeature.');
            }
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling moveContentItemToApplicationFeature.');
            }
            const localVarPath = `/api/CustomRequest/{contentItemId}/MoveToFeature/{applicationFeatureId}`
                .replace(`{${"contentItemId"}}`, encodeURIComponent(String(contentItemId)))
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} customRequestWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(customRequestWebhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'customRequestWebhookId' is not null or undefined
            if (customRequestWebhookId === null || customRequestWebhookId === undefined) {
                throw new RequiredError('customRequestWebhookId','Required parameter customRequestWebhookId was null or undefined when calling removeWebhook.');
            }
            const localVarPath = `/api/CustomRequest/webhook/{customRequestWebhookId}`
                .replace(`{${"customRequestWebhookId"}}`, encodeURIComponent(String(customRequestWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggles the given message as live or not
         * @param {string} customRequestId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleLive(customRequestId: string, model?: ToggleLiveRequest, options: any = {}): FetchArgs {
            // verify required parameter 'customRequestId' is not null or undefined
            if (customRequestId === null || customRequestId === undefined) {
                throw new RequiredError('customRequestId','Required parameter customRequestId was null or undefined when calling toggleLive.');
            }
            const localVarPath = `/api/CustomRequest/{customRequestId}/isLive`
                .replace(`{${"customRequestId"}}`, encodeURIComponent(String(customRequestId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ToggleLiveRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} customRequestId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(customRequestId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'customRequestId' is not null or undefined
            if (customRequestId === null || customRequestId === undefined) {
                throw new RequiredError('customRequestId','Required parameter customRequestId was null or undefined when calling updateAttachedWebhook.');
            }
            // verify required parameter 'webhookInstanceId' is not null or undefined
            if (webhookInstanceId === null || webhookInstanceId === undefined) {
                throw new RequiredError('webhookInstanceId','Required parameter webhookInstanceId was null or undefined when calling updateAttachedWebhook.');
            }
            const localVarPath = `/api/CustomRequest/{customRequestId}/webhooks/{webhookInstanceId}`
                .replace(`{${"customRequestId"}}`, encodeURIComponent(String(customRequestId)))
                .replace(`{${"webhookInstanceId"}}`, encodeURIComponent(String(webhookInstanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {CustomRequestModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: CustomRequestModel, options: any = {}): FetchArgs {
            // verify required parameter 'contentItemId' is not null or undefined
            if (contentItemId === null || contentItemId === undefined) {
                throw new RequiredError('contentItemId','Required parameter contentItemId was null or undefined when calling updateFullContentItem.');
            }
            const localVarPath = `/api/CustomRequest/{contentItemId}/full`
                .replace(`{${"contentItemId"}}`, encodeURIComponent(String(contentItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CustomRequestModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the custom request with the given fields  If you send null or no value for fields, they won't be updated
         * @param {string} customRequestId 
         * @param {UpdateCustomRequestRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessage(customRequestId: string, model?: UpdateCustomRequestRequest, options: any = {}): FetchArgs {
            // verify required parameter 'customRequestId' is not null or undefined
            if (customRequestId === null || customRequestId === undefined) {
                throw new RequiredError('customRequestId','Required parameter customRequestId was null or undefined when calling updateMessage.');
            }
            const localVarPath = `/api/CustomRequest/{customRequestId}`
                .replace(`{${"customRequestId"}}`, encodeURIComponent(String(customRequestId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateCustomRequestRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the given response
         * @param {string} customRequestResponseId 
         * @param {UpdateCustomRequestResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResponse(customRequestResponseId: string, model?: UpdateCustomRequestResponseRequest, options: any = {}): FetchArgs {
            // verify required parameter 'customRequestResponseId' is not null or undefined
            if (customRequestResponseId === null || customRequestResponseId === undefined) {
                throw new RequiredError('customRequestResponseId','Required parameter customRequestResponseId was null or undefined when calling updateResponse.');
            }
            const localVarPath = `/api/CustomRequest/response/{customRequestResponseId}`
                .replace(`{${"customRequestResponseId"}}`, encodeURIComponent(String(customRequestResponseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateCustomRequestResponseRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomRequestApi - functional programming interface
 * @export
 */
export const CustomRequestApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds an audio file to the given response
         * @param {string} customRequestResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFile(customRequestResponseId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomRequestResponseModel> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).addAudioFile(customRequestResponseId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a large image to the given response
         * @param {string} customRequestResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(customRequestResponseId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomRequestResponseModel> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).addLargeImage(customRequestResponseId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a small image item to the given response
         * @param {string} customRequestResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(customRequestResponseId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomRequestResponseModel> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).addSmallImage(customRequestResponseId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a video file to the given response
         * @param {string} customRequestResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(customRequestResponseId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomRequestResponseModel> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).addVideoFile(customRequestResponseId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} customRequestId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(customRequestId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomRequestWebhookModel> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).addWebhook(customRequestId, webhookId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} customRequestId 
         * @param {BulkUpdateCustomRequestRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateCustomRequest(customRequestId: string, model?: BulkUpdateCustomRequestRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomRequestModel> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).bulkUpdateCustomRequest(customRequestId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} customRequestId 
         * @param {BulkUpdateCustomRequestStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateCustomRequestStub(customRequestId: string, model?: BulkUpdateCustomRequestStubRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomRequestModel> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).bulkUpdateCustomRequestStub(customRequestId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} customRequestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(customRequestId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomRequestModel> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).copyContentItem(customRequestId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new custom request entity
         * @param {NewCustomRequestRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomRequest(model?: NewCustomRequestRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomRequestModel> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).createCustomRequest(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new custom request entity
         * @param {NewCustomRequestStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomRequestStub(model?: NewCustomRequestStubRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomRequestModel> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).createCustomRequestStub(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {CustomRequestModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: CustomRequestModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomRequestModel> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).createFullContentItem(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new response varation for the given message
         * @param {string} customRequestId 
         * @param {NewCustomRequestResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResponse(customRequestId: string, model?: NewCustomRequestResponseRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomRequestResponseModel> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).createResponse(customRequestId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete the given custom request
         * @param {string} customRequestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomRequest(customRequestId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomRequestModel> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).deleteCustomRequest(customRequestId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes the given response
         * @param {string} customRequestResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResponse(customRequestResponseId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomRequestResponseModel> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).deleteResponse(customRequestResponseId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomRequestModel> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).findFullById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CustomRequestModel>> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).getByApplicationFeature(applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} customRequestResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaItemsForCustomRequest(customRequestResponseId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MediaItemModel>> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).getMediaItemsForCustomRequest(customRequestResponseId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the custom requests content for the given application  regardless of module
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesForApplication(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CustomRequestModel>> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).getMessagesForApplication(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the custom requests for the given application module
         * @param {string} applicationModuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesForModule(applicationModuleId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CustomRequestModel>> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).getMessagesForModule(applicationModuleId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} customRequestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(customRequestId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CustomRequestWebhookModel>> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).getWebhooks(customRequestId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomRequestModel> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} customRequestWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(customRequestWebhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomRequestWebhookModel> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).removeWebhook(customRequestWebhookId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Toggles the given message as live or not
         * @param {string} customRequestId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleLive(customRequestId: string, model?: ToggleLiveRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomRequestModel> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).toggleLive(customRequestId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} customRequestId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(customRequestId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomRequestWebhookModel> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).updateAttachedWebhook(customRequestId, webhookInstanceId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {CustomRequestModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: CustomRequestModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomRequestModel> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).updateFullContentItem(contentItemId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the custom request with the given fields  If you send null or no value for fields, they won't be updated
         * @param {string} customRequestId 
         * @param {UpdateCustomRequestRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessage(customRequestId: string, model?: UpdateCustomRequestRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomRequestModel> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).updateMessage(customRequestId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the given response
         * @param {string} customRequestResponseId 
         * @param {UpdateCustomRequestResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResponse(customRequestResponseId: string, model?: UpdateCustomRequestResponseRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CustomRequestResponseModel> {
            const localVarFetchArgs = CustomRequestApiFetchParamCreator(configuration).updateResponse(customRequestResponseId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CustomRequestApi - factory interface
 * @export
 */
export const CustomRequestApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Adds an audio file to the given response
         * @param {string} customRequestResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFile(customRequestResponseId: string, mediaItemId: string, options?: any) {
            return CustomRequestApiFp(configuration).addAudioFile(customRequestResponseId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a large image to the given response
         * @param {string} customRequestResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(customRequestResponseId: string, mediaItemId: string, options?: any) {
            return CustomRequestApiFp(configuration).addLargeImage(customRequestResponseId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a small image item to the given response
         * @param {string} customRequestResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(customRequestResponseId: string, mediaItemId: string, options?: any) {
            return CustomRequestApiFp(configuration).addSmallImage(customRequestResponseId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a video file to the given response
         * @param {string} customRequestResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(customRequestResponseId: string, mediaItemId: string, options?: any) {
            return CustomRequestApiFp(configuration).addVideoFile(customRequestResponseId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} customRequestId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(customRequestId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
            return CustomRequestApiFp(configuration).addWebhook(customRequestId, webhookId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} customRequestId 
         * @param {BulkUpdateCustomRequestRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateCustomRequest(customRequestId: string, model?: BulkUpdateCustomRequestRequest, options?: any) {
            return CustomRequestApiFp(configuration).bulkUpdateCustomRequest(customRequestId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} customRequestId 
         * @param {BulkUpdateCustomRequestStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateCustomRequestStub(customRequestId: string, model?: BulkUpdateCustomRequestStubRequest, options?: any) {
            return CustomRequestApiFp(configuration).bulkUpdateCustomRequestStub(customRequestId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} customRequestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(customRequestId: string, options?: any) {
            return CustomRequestApiFp(configuration).copyContentItem(customRequestId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new custom request entity
         * @param {NewCustomRequestRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomRequest(model?: NewCustomRequestRequest, options?: any) {
            return CustomRequestApiFp(configuration).createCustomRequest(model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new custom request entity
         * @param {NewCustomRequestStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomRequestStub(model?: NewCustomRequestStubRequest, options?: any) {
            return CustomRequestApiFp(configuration).createCustomRequestStub(model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {CustomRequestModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: CustomRequestModel, options?: any) {
            return CustomRequestApiFp(configuration).createFullContentItem(model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new response varation for the given message
         * @param {string} customRequestId 
         * @param {NewCustomRequestResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResponse(customRequestId: string, model?: NewCustomRequestResponseRequest, options?: any) {
            return CustomRequestApiFp(configuration).createResponse(customRequestId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the given custom request
         * @param {string} customRequestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomRequest(customRequestId: string, options?: any) {
            return CustomRequestApiFp(configuration).deleteCustomRequest(customRequestId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes the given response
         * @param {string} customRequestResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResponse(customRequestResponseId: string, options?: any) {
            return CustomRequestApiFp(configuration).deleteResponse(customRequestResponseId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options?: any) {
            return CustomRequestApiFp(configuration).findFullById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options?: any) {
            return CustomRequestApiFp(configuration).getByApplicationFeature(applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} customRequestResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaItemsForCustomRequest(customRequestResponseId: string, options?: any) {
            return CustomRequestApiFp(configuration).getMediaItemsForCustomRequest(customRequestResponseId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the custom requests content for the given application  regardless of module
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesForApplication(applicationId: string, options?: any) {
            return CustomRequestApiFp(configuration).getMessagesForApplication(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the custom requests for the given application module
         * @param {string} applicationModuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesForModule(applicationModuleId: string, options?: any) {
            return CustomRequestApiFp(configuration).getMessagesForModule(applicationModuleId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} customRequestId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(customRequestId: string, options?: any) {
            return CustomRequestApiFp(configuration).getWebhooks(customRequestId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any) {
            return CustomRequestApiFp(configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} customRequestWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(customRequestWebhookId: string, options?: any) {
            return CustomRequestApiFp(configuration).removeWebhook(customRequestWebhookId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Toggles the given message as live or not
         * @param {string} customRequestId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleLive(customRequestId: string, model?: ToggleLiveRequest, options?: any) {
            return CustomRequestApiFp(configuration).toggleLive(customRequestId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} customRequestId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(customRequestId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any) {
            return CustomRequestApiFp(configuration).updateAttachedWebhook(customRequestId, webhookInstanceId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {CustomRequestModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: CustomRequestModel, options?: any) {
            return CustomRequestApiFp(configuration).updateFullContentItem(contentItemId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the custom request with the given fields  If you send null or no value for fields, they won't be updated
         * @param {string} customRequestId 
         * @param {UpdateCustomRequestRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessage(customRequestId: string, model?: UpdateCustomRequestRequest, options?: any) {
            return CustomRequestApiFp(configuration).updateMessage(customRequestId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the given response
         * @param {string} customRequestResponseId 
         * @param {UpdateCustomRequestResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResponse(customRequestResponseId: string, model?: UpdateCustomRequestResponseRequest, options?: any) {
            return CustomRequestApiFp(configuration).updateResponse(customRequestResponseId, model, options)(fetch, basePath);
        },
    };
};

/**
 * CustomRequestApi - interface
 * @export
 * @interface CustomRequestApi
 */
export interface CustomRequestApiInterface {
    /**
     * 
     * @summary Adds an audio file to the given response
     * @param {string} customRequestResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    addAudioFile(customRequestResponseId: string, mediaItemId: string, options?: any): Promise<CustomRequestResponseModel>;

    /**
     * 
     * @summary Adds a large image to the given response
     * @param {string} customRequestResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    addLargeImage(customRequestResponseId: string, mediaItemId: string, options?: any): Promise<CustomRequestResponseModel>;

    /**
     * 
     * @summary Adds a small image item to the given response
     * @param {string} customRequestResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    addSmallImage(customRequestResponseId: string, mediaItemId: string, options?: any): Promise<CustomRequestResponseModel>;

    /**
     * 
     * @summary Adds a video file to the given response
     * @param {string} customRequestResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    addVideoFile(customRequestResponseId: string, mediaItemId: string, options?: any): Promise<CustomRequestResponseModel>;

    /**
     * 
     * @param {string} customRequestId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    addWebhook(customRequestId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): Promise<CustomRequestWebhookModel>;

    /**
     * 
     * @param {string} customRequestId 
     * @param {BulkUpdateCustomRequestRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    bulkUpdateCustomRequest(customRequestId: string, model?: BulkUpdateCustomRequestRequest, options?: any): Promise<CustomRequestModel>;

    /**
     * 
     * @param {string} customRequestId 
     * @param {BulkUpdateCustomRequestStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    bulkUpdateCustomRequestStub(customRequestId: string, model?: BulkUpdateCustomRequestStubRequest, options?: any): Promise<CustomRequestModel>;

    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param {string} customRequestId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    copyContentItem(customRequestId: string, options?: any): Promise<CustomRequestModel>;

    /**
     * 
     * @summary Creates a new custom request entity
     * @param {NewCustomRequestRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    createCustomRequest(model?: NewCustomRequestRequest, options?: any): Promise<CustomRequestModel>;

    /**
     * 
     * @summary Creates a new custom request entity
     * @param {NewCustomRequestStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    createCustomRequestStub(model?: NewCustomRequestStubRequest, options?: any): Promise<CustomRequestModel>;

    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param {CustomRequestModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    createFullContentItem(model?: CustomRequestModel, options?: any): Promise<CustomRequestModel>;

    /**
     * 
     * @summary Creates a new response varation for the given message
     * @param {string} customRequestId 
     * @param {NewCustomRequestResponseRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    createResponse(customRequestId: string, model?: NewCustomRequestResponseRequest, options?: any): Promise<CustomRequestResponseModel>;

    /**
     * 
     * @summary Delete the given custom request
     * @param {string} customRequestId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    deleteCustomRequest(customRequestId: string, options?: any): Promise<CustomRequestModel>;

    /**
     * 
     * @summary Deletes the given response
     * @param {string} customRequestResponseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    deleteResponse(customRequestResponseId: string, options?: any): Promise<CustomRequestResponseModel>;

    /**
     * 
     * @summary Finds the full content item by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    findFullById(id: string, options?: any): Promise<CustomRequestModel>;

    /**
     * 
     * @summary Gets the content for the given application feature
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    getByApplicationFeature(applicationFeatureId: string, options?: any): Promise<Array<CustomRequestModel>>;

    /**
     * 
     * @param {string} customRequestResponseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    getMediaItemsForCustomRequest(customRequestResponseId: string, options?: any): Promise<Array<MediaItemModel>>;

    /**
     * 
     * @summary Gets the custom requests content for the given application  regardless of module
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    getMessagesForApplication(applicationId: string, options?: any): Promise<Array<CustomRequestModel>>;

    /**
     * 
     * @summary Gets the custom requests for the given application module
     * @param {string} applicationModuleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    getMessagesForModule(applicationModuleId: string, options?: any): Promise<Array<CustomRequestModel>>;

    /**
     * 
     * @param {string} customRequestId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    getWebhooks(customRequestId: string, options?: any): Promise<Array<CustomRequestWebhookModel>>;

    /**
     * 
     * @param {string} contentItemId 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any): Promise<CustomRequestModel>;

    /**
     * 
     * @param {string} customRequestWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    removeWebhook(customRequestWebhookId: string, options?: any): Promise<CustomRequestWebhookModel>;

    /**
     * 
     * @summary Toggles the given message as live or not
     * @param {string} customRequestId 
     * @param {ToggleLiveRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    toggleLive(customRequestId: string, model?: ToggleLiveRequest, options?: any): Promise<CustomRequestModel>;

    /**
     * 
     * @param {string} customRequestId 
     * @param {string} webhookInstanceId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    updateAttachedWebhook(customRequestId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any): Promise<CustomRequestWebhookModel>;

    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param {string} contentItemId 
     * @param {CustomRequestModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    updateFullContentItem(contentItemId: string, model?: CustomRequestModel, options?: any): Promise<CustomRequestModel>;

    /**
     * 
     * @summary Updates the custom request with the given fields  If you send null or no value for fields, they won't be updated
     * @param {string} customRequestId 
     * @param {UpdateCustomRequestRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    updateMessage(customRequestId: string, model?: UpdateCustomRequestRequest, options?: any): Promise<CustomRequestModel>;

    /**
     * 
     * @summary Updates the given response
     * @param {string} customRequestResponseId 
     * @param {UpdateCustomRequestResponseRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApiInterface
     */
    updateResponse(customRequestResponseId: string, model?: UpdateCustomRequestResponseRequest, options?: any): Promise<CustomRequestResponseModel>;

}

/**
 * CustomRequestApi - object-oriented interface
 * @export
 * @class CustomRequestApi
 * @extends {BaseAPI}
 */
export class CustomRequestApi extends BaseAPI implements CustomRequestApiInterface {
    /**
     * 
     * @summary Adds an audio file to the given response
     * @param {string} customRequestResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public addAudioFile(customRequestResponseId: string, mediaItemId: string, options?: any) {
        return CustomRequestApiFp(this.configuration).addAudioFile(customRequestResponseId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a large image to the given response
     * @param {string} customRequestResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public addLargeImage(customRequestResponseId: string, mediaItemId: string, options?: any) {
        return CustomRequestApiFp(this.configuration).addLargeImage(customRequestResponseId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a small image item to the given response
     * @param {string} customRequestResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public addSmallImage(customRequestResponseId: string, mediaItemId: string, options?: any) {
        return CustomRequestApiFp(this.configuration).addSmallImage(customRequestResponseId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a video file to the given response
     * @param {string} customRequestResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public addVideoFile(customRequestResponseId: string, mediaItemId: string, options?: any) {
        return CustomRequestApiFp(this.configuration).addVideoFile(customRequestResponseId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} customRequestId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public addWebhook(customRequestId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
        return CustomRequestApiFp(this.configuration).addWebhook(customRequestId, webhookId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} customRequestId 
     * @param {BulkUpdateCustomRequestRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public bulkUpdateCustomRequest(customRequestId: string, model?: BulkUpdateCustomRequestRequest, options?: any) {
        return CustomRequestApiFp(this.configuration).bulkUpdateCustomRequest(customRequestId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} customRequestId 
     * @param {BulkUpdateCustomRequestStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public bulkUpdateCustomRequestStub(customRequestId: string, model?: BulkUpdateCustomRequestStubRequest, options?: any) {
        return CustomRequestApiFp(this.configuration).bulkUpdateCustomRequestStub(customRequestId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param {string} customRequestId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public copyContentItem(customRequestId: string, options?: any) {
        return CustomRequestApiFp(this.configuration).copyContentItem(customRequestId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new custom request entity
     * @param {NewCustomRequestRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public createCustomRequest(model?: NewCustomRequestRequest, options?: any) {
        return CustomRequestApiFp(this.configuration).createCustomRequest(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new custom request entity
     * @param {NewCustomRequestStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public createCustomRequestStub(model?: NewCustomRequestStubRequest, options?: any) {
        return CustomRequestApiFp(this.configuration).createCustomRequestStub(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param {CustomRequestModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public createFullContentItem(model?: CustomRequestModel, options?: any) {
        return CustomRequestApiFp(this.configuration).createFullContentItem(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new response varation for the given message
     * @param {string} customRequestId 
     * @param {NewCustomRequestResponseRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public createResponse(customRequestId: string, model?: NewCustomRequestResponseRequest, options?: any) {
        return CustomRequestApiFp(this.configuration).createResponse(customRequestId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete the given custom request
     * @param {string} customRequestId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public deleteCustomRequest(customRequestId: string, options?: any) {
        return CustomRequestApiFp(this.configuration).deleteCustomRequest(customRequestId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes the given response
     * @param {string} customRequestResponseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public deleteResponse(customRequestResponseId: string, options?: any) {
        return CustomRequestApiFp(this.configuration).deleteResponse(customRequestResponseId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Finds the full content item by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public findFullById(id: string, options?: any) {
        return CustomRequestApiFp(this.configuration).findFullById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the content for the given application feature
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public getByApplicationFeature(applicationFeatureId: string, options?: any) {
        return CustomRequestApiFp(this.configuration).getByApplicationFeature(applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} customRequestResponseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public getMediaItemsForCustomRequest(customRequestResponseId: string, options?: any) {
        return CustomRequestApiFp(this.configuration).getMediaItemsForCustomRequest(customRequestResponseId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the custom requests content for the given application  regardless of module
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public getMessagesForApplication(applicationId: string, options?: any) {
        return CustomRequestApiFp(this.configuration).getMessagesForApplication(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the custom requests for the given application module
     * @param {string} applicationModuleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public getMessagesForModule(applicationModuleId: string, options?: any) {
        return CustomRequestApiFp(this.configuration).getMessagesForModule(applicationModuleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} customRequestId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public getWebhooks(customRequestId: string, options?: any) {
        return CustomRequestApiFp(this.configuration).getWebhooks(customRequestId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} contentItemId 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any) {
        return CustomRequestApiFp(this.configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} customRequestWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public removeWebhook(customRequestWebhookId: string, options?: any) {
        return CustomRequestApiFp(this.configuration).removeWebhook(customRequestWebhookId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Toggles the given message as live or not
     * @param {string} customRequestId 
     * @param {ToggleLiveRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public toggleLive(customRequestId: string, model?: ToggleLiveRequest, options?: any) {
        return CustomRequestApiFp(this.configuration).toggleLive(customRequestId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} customRequestId 
     * @param {string} webhookInstanceId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public updateAttachedWebhook(customRequestId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any) {
        return CustomRequestApiFp(this.configuration).updateAttachedWebhook(customRequestId, webhookInstanceId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param {string} contentItemId 
     * @param {CustomRequestModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public updateFullContentItem(contentItemId: string, model?: CustomRequestModel, options?: any) {
        return CustomRequestApiFp(this.configuration).updateFullContentItem(contentItemId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the custom request with the given fields  If you send null or no value for fields, they won't be updated
     * @param {string} customRequestId 
     * @param {UpdateCustomRequestRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public updateMessage(customRequestId: string, model?: UpdateCustomRequestRequest, options?: any) {
        return CustomRequestApiFp(this.configuration).updateMessage(customRequestId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the given response
     * @param {string} customRequestResponseId 
     * @param {UpdateCustomRequestResponseRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomRequestApi
     */
    public updateResponse(customRequestResponseId: string, model?: UpdateCustomRequestResponseRequest, options?: any) {
        return CustomRequestApiFp(this.configuration).updateResponse(customRequestResponseId, model, options)(this.fetch, this.basePath);
    }

}

/**
 * DeviceTargetApi - fetch parameter creator
 * @export
 */
export const DeviceTargetApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns all the supported device types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTargets(options: any = {}): FetchArgs {
            const localVarPath = `/api/DeviceTarget`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} deviceTargetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTarget(deviceTargetId: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceTargetId' is not null or undefined
            if (deviceTargetId === null || deviceTargetId === undefined) {
                throw new RequiredError('deviceTargetId','Required parameter deviceTargetId was null or undefined when calling getTarget.');
            }
            const localVarPath = `/api/DeviceTarget/{deviceTargetId}`
                .replace(`{${"deviceTargetId"}}`, encodeURIComponent(String(deviceTargetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeviceTargetApi - functional programming interface
 * @export
 */
export const DeviceTargetApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns all the supported device types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTargets(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DeviceTargetModel>> {
            const localVarFetchArgs = DeviceTargetApiFetchParamCreator(configuration).getAllTargets(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} deviceTargetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTarget(deviceTargetId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeviceTargetModel> {
            const localVarFetchArgs = DeviceTargetApiFetchParamCreator(configuration).getTarget(deviceTargetId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DeviceTargetApi - factory interface
 * @export
 */
export const DeviceTargetApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Returns all the supported device types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTargets(options?: any) {
            return DeviceTargetApiFp(configuration).getAllTargets(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} deviceTargetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTarget(deviceTargetId: string, options?: any) {
            return DeviceTargetApiFp(configuration).getTarget(deviceTargetId, options)(fetch, basePath);
        },
    };
};

/**
 * DeviceTargetApi - interface
 * @export
 * @interface DeviceTargetApi
 */
export interface DeviceTargetApiInterface {
    /**
     * 
     * @summary Returns all the supported device types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTargetApiInterface
     */
    getAllTargets(options?: any): Promise<Array<DeviceTargetModel>>;

    /**
     * 
     * @param {string} deviceTargetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTargetApiInterface
     */
    getTarget(deviceTargetId: string, options?: any): Promise<DeviceTargetModel>;

}

/**
 * DeviceTargetApi - object-oriented interface
 * @export
 * @class DeviceTargetApi
 * @extends {BaseAPI}
 */
export class DeviceTargetApi extends BaseAPI implements DeviceTargetApiInterface {
    /**
     * 
     * @summary Returns all the supported device types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTargetApi
     */
    public getAllTargets(options?: any) {
        return DeviceTargetApiFp(this.configuration).getAllTargets(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} deviceTargetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeviceTargetApi
     */
    public getTarget(deviceTargetId: string, options?: any) {
        return DeviceTargetApiFp(this.configuration).getTarget(deviceTargetId, options)(this.fetch, this.basePath);
    }

}

/**
 * DialogflowAgentApi - fetch parameter creator
 * @export
 */
export const DialogflowAgentApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDialogflowAgentsAsync(tokenId: string, options: any = {}): FetchArgs {
            // verify required parameter 'tokenId' is not null or undefined
            if (tokenId === null || tokenId === undefined) {
                throw new RequiredError('tokenId','Required parameter tokenId was null or undefined when calling listDialogflowAgentsAsync.');
            }
            const localVarPath = `/api/DialogflowAgent/Agents/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DialogflowAgentApi - functional programming interface
 * @export
 */
export const DialogflowAgentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDialogflowAgentsAsync(tokenId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DialogflowAgentInformation>> {
            const localVarFetchArgs = DialogflowAgentApiFetchParamCreator(configuration).listDialogflowAgentsAsync(tokenId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DialogflowAgentApi - factory interface
 * @export
 */
export const DialogflowAgentApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDialogflowAgentsAsync(tokenId: string, options?: any) {
            return DialogflowAgentApiFp(configuration).listDialogflowAgentsAsync(tokenId, options)(fetch, basePath);
        },
    };
};

/**
 * DialogflowAgentApi - interface
 * @export
 * @interface DialogflowAgentApi
 */
export interface DialogflowAgentApiInterface {
    /**
     * 
     * @param {string} tokenId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DialogflowAgentApiInterface
     */
    listDialogflowAgentsAsync(tokenId: string, options?: any): Promise<Array<DialogflowAgentInformation>>;

}

/**
 * DialogflowAgentApi - object-oriented interface
 * @export
 * @class DialogflowAgentApi
 * @extends {BaseAPI}
 */
export class DialogflowAgentApi extends BaseAPI implements DialogflowAgentApiInterface {
    /**
     * 
     * @param {string} tokenId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DialogflowAgentApi
     */
    public listDialogflowAgentsAsync(tokenId: string, options?: any) {
        return DialogflowAgentApiFp(this.configuration).listDialogflowAgentsAsync(tokenId, options)(this.fetch, this.basePath);
    }

}

/**
 * EventsApi - fetch parameter creator
 * @export
 */
export const EventsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a webhook to an event content item
         * @param {string} eventId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(eventId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling addWebhook.');
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId','Required parameter webhookId was null or undefined when calling addWebhook.');
            }
            const localVarPath = `/api/Events/{eventId}/webhooks/{webhookId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bulk updates an event and it's categories and responses
         * @param {string} eventId 
         * @param {BulkUpdateEventRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdate(eventId: string, model?: BulkUpdateEventRequest, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling bulkUpdate.');
            }
            const localVarPath = `/api/Events/{eventId}/bulkUpdate`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkUpdateEventRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bulk updates an event and it's categories and responses
         * @param {string} eventId 
         * @param {BulkUpdateEventStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateStub(eventId: string, model?: BulkUpdateEventStubRequest, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling bulkUpdateStub.');
            }
            const localVarPath = `/api/Events/{eventId}/bulkUpdate/stub`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkUpdateEventStubRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(eventId: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling copyContentItem.');
            }
            const localVarPath = `/api/Events/{eventId}/copy`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new event item
         * @param {CreateEventRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(model?: CreateEventRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Events`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateEventRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new event item
         * @param {CreateEventStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventStub(model?: CreateEventStubRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Events/stub`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateEventStubRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {EventItemModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: EventItemModel, options: any = {}): FetchArgs {
            const localVarPath = `/api/Events/full`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EventItemModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling createUserDefinedParameter.');
            }
            const localVarPath = `/api/Events/webhook/{instanceWebhookId}/userParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDefinedWebhookParameterCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes the given event
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(eventId: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling deleteEvent.');
            }
            const localVarPath = `/api/Events/{eventId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling findFullById.');
            }
            const localVarPath = `/api/Events/full/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling getByApplicationFeature.');
            }
            const localVarPath = `/api/Events/byFeature/{applicationFeatureId}`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all the event content items for the given module
         * @param {string} applicationModuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsForModule(applicationModuleId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationModuleId' is not null or undefined
            if (applicationModuleId === null || applicationModuleId === undefined) {
                throw new RequiredError('applicationModuleId','Required parameter applicationModuleId was null or undefined when calling getEventsForModule.');
            }
            const localVarPath = `/api/Events/{applicationModuleId}`
                .replace(`{${"applicationModuleId"}}`, encodeURIComponent(String(applicationModuleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get webhooks attached to an event content item
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(eventId: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling getWebhooks.');
            }
            const localVarPath = `/api/Events/{eventId}/webhooks`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'contentItemId' is not null or undefined
            if (contentItemId === null || contentItemId === undefined) {
                throw new RequiredError('contentItemId','Required parameter contentItemId was null or undefined when calling moveContentItemToApplicationFeature.');
            }
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling moveContentItemToApplicationFeature.');
            }
            const localVarPath = `/api/Events/{contentItemId}/MoveToFeature/{applicationFeatureId}`
                .replace(`{${"contentItemId"}}`, encodeURIComponent(String(contentItemId)))
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling removeUserDefinedParameter.');
            }
            // verify required parameter 'parameterName' is not null or undefined
            if (parameterName === null || parameterName === undefined) {
                throw new RequiredError('parameterName','Required parameter parameterName was null or undefined when calling removeUserDefinedParameter.');
            }
            const localVarPath = `/api/Events/webhook/{instanceWebhookId}/userParameters/{parameterName}`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)))
                .replace(`{${"parameterName"}}`, encodeURIComponent(String(parameterName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove webhook from an event content item
         * @param {string} eventWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(eventWebhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'eventWebhookId' is not null or undefined
            if (eventWebhookId === null || eventWebhookId === undefined) {
                throw new RequiredError('eventWebhookId','Required parameter eventWebhookId was null or undefined when calling removeWebhook.');
            }
            const localVarPath = `/api/Events/webhook/{eventWebhookId}`
                .replace(`{${"eventWebhookId"}}`, encodeURIComponent(String(eventWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggles whether the given event item is live or not
         * @param {string} eventId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleIsLive(eventId: string, model?: ToggleLiveRequest, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling toggleIsLive.');
            }
            const localVarPath = `/api/Events/{eventId}/isLive`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ToggleLiveRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} eventId 
         * @param {string} instanceWebhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(eventId: string, instanceWebhookId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling updateAttachedWebhook.');
            }
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateAttachedWebhook.');
            }
            const localVarPath = `/api/Events/{eventId}/webhooks/{instanceWebhookId}`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)))
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {EventItemModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: EventItemModel, options: any = {}): FetchArgs {
            // verify required parameter 'contentItemId' is not null or undefined
            if (contentItemId === null || contentItemId === undefined) {
                throw new RequiredError('contentItemId','Required parameter contentItemId was null or undefined when calling updateFullContentItem.');
            }
            const localVarPath = `/api/Events/{contentItemId}/full`
                .replace(`{${"contentItemId"}}`, encodeURIComponent(String(contentItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EventItemModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateUserDefinedParameter.');
            }
            const localVarPath = `/api/Events/webhook/{instanceWebhookId}/userParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDefinedWebhookParameterUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateWebhookParameter.');
            }
            const localVarPath = `/api/Events/webhook/{instanceWebhookId}/webhookParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParameterUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a webhook to an event content item
         * @param {string} eventId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(eventId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventItemWebhookModel> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).addWebhook(eventId, webhookId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Bulk updates an event and it's categories and responses
         * @param {string} eventId 
         * @param {BulkUpdateEventRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdate(eventId: string, model?: BulkUpdateEventRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventItemModel> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).bulkUpdate(eventId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Bulk updates an event and it's categories and responses
         * @param {string} eventId 
         * @param {BulkUpdateEventStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateStub(eventId: string, model?: BulkUpdateEventStubRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventItemModel> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).bulkUpdateStub(eventId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(eventId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventItemModel> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).copyContentItem(eventId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new event item
         * @param {CreateEventRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(model?: CreateEventRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventItemModel> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).createEvent(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new event item
         * @param {CreateEventStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventStub(model?: CreateEventStubRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventItemModel> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).createEventStub(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {EventItemModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: EventItemModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventItemModel> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).createFullContentItem(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).createUserDefinedParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes the given event
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(eventId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventItemModel> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).deleteEvent(eventId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventItemModel> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).findFullById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EventItemModel>> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).getByApplicationFeature(applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all the event content items for the given module
         * @param {string} applicationModuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsForModule(applicationModuleId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EventItemModel>> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).getEventsForModule(applicationModuleId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get webhooks attached to an event content item
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(eventId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EventItemWebhookModel>> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).getWebhooks(eventId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventItemModel> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Remove webhook from an event content item
         * @param {string} eventWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(eventWebhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventItemWebhookModel> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).removeWebhook(eventWebhookId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Toggles whether the given event item is live or not
         * @param {string} eventId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleIsLive(eventId: string, model?: ToggleLiveRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventItemModel> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).toggleIsLive(eventId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} eventId 
         * @param {string} instanceWebhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(eventId: string, instanceWebhookId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventItemWebhookModel> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).updateAttachedWebhook(eventId, instanceWebhookId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {EventItemModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: EventItemModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventItemModel> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).updateFullContentItem(contentItemId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).updateUserDefinedParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).updateWebhookParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Add a webhook to an event content item
         * @param {string} eventId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(eventId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
            return EventsApiFp(configuration).addWebhook(eventId, webhookId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Bulk updates an event and it's categories and responses
         * @param {string} eventId 
         * @param {BulkUpdateEventRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdate(eventId: string, model?: BulkUpdateEventRequest, options?: any) {
            return EventsApiFp(configuration).bulkUpdate(eventId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Bulk updates an event and it's categories and responses
         * @param {string} eventId 
         * @param {BulkUpdateEventStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateStub(eventId: string, model?: BulkUpdateEventStubRequest, options?: any) {
            return EventsApiFp(configuration).bulkUpdateStub(eventId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(eventId: string, options?: any) {
            return EventsApiFp(configuration).copyContentItem(eventId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new event item
         * @param {CreateEventRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEvent(model?: CreateEventRequest, options?: any) {
            return EventsApiFp(configuration).createEvent(model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new event item
         * @param {CreateEventStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEventStub(model?: CreateEventStubRequest, options?: any) {
            return EventsApiFp(configuration).createEventStub(model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {EventItemModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: EventItemModel, options?: any) {
            return EventsApiFp(configuration).createFullContentItem(model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any) {
            return EventsApiFp(configuration).createUserDefinedParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes the given event
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEvent(eventId: string, options?: any) {
            return EventsApiFp(configuration).deleteEvent(eventId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options?: any) {
            return EventsApiFp(configuration).findFullById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options?: any) {
            return EventsApiFp(configuration).getByApplicationFeature(applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all the event content items for the given module
         * @param {string} applicationModuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventsForModule(applicationModuleId: string, options?: any) {
            return EventsApiFp(configuration).getEventsForModule(applicationModuleId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get webhooks attached to an event content item
         * @param {string} eventId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(eventId: string, options?: any) {
            return EventsApiFp(configuration).getWebhooks(eventId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any) {
            return EventsApiFp(configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any) {
            return EventsApiFp(configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Remove webhook from an event content item
         * @param {string} eventWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(eventWebhookId: string, options?: any) {
            return EventsApiFp(configuration).removeWebhook(eventWebhookId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Toggles whether the given event item is live or not
         * @param {string} eventId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleIsLive(eventId: string, model?: ToggleLiveRequest, options?: any) {
            return EventsApiFp(configuration).toggleIsLive(eventId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} eventId 
         * @param {string} instanceWebhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(eventId: string, instanceWebhookId: string, parameters?: WebhookParametersRequest, options?: any) {
            return EventsApiFp(configuration).updateAttachedWebhook(eventId, instanceWebhookId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {EventItemModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: EventItemModel, options?: any) {
            return EventsApiFp(configuration).updateFullContentItem(contentItemId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any) {
            return EventsApiFp(configuration).updateUserDefinedParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any) {
            return EventsApiFp(configuration).updateWebhookParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
    };
};

/**
 * EventsApi - interface
 * @export
 * @interface EventsApi
 */
export interface EventsApiInterface {
    /**
     * 
     * @summary Add a webhook to an event content item
     * @param {string} eventId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    addWebhook(eventId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): Promise<EventItemWebhookModel>;

    /**
     * 
     * @summary Bulk updates an event and it's categories and responses
     * @param {string} eventId 
     * @param {BulkUpdateEventRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    bulkUpdate(eventId: string, model?: BulkUpdateEventRequest, options?: any): Promise<EventItemModel>;

    /**
     * 
     * @summary Bulk updates an event and it's categories and responses
     * @param {string} eventId 
     * @param {BulkUpdateEventStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    bulkUpdateStub(eventId: string, model?: BulkUpdateEventStubRequest, options?: any): Promise<EventItemModel>;

    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    copyContentItem(eventId: string, options?: any): Promise<EventItemModel>;

    /**
     * 
     * @summary Creates a new event item
     * @param {CreateEventRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    createEvent(model?: CreateEventRequest, options?: any): Promise<EventItemModel>;

    /**
     * 
     * @summary Creates a new event item
     * @param {CreateEventStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    createEventStub(model?: CreateEventStubRequest, options?: any): Promise<EventItemModel>;

    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param {EventItemModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    createFullContentItem(model?: EventItemModel, options?: any): Promise<EventItemModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterCreateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @summary Deletes the given event
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    deleteEvent(eventId: string, options?: any): Promise<EventItemModel>;

    /**
     * 
     * @summary Finds the full content item by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    findFullById(id: string, options?: any): Promise<EventItemModel>;

    /**
     * 
     * @summary Gets the content for the given application feature
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    getByApplicationFeature(applicationFeatureId: string, options?: any): Promise<Array<EventItemModel>>;

    /**
     * 
     * @summary Get all the event content items for the given module
     * @param {string} applicationModuleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    getEventsForModule(applicationModuleId: string, options?: any): Promise<Array<EventItemModel>>;

    /**
     * 
     * @summary Get webhooks attached to an event content item
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    getWebhooks(eventId: string, options?: any): Promise<Array<EventItemWebhookModel>>;

    /**
     * 
     * @param {string} contentItemId 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any): Promise<EventItemModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {string} parameterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any): Promise<boolean>;

    /**
     * 
     * @summary Remove webhook from an event content item
     * @param {string} eventWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    removeWebhook(eventWebhookId: string, options?: any): Promise<EventItemWebhookModel>;

    /**
     * 
     * @summary Toggles whether the given event item is live or not
     * @param {string} eventId 
     * @param {ToggleLiveRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    toggleIsLive(eventId: string, model?: ToggleLiveRequest, options?: any): Promise<EventItemModel>;

    /**
     * 
     * @param {string} eventId 
     * @param {string} instanceWebhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    updateAttachedWebhook(eventId: string, instanceWebhookId: string, parameters?: WebhookParametersRequest, options?: any): Promise<EventItemWebhookModel>;

    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param {string} contentItemId 
     * @param {EventItemModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    updateFullContentItem(contentItemId: string, model?: EventItemModel, options?: any): Promise<EventItemModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {WebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any): Promise<boolean>;

}

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI implements EventsApiInterface {
    /**
     * 
     * @summary Add a webhook to an event content item
     * @param {string} eventId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public addWebhook(eventId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
        return EventsApiFp(this.configuration).addWebhook(eventId, webhookId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Bulk updates an event and it's categories and responses
     * @param {string} eventId 
     * @param {BulkUpdateEventRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public bulkUpdate(eventId: string, model?: BulkUpdateEventRequest, options?: any) {
        return EventsApiFp(this.configuration).bulkUpdate(eventId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Bulk updates an event and it's categories and responses
     * @param {string} eventId 
     * @param {BulkUpdateEventStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public bulkUpdateStub(eventId: string, model?: BulkUpdateEventStubRequest, options?: any) {
        return EventsApiFp(this.configuration).bulkUpdateStub(eventId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public copyContentItem(eventId: string, options?: any) {
        return EventsApiFp(this.configuration).copyContentItem(eventId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new event item
     * @param {CreateEventRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public createEvent(model?: CreateEventRequest, options?: any) {
        return EventsApiFp(this.configuration).createEvent(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new event item
     * @param {CreateEventStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public createEventStub(model?: CreateEventStubRequest, options?: any) {
        return EventsApiFp(this.configuration).createEventStub(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param {EventItemModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public createFullContentItem(model?: EventItemModel, options?: any) {
        return EventsApiFp(this.configuration).createFullContentItem(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterCreateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any) {
        return EventsApiFp(this.configuration).createUserDefinedParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes the given event
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public deleteEvent(eventId: string, options?: any) {
        return EventsApiFp(this.configuration).deleteEvent(eventId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Finds the full content item by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public findFullById(id: string, options?: any) {
        return EventsApiFp(this.configuration).findFullById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the content for the given application feature
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getByApplicationFeature(applicationFeatureId: string, options?: any) {
        return EventsApiFp(this.configuration).getByApplicationFeature(applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all the event content items for the given module
     * @param {string} applicationModuleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEventsForModule(applicationModuleId: string, options?: any) {
        return EventsApiFp(this.configuration).getEventsForModule(applicationModuleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get webhooks attached to an event content item
     * @param {string} eventId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getWebhooks(eventId: string, options?: any) {
        return EventsApiFp(this.configuration).getWebhooks(eventId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} contentItemId 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any) {
        return EventsApiFp(this.configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {string} parameterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any) {
        return EventsApiFp(this.configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Remove webhook from an event content item
     * @param {string} eventWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public removeWebhook(eventWebhookId: string, options?: any) {
        return EventsApiFp(this.configuration).removeWebhook(eventWebhookId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Toggles whether the given event item is live or not
     * @param {string} eventId 
     * @param {ToggleLiveRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public toggleIsLive(eventId: string, model?: ToggleLiveRequest, options?: any) {
        return EventsApiFp(this.configuration).toggleIsLive(eventId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} eventId 
     * @param {string} instanceWebhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateAttachedWebhook(eventId: string, instanceWebhookId: string, parameters?: WebhookParametersRequest, options?: any) {
        return EventsApiFp(this.configuration).updateAttachedWebhook(eventId, instanceWebhookId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param {string} contentItemId 
     * @param {EventItemModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateFullContentItem(contentItemId: string, model?: EventItemModel, options?: any) {
        return EventsApiFp(this.configuration).updateFullContentItem(contentItemId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any) {
        return EventsApiFp(this.configuration).updateUserDefinedParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {WebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any) {
        return EventsApiFp(this.configuration).updateWebhookParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

}

/**
 * ExitMessageApi - fetch parameter creator
 * @export
 */
export const ExitMessageApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds an audio file to the exit message
         * @param {string} exitMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFileImage(exitMessageId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'exitMessageId' is not null or undefined
            if (exitMessageId === null || exitMessageId === undefined) {
                throw new RequiredError('exitMessageId','Required parameter exitMessageId was null or undefined when calling addAudioFileImage.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addAudioFileImage.');
            }
            const localVarPath = `/api/ExitMessage/{exitMessageId}/addAudioFile/{mediaItemId}`
                .replace(`{${"exitMessageId"}}`, encodeURIComponent(String(exitMessageId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a new exit message to the given application
         * @param {string} applicationId 
         * @param {NewExitMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExitMessage(applicationId: string, model?: NewExitMessageRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling addExitMessage.');
            }
            const localVarPath = `/api/ExitMessage/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewExitMessageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a new exit message to the given application
         * @param {string} applicationId 
         * @param {NewExitMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExitMessageStub(applicationId: string, model?: NewExitMessageStubRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling addExitMessageStub.');
            }
            const localVarPath = `/api/ExitMessage/{applicationId}/stub`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewExitMessageStubRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a large image to the exit message
         * @param {string} exitMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(exitMessageId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'exitMessageId' is not null or undefined
            if (exitMessageId === null || exitMessageId === undefined) {
                throw new RequiredError('exitMessageId','Required parameter exitMessageId was null or undefined when calling addLargeImage.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addLargeImage.');
            }
            const localVarPath = `/api/ExitMessage/{exitMessageId}/addLargeImage/{mediaItemId}`
                .replace(`{${"exitMessageId"}}`, encodeURIComponent(String(exitMessageId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a small image to the exit message
         * @param {string} exitMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(exitMessageId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'exitMessageId' is not null or undefined
            if (exitMessageId === null || exitMessageId === undefined) {
                throw new RequiredError('exitMessageId','Required parameter exitMessageId was null or undefined when calling addSmallImage.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addSmallImage.');
            }
            const localVarPath = `/api/ExitMessage/{exitMessageId}/addSmallImage/{mediaItemId}`
                .replace(`{${"exitMessageId"}}`, encodeURIComponent(String(exitMessageId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a video file to the exit message
         * @param {string} exitMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(exitMessageId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'exitMessageId' is not null or undefined
            if (exitMessageId === null || exitMessageId === undefined) {
                throw new RequiredError('exitMessageId','Required parameter exitMessageId was null or undefined when calling addVideoFile.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addVideoFile.');
            }
            const localVarPath = `/api/ExitMessage/{exitMessageId}/addVideoFile/{mediaItemId}`
                .replace(`{${"exitMessageId"}}`, encodeURIComponent(String(exitMessageId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} exitMessageId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(exitMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'exitMessageId' is not null or undefined
            if (exitMessageId === null || exitMessageId === undefined) {
                throw new RequiredError('exitMessageId','Required parameter exitMessageId was null or undefined when calling addWebhook.');
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId','Required parameter webhookId was null or undefined when calling addWebhook.');
            }
            const localVarPath = `/api/ExitMessage/{exitMessageId}/webhooks/{webhookId}`
                .replace(`{${"exitMessageId"}}`, encodeURIComponent(String(exitMessageId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} exitMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(exitMessageId: string, options: any = {}): FetchArgs {
            // verify required parameter 'exitMessageId' is not null or undefined
            if (exitMessageId === null || exitMessageId === undefined) {
                throw new RequiredError('exitMessageId','Required parameter exitMessageId was null or undefined when calling copyContentItem.');
            }
            const localVarPath = `/api/ExitMessage/{exitMessageId}/copy`
                .replace(`{${"exitMessageId"}}`, encodeURIComponent(String(exitMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new custom request entity from a dto
         * @param {ExitMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullCustomRequest(model?: ExitMessageModel, options: any = {}): FetchArgs {
            const localVarPath = `/api/ExitMessage/full`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExitMessageModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling createUserDefinedParameter.');
            }
            const localVarPath = `/api/ExitMessage/webhook/{instanceWebhookId}/userParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDefinedWebhookParameterCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes the given message
         * @param {string} exitMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExitMessage(exitMessageId: string, options: any = {}): FetchArgs {
            // verify required parameter 'exitMessageId' is not null or undefined
            if (exitMessageId === null || exitMessageId === undefined) {
                throw new RequiredError('exitMessageId','Required parameter exitMessageId was null or undefined when calling deleteExitMessage.');
            }
            const localVarPath = `/api/ExitMessage/{exitMessageId}`
                .replace(`{${"exitMessageId"}}`, encodeURIComponent(String(exitMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling findFullById.');
            }
            const localVarPath = `/api/ExitMessage/full/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling getByApplicationFeature.');
            }
            const localVarPath = `/api/ExitMessage/byFeature/{applicationFeatureId}`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the exit messages for the given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExitMessagesForApplication(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getExitMessagesForApplication.');
            }
            const localVarPath = `/api/ExitMessage/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} exitMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(exitMessageId: string, options: any = {}): FetchArgs {
            // verify required parameter 'exitMessageId' is not null or undefined
            if (exitMessageId === null || exitMessageId === undefined) {
                throw new RequiredError('exitMessageId','Required parameter exitMessageId was null or undefined when calling getWebhooks.');
            }
            const localVarPath = `/api/ExitMessage/{exitMessageId}/webhooks`
                .replace(`{${"exitMessageId"}}`, encodeURIComponent(String(exitMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'contentItemId' is not null or undefined
            if (contentItemId === null || contentItemId === undefined) {
                throw new RequiredError('contentItemId','Required parameter contentItemId was null or undefined when calling moveContentItemToApplicationFeature.');
            }
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling moveContentItemToApplicationFeature.');
            }
            const localVarPath = `/api/ExitMessage/{contentItemId}/MoveToFeature/{applicationFeatureId}`
                .replace(`{${"contentItemId"}}`, encodeURIComponent(String(contentItemId)))
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling removeUserDefinedParameter.');
            }
            // verify required parameter 'parameterName' is not null or undefined
            if (parameterName === null || parameterName === undefined) {
                throw new RequiredError('parameterName','Required parameter parameterName was null or undefined when calling removeUserDefinedParameter.');
            }
            const localVarPath = `/api/ExitMessage/webhook/{instanceWebhookId}/userParameters/{parameterName}`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)))
                .replace(`{${"parameterName"}}`, encodeURIComponent(String(parameterName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} exitMessageWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(exitMessageWebhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'exitMessageWebhookId' is not null or undefined
            if (exitMessageWebhookId === null || exitMessageWebhookId === undefined) {
                throw new RequiredError('exitMessageWebhookId','Required parameter exitMessageWebhookId was null or undefined when calling removeWebhook.');
            }
            const localVarPath = `/api/ExitMessage/webhook/{exitMessageWebhookId}`
                .replace(`{${"exitMessageWebhookId"}}`, encodeURIComponent(String(exitMessageWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggles whether the given exit message is live or not
         * @param {string} exitMessageId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleIsLive(exitMessageId: string, model?: ToggleLiveRequest, options: any = {}): FetchArgs {
            // verify required parameter 'exitMessageId' is not null or undefined
            if (exitMessageId === null || exitMessageId === undefined) {
                throw new RequiredError('exitMessageId','Required parameter exitMessageId was null or undefined when calling toggleIsLive.');
            }
            const localVarPath = `/api/ExitMessage/{exitMessageId}/isLive`
                .replace(`{${"exitMessageId"}}`, encodeURIComponent(String(exitMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ToggleLiveRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} exitMessageId 
         * @param {string} instanceWebhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(exitMessageId: string, instanceWebhookId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'exitMessageId' is not null or undefined
            if (exitMessageId === null || exitMessageId === undefined) {
                throw new RequiredError('exitMessageId','Required parameter exitMessageId was null or undefined when calling updateAttachedWebhook.');
            }
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateAttachedWebhook.');
            }
            const localVarPath = `/api/ExitMessage/{exitMessageId}/webhooks/{instanceWebhookId}`
                .replace(`{${"exitMessageId"}}`, encodeURIComponent(String(exitMessageId)))
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the content of the given exit message id
         * @param {string} exitMessageId 
         * @param {UpdateExitMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExitMessage(exitMessageId: string, model?: UpdateExitMessageRequest, options: any = {}): FetchArgs {
            // verify required parameter 'exitMessageId' is not null or undefined
            if (exitMessageId === null || exitMessageId === undefined) {
                throw new RequiredError('exitMessageId','Required parameter exitMessageId was null or undefined when calling updateExitMessage.');
            }
            const localVarPath = `/api/ExitMessage/{exitMessageId}/update`
                .replace(`{${"exitMessageId"}}`, encodeURIComponent(String(exitMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateExitMessageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the content of the given exit message id
         * @param {string} exitMessageId 
         * @param {UpdateExitMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExitMessageStub(exitMessageId: string, model?: UpdateExitMessageStubRequest, options: any = {}): FetchArgs {
            // verify required parameter 'exitMessageId' is not null or undefined
            if (exitMessageId === null || exitMessageId === undefined) {
                throw new RequiredError('exitMessageId','Required parameter exitMessageId was null or undefined when calling updateExitMessageStub.');
            }
            const localVarPath = `/api/ExitMessage/{exitMessageId}/update/stub`
                .replace(`{${"exitMessageId"}}`, encodeURIComponent(String(exitMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateExitMessageStubRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {ExitMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: ExitMessageModel, options: any = {}): FetchArgs {
            // verify required parameter 'contentItemId' is not null or undefined
            if (contentItemId === null || contentItemId === undefined) {
                throw new RequiredError('contentItemId','Required parameter contentItemId was null or undefined when calling updateFullContentItem.');
            }
            const localVarPath = `/api/ExitMessage/{contentItemId}/full`
                .replace(`{${"contentItemId"}}`, encodeURIComponent(String(contentItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExitMessageModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateUserDefinedParameter.');
            }
            const localVarPath = `/api/ExitMessage/webhook/{instanceWebhookId}/userParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDefinedWebhookParameterUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateWebhookParameter.');
            }
            const localVarPath = `/api/ExitMessage/webhook/{instanceWebhookId}/webhookParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParameterUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExitMessageApi - functional programming interface
 * @export
 */
export const ExitMessageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds an audio file to the exit message
         * @param {string} exitMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFileImage(exitMessageId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExitMessageModel> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).addAudioFileImage(exitMessageId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a new exit message to the given application
         * @param {string} applicationId 
         * @param {NewExitMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExitMessage(applicationId: string, model?: NewExitMessageRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExitMessageModel> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).addExitMessage(applicationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a new exit message to the given application
         * @param {string} applicationId 
         * @param {NewExitMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExitMessageStub(applicationId: string, model?: NewExitMessageStubRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExitMessageModel> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).addExitMessageStub(applicationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a large image to the exit message
         * @param {string} exitMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(exitMessageId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExitMessageModel> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).addLargeImage(exitMessageId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a small image to the exit message
         * @param {string} exitMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(exitMessageId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExitMessageModel> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).addSmallImage(exitMessageId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a video file to the exit message
         * @param {string} exitMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(exitMessageId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExitMessageModel> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).addVideoFile(exitMessageId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} exitMessageId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(exitMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExitMessageWebhookModel> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).addWebhook(exitMessageId, webhookId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} exitMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(exitMessageId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExitMessageModel> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).copyContentItem(exitMessageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new custom request entity from a dto
         * @param {ExitMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullCustomRequest(model?: ExitMessageModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExitMessageModel> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).createFullCustomRequest(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).createUserDefinedParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes the given message
         * @param {string} exitMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExitMessage(exitMessageId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExitMessageModel> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).deleteExitMessage(exitMessageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExitMessageModel> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).findFullById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ExitMessageModel>> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).getByApplicationFeature(applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the exit messages for the given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExitMessagesForApplication(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ExitMessageModel>> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).getExitMessagesForApplication(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} exitMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(exitMessageId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ExitMessageWebhookModel>> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).getWebhooks(exitMessageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExitMessageModel> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} exitMessageWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(exitMessageWebhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExitMessageWebhookModel> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).removeWebhook(exitMessageWebhookId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Toggles whether the given exit message is live or not
         * @param {string} exitMessageId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleIsLive(exitMessageId: string, model?: ToggleLiveRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExitMessageModel> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).toggleIsLive(exitMessageId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} exitMessageId 
         * @param {string} instanceWebhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(exitMessageId: string, instanceWebhookId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExitMessageWebhookModel> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).updateAttachedWebhook(exitMessageId, instanceWebhookId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the content of the given exit message id
         * @param {string} exitMessageId 
         * @param {UpdateExitMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExitMessage(exitMessageId: string, model?: UpdateExitMessageRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExitMessageModel> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).updateExitMessage(exitMessageId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the content of the given exit message id
         * @param {string} exitMessageId 
         * @param {UpdateExitMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExitMessageStub(exitMessageId: string, model?: UpdateExitMessageStubRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExitMessageModel> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).updateExitMessageStub(exitMessageId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {ExitMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: ExitMessageModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExitMessageModel> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).updateFullContentItem(contentItemId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).updateUserDefinedParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = ExitMessageApiFetchParamCreator(configuration).updateWebhookParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ExitMessageApi - factory interface
 * @export
 */
export const ExitMessageApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Adds an audio file to the exit message
         * @param {string} exitMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFileImage(exitMessageId: string, mediaItemId: string, options?: any) {
            return ExitMessageApiFp(configuration).addAudioFileImage(exitMessageId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a new exit message to the given application
         * @param {string} applicationId 
         * @param {NewExitMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExitMessage(applicationId: string, model?: NewExitMessageRequest, options?: any) {
            return ExitMessageApiFp(configuration).addExitMessage(applicationId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a new exit message to the given application
         * @param {string} applicationId 
         * @param {NewExitMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addExitMessageStub(applicationId: string, model?: NewExitMessageStubRequest, options?: any) {
            return ExitMessageApiFp(configuration).addExitMessageStub(applicationId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a large image to the exit message
         * @param {string} exitMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(exitMessageId: string, mediaItemId: string, options?: any) {
            return ExitMessageApiFp(configuration).addLargeImage(exitMessageId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a small image to the exit message
         * @param {string} exitMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(exitMessageId: string, mediaItemId: string, options?: any) {
            return ExitMessageApiFp(configuration).addSmallImage(exitMessageId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a video file to the exit message
         * @param {string} exitMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(exitMessageId: string, mediaItemId: string, options?: any) {
            return ExitMessageApiFp(configuration).addVideoFile(exitMessageId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} exitMessageId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(exitMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
            return ExitMessageApiFp(configuration).addWebhook(exitMessageId, webhookId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} exitMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(exitMessageId: string, options?: any) {
            return ExitMessageApiFp(configuration).copyContentItem(exitMessageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new custom request entity from a dto
         * @param {ExitMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullCustomRequest(model?: ExitMessageModel, options?: any) {
            return ExitMessageApiFp(configuration).createFullCustomRequest(model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any) {
            return ExitMessageApiFp(configuration).createUserDefinedParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes the given message
         * @param {string} exitMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteExitMessage(exitMessageId: string, options?: any) {
            return ExitMessageApiFp(configuration).deleteExitMessage(exitMessageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options?: any) {
            return ExitMessageApiFp(configuration).findFullById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options?: any) {
            return ExitMessageApiFp(configuration).getByApplicationFeature(applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the exit messages for the given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExitMessagesForApplication(applicationId: string, options?: any) {
            return ExitMessageApiFp(configuration).getExitMessagesForApplication(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} exitMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(exitMessageId: string, options?: any) {
            return ExitMessageApiFp(configuration).getWebhooks(exitMessageId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any) {
            return ExitMessageApiFp(configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any) {
            return ExitMessageApiFp(configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} exitMessageWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(exitMessageWebhookId: string, options?: any) {
            return ExitMessageApiFp(configuration).removeWebhook(exitMessageWebhookId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Toggles whether the given exit message is live or not
         * @param {string} exitMessageId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleIsLive(exitMessageId: string, model?: ToggleLiveRequest, options?: any) {
            return ExitMessageApiFp(configuration).toggleIsLive(exitMessageId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} exitMessageId 
         * @param {string} instanceWebhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(exitMessageId: string, instanceWebhookId: string, parameters?: WebhookParametersRequest, options?: any) {
            return ExitMessageApiFp(configuration).updateAttachedWebhook(exitMessageId, instanceWebhookId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the content of the given exit message id
         * @param {string} exitMessageId 
         * @param {UpdateExitMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExitMessage(exitMessageId: string, model?: UpdateExitMessageRequest, options?: any) {
            return ExitMessageApiFp(configuration).updateExitMessage(exitMessageId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the content of the given exit message id
         * @param {string} exitMessageId 
         * @param {UpdateExitMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExitMessageStub(exitMessageId: string, model?: UpdateExitMessageStubRequest, options?: any) {
            return ExitMessageApiFp(configuration).updateExitMessageStub(exitMessageId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {ExitMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: ExitMessageModel, options?: any) {
            return ExitMessageApiFp(configuration).updateFullContentItem(contentItemId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any) {
            return ExitMessageApiFp(configuration).updateUserDefinedParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any) {
            return ExitMessageApiFp(configuration).updateWebhookParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
    };
};

/**
 * ExitMessageApi - interface
 * @export
 * @interface ExitMessageApi
 */
export interface ExitMessageApiInterface {
    /**
     * 
     * @summary Adds an audio file to the exit message
     * @param {string} exitMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    addAudioFileImage(exitMessageId: string, mediaItemId: string, options?: any): Promise<ExitMessageModel>;

    /**
     * 
     * @summary Adds a new exit message to the given application
     * @param {string} applicationId 
     * @param {NewExitMessageRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    addExitMessage(applicationId: string, model?: NewExitMessageRequest, options?: any): Promise<ExitMessageModel>;

    /**
     * 
     * @summary Adds a new exit message to the given application
     * @param {string} applicationId 
     * @param {NewExitMessageStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    addExitMessageStub(applicationId: string, model?: NewExitMessageStubRequest, options?: any): Promise<ExitMessageModel>;

    /**
     * 
     * @summary Adds a large image to the exit message
     * @param {string} exitMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    addLargeImage(exitMessageId: string, mediaItemId: string, options?: any): Promise<ExitMessageModel>;

    /**
     * 
     * @summary Adds a small image to the exit message
     * @param {string} exitMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    addSmallImage(exitMessageId: string, mediaItemId: string, options?: any): Promise<ExitMessageModel>;

    /**
     * 
     * @summary Adds a video file to the exit message
     * @param {string} exitMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    addVideoFile(exitMessageId: string, mediaItemId: string, options?: any): Promise<ExitMessageModel>;

    /**
     * 
     * @param {string} exitMessageId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    addWebhook(exitMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): Promise<ExitMessageWebhookModel>;

    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param {string} exitMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    copyContentItem(exitMessageId: string, options?: any): Promise<ExitMessageModel>;

    /**
     * 
     * @summary Creates a new custom request entity from a dto
     * @param {ExitMessageModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    createFullCustomRequest(model?: ExitMessageModel, options?: any): Promise<ExitMessageModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterCreateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @summary Deletes the given message
     * @param {string} exitMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    deleteExitMessage(exitMessageId: string, options?: any): Promise<ExitMessageModel>;

    /**
     * 
     * @summary Finds the full content item by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    findFullById(id: string, options?: any): Promise<ExitMessageModel>;

    /**
     * 
     * @summary Gets the content for the given application feature
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    getByApplicationFeature(applicationFeatureId: string, options?: any): Promise<Array<ExitMessageModel>>;

    /**
     * 
     * @summary Gets the exit messages for the given application
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    getExitMessagesForApplication(applicationId: string, options?: any): Promise<Array<ExitMessageModel>>;

    /**
     * 
     * @param {string} exitMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    getWebhooks(exitMessageId: string, options?: any): Promise<Array<ExitMessageWebhookModel>>;

    /**
     * 
     * @param {string} contentItemId 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any): Promise<ExitMessageModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {string} parameterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} exitMessageWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    removeWebhook(exitMessageWebhookId: string, options?: any): Promise<ExitMessageWebhookModel>;

    /**
     * 
     * @summary Toggles whether the given exit message is live or not
     * @param {string} exitMessageId 
     * @param {ToggleLiveRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    toggleIsLive(exitMessageId: string, model?: ToggleLiveRequest, options?: any): Promise<ExitMessageModel>;

    /**
     * 
     * @param {string} exitMessageId 
     * @param {string} instanceWebhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    updateAttachedWebhook(exitMessageId: string, instanceWebhookId: string, parameters?: WebhookParametersRequest, options?: any): Promise<ExitMessageWebhookModel>;

    /**
     * 
     * @summary Updates the content of the given exit message id
     * @param {string} exitMessageId 
     * @param {UpdateExitMessageRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    updateExitMessage(exitMessageId: string, model?: UpdateExitMessageRequest, options?: any): Promise<ExitMessageModel>;

    /**
     * 
     * @summary Updates the content of the given exit message id
     * @param {string} exitMessageId 
     * @param {UpdateExitMessageStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    updateExitMessageStub(exitMessageId: string, model?: UpdateExitMessageStubRequest, options?: any): Promise<ExitMessageModel>;

    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param {string} contentItemId 
     * @param {ExitMessageModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    updateFullContentItem(contentItemId: string, model?: ExitMessageModel, options?: any): Promise<ExitMessageModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {WebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApiInterface
     */
    updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any): Promise<boolean>;

}

/**
 * ExitMessageApi - object-oriented interface
 * @export
 * @class ExitMessageApi
 * @extends {BaseAPI}
 */
export class ExitMessageApi extends BaseAPI implements ExitMessageApiInterface {
    /**
     * 
     * @summary Adds an audio file to the exit message
     * @param {string} exitMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public addAudioFileImage(exitMessageId: string, mediaItemId: string, options?: any) {
        return ExitMessageApiFp(this.configuration).addAudioFileImage(exitMessageId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a new exit message to the given application
     * @param {string} applicationId 
     * @param {NewExitMessageRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public addExitMessage(applicationId: string, model?: NewExitMessageRequest, options?: any) {
        return ExitMessageApiFp(this.configuration).addExitMessage(applicationId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a new exit message to the given application
     * @param {string} applicationId 
     * @param {NewExitMessageStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public addExitMessageStub(applicationId: string, model?: NewExitMessageStubRequest, options?: any) {
        return ExitMessageApiFp(this.configuration).addExitMessageStub(applicationId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a large image to the exit message
     * @param {string} exitMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public addLargeImage(exitMessageId: string, mediaItemId: string, options?: any) {
        return ExitMessageApiFp(this.configuration).addLargeImage(exitMessageId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a small image to the exit message
     * @param {string} exitMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public addSmallImage(exitMessageId: string, mediaItemId: string, options?: any) {
        return ExitMessageApiFp(this.configuration).addSmallImage(exitMessageId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a video file to the exit message
     * @param {string} exitMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public addVideoFile(exitMessageId: string, mediaItemId: string, options?: any) {
        return ExitMessageApiFp(this.configuration).addVideoFile(exitMessageId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} exitMessageId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public addWebhook(exitMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
        return ExitMessageApiFp(this.configuration).addWebhook(exitMessageId, webhookId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param {string} exitMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public copyContentItem(exitMessageId: string, options?: any) {
        return ExitMessageApiFp(this.configuration).copyContentItem(exitMessageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new custom request entity from a dto
     * @param {ExitMessageModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public createFullCustomRequest(model?: ExitMessageModel, options?: any) {
        return ExitMessageApiFp(this.configuration).createFullCustomRequest(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterCreateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any) {
        return ExitMessageApiFp(this.configuration).createUserDefinedParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes the given message
     * @param {string} exitMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public deleteExitMessage(exitMessageId: string, options?: any) {
        return ExitMessageApiFp(this.configuration).deleteExitMessage(exitMessageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Finds the full content item by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public findFullById(id: string, options?: any) {
        return ExitMessageApiFp(this.configuration).findFullById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the content for the given application feature
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public getByApplicationFeature(applicationFeatureId: string, options?: any) {
        return ExitMessageApiFp(this.configuration).getByApplicationFeature(applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the exit messages for the given application
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public getExitMessagesForApplication(applicationId: string, options?: any) {
        return ExitMessageApiFp(this.configuration).getExitMessagesForApplication(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} exitMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public getWebhooks(exitMessageId: string, options?: any) {
        return ExitMessageApiFp(this.configuration).getWebhooks(exitMessageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} contentItemId 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any) {
        return ExitMessageApiFp(this.configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {string} parameterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any) {
        return ExitMessageApiFp(this.configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} exitMessageWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public removeWebhook(exitMessageWebhookId: string, options?: any) {
        return ExitMessageApiFp(this.configuration).removeWebhook(exitMessageWebhookId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Toggles whether the given exit message is live or not
     * @param {string} exitMessageId 
     * @param {ToggleLiveRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public toggleIsLive(exitMessageId: string, model?: ToggleLiveRequest, options?: any) {
        return ExitMessageApiFp(this.configuration).toggleIsLive(exitMessageId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} exitMessageId 
     * @param {string} instanceWebhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public updateAttachedWebhook(exitMessageId: string, instanceWebhookId: string, parameters?: WebhookParametersRequest, options?: any) {
        return ExitMessageApiFp(this.configuration).updateAttachedWebhook(exitMessageId, instanceWebhookId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the content of the given exit message id
     * @param {string} exitMessageId 
     * @param {UpdateExitMessageRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public updateExitMessage(exitMessageId: string, model?: UpdateExitMessageRequest, options?: any) {
        return ExitMessageApiFp(this.configuration).updateExitMessage(exitMessageId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the content of the given exit message id
     * @param {string} exitMessageId 
     * @param {UpdateExitMessageStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public updateExitMessageStub(exitMessageId: string, model?: UpdateExitMessageStubRequest, options?: any) {
        return ExitMessageApiFp(this.configuration).updateExitMessageStub(exitMessageId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param {string} contentItemId 
     * @param {ExitMessageModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public updateFullContentItem(contentItemId: string, model?: ExitMessageModel, options?: any) {
        return ExitMessageApiFp(this.configuration).updateFullContentItem(contentItemId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any) {
        return ExitMessageApiFp(this.configuration).updateUserDefinedParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {WebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExitMessageApi
     */
    public updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any) {
        return ExitMessageApiFp(this.configuration).updateWebhookParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

}

/**
 * FallbackMessageApi - fetch parameter creator
 * @export
 */
export const FallbackMessageApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds an audio file to the fallback message
         * @param {string} fallbackMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFileImage(fallbackMessageId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'fallbackMessageId' is not null or undefined
            if (fallbackMessageId === null || fallbackMessageId === undefined) {
                throw new RequiredError('fallbackMessageId','Required parameter fallbackMessageId was null or undefined when calling addAudioFileImage.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addAudioFileImage.');
            }
            const localVarPath = `/api/FallbackMessage/{fallbackMessageId}/addAudioFile/{mediaItemId}`
                .replace(`{${"fallbackMessageId"}}`, encodeURIComponent(String(fallbackMessageId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a new fallback message to the given application
         * @param {string} applicationId 
         * @param {NewFallbackMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFallbackMessage(applicationId: string, model?: NewFallbackMessageRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling addFallbackMessage.');
            }
            const localVarPath = `/api/FallbackMessage/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewFallbackMessageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a new fallback message to the given application
         * @param {string} applicationId 
         * @param {NewFallbackMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFallbackMessageStub(applicationId: string, model?: NewFallbackMessageStubRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling addFallbackMessageStub.');
            }
            const localVarPath = `/api/FallbackMessage/{applicationId}/stub`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewFallbackMessageStubRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a large image to the fallback message
         * @param {string} fallbackMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(fallbackMessageId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'fallbackMessageId' is not null or undefined
            if (fallbackMessageId === null || fallbackMessageId === undefined) {
                throw new RequiredError('fallbackMessageId','Required parameter fallbackMessageId was null or undefined when calling addLargeImage.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addLargeImage.');
            }
            const localVarPath = `/api/FallbackMessage/{fallbackMessageId}/addLargeImage/{mediaItemId}`
                .replace(`{${"fallbackMessageId"}}`, encodeURIComponent(String(fallbackMessageId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a small image to the fallback message
         * @param {string} fallbackMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(fallbackMessageId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'fallbackMessageId' is not null or undefined
            if (fallbackMessageId === null || fallbackMessageId === undefined) {
                throw new RequiredError('fallbackMessageId','Required parameter fallbackMessageId was null or undefined when calling addSmallImage.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addSmallImage.');
            }
            const localVarPath = `/api/FallbackMessage/{fallbackMessageId}/addSmallImage/{mediaItemId}`
                .replace(`{${"fallbackMessageId"}}`, encodeURIComponent(String(fallbackMessageId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a video file to the fallback message
         * @param {string} fallbackMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(fallbackMessageId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'fallbackMessageId' is not null or undefined
            if (fallbackMessageId === null || fallbackMessageId === undefined) {
                throw new RequiredError('fallbackMessageId','Required parameter fallbackMessageId was null or undefined when calling addVideoFile.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addVideoFile.');
            }
            const localVarPath = `/api/FallbackMessage/{fallbackMessageId}/addVideoFile/{mediaItemId}`
                .replace(`{${"fallbackMessageId"}}`, encodeURIComponent(String(fallbackMessageId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} fallbackMessageId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(fallbackMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'fallbackMessageId' is not null or undefined
            if (fallbackMessageId === null || fallbackMessageId === undefined) {
                throw new RequiredError('fallbackMessageId','Required parameter fallbackMessageId was null or undefined when calling addWebhook.');
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId','Required parameter webhookId was null or undefined when calling addWebhook.');
            }
            const localVarPath = `/api/FallbackMessage/{fallbackMessageId}/webhooks/{webhookId}`
                .replace(`{${"fallbackMessageId"}}`, encodeURIComponent(String(fallbackMessageId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} fallbackMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(fallbackMessageId: string, options: any = {}): FetchArgs {
            // verify required parameter 'fallbackMessageId' is not null or undefined
            if (fallbackMessageId === null || fallbackMessageId === undefined) {
                throw new RequiredError('fallbackMessageId','Required parameter fallbackMessageId was null or undefined when calling copyContentItem.');
            }
            const localVarPath = `/api/FallbackMessage/{fallbackMessageId}/copy`
                .replace(`{${"fallbackMessageId"}}`, encodeURIComponent(String(fallbackMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {FallbackMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: FallbackMessageModel, options: any = {}): FetchArgs {
            const localVarPath = `/api/FallbackMessage/full`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FallbackMessageModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling createUserDefinedParameter.');
            }
            const localVarPath = `/api/FallbackMessage/webhook/{instanceWebhookId}/userParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDefinedWebhookParameterCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes the given message
         * @param {string} fallbackMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFallbackMessage(fallbackMessageId: string, options: any = {}): FetchArgs {
            // verify required parameter 'fallbackMessageId' is not null or undefined
            if (fallbackMessageId === null || fallbackMessageId === undefined) {
                throw new RequiredError('fallbackMessageId','Required parameter fallbackMessageId was null or undefined when calling deleteFallbackMessage.');
            }
            const localVarPath = `/api/FallbackMessage/{fallbackMessageId}`
                .replace(`{${"fallbackMessageId"}}`, encodeURIComponent(String(fallbackMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling findFullById.');
            }
            const localVarPath = `/api/FallbackMessage/full/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling getByApplicationFeature.');
            }
            const localVarPath = `/api/FallbackMessage/byFeature/{applicationFeatureId}`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(options: any = {}): FetchArgs {
            const localVarPath = `/api/FallbackMessage/categories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the fallback messages for the given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFallbackMessagesForApplication(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getFallbackMessagesForApplication.');
            }
            const localVarPath = `/api/FallbackMessage/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} fallbackMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(fallbackMessageId: string, options: any = {}): FetchArgs {
            // verify required parameter 'fallbackMessageId' is not null or undefined
            if (fallbackMessageId === null || fallbackMessageId === undefined) {
                throw new RequiredError('fallbackMessageId','Required parameter fallbackMessageId was null or undefined when calling getWebhooks.');
            }
            const localVarPath = `/api/FallbackMessage/{fallbackMessageId}/webhooks`
                .replace(`{${"fallbackMessageId"}}`, encodeURIComponent(String(fallbackMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'contentItemId' is not null or undefined
            if (contentItemId === null || contentItemId === undefined) {
                throw new RequiredError('contentItemId','Required parameter contentItemId was null or undefined when calling moveContentItemToApplicationFeature.');
            }
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling moveContentItemToApplicationFeature.');
            }
            const localVarPath = `/api/FallbackMessage/{contentItemId}/MoveToFeature/{applicationFeatureId}`
                .replace(`{${"contentItemId"}}`, encodeURIComponent(String(contentItemId)))
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling removeUserDefinedParameter.');
            }
            // verify required parameter 'parameterName' is not null or undefined
            if (parameterName === null || parameterName === undefined) {
                throw new RequiredError('parameterName','Required parameter parameterName was null or undefined when calling removeUserDefinedParameter.');
            }
            const localVarPath = `/api/FallbackMessage/webhook/{instanceWebhookId}/userParameters/{parameterName}`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)))
                .replace(`{${"parameterName"}}`, encodeURIComponent(String(parameterName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} fallbackMessageWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(fallbackMessageWebhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'fallbackMessageWebhookId' is not null or undefined
            if (fallbackMessageWebhookId === null || fallbackMessageWebhookId === undefined) {
                throw new RequiredError('fallbackMessageWebhookId','Required parameter fallbackMessageWebhookId was null or undefined when calling removeWebhook.');
            }
            const localVarPath = `/api/FallbackMessage/webhook/{fallbackMessageWebhookId}`
                .replace(`{${"fallbackMessageWebhookId"}}`, encodeURIComponent(String(fallbackMessageWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggles whether the given fallback Message is live or not
         * @param {string} fallbackMessageId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleIsLive(fallbackMessageId: string, model?: ToggleLiveRequest, options: any = {}): FetchArgs {
            // verify required parameter 'fallbackMessageId' is not null or undefined
            if (fallbackMessageId === null || fallbackMessageId === undefined) {
                throw new RequiredError('fallbackMessageId','Required parameter fallbackMessageId was null or undefined when calling toggleIsLive.');
            }
            const localVarPath = `/api/FallbackMessage/{fallbackMessageId}/isLive`
                .replace(`{${"fallbackMessageId"}}`, encodeURIComponent(String(fallbackMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ToggleLiveRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} fallbackMessageId 
         * @param {string} instanceWebhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(fallbackMessageId: string, instanceWebhookId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'fallbackMessageId' is not null or undefined
            if (fallbackMessageId === null || fallbackMessageId === undefined) {
                throw new RequiredError('fallbackMessageId','Required parameter fallbackMessageId was null or undefined when calling updateAttachedWebhook.');
            }
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateAttachedWebhook.');
            }
            const localVarPath = `/api/FallbackMessage/{fallbackMessageId}/webhooks/{instanceWebhookId}`
                .replace(`{${"fallbackMessageId"}}`, encodeURIComponent(String(fallbackMessageId)))
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the content of the given fallback message id
         * @param {string} fallbackMessageId 
         * @param {UpdateFallbackMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFallbackMessage(fallbackMessageId: string, model?: UpdateFallbackMessageRequest, options: any = {}): FetchArgs {
            // verify required parameter 'fallbackMessageId' is not null or undefined
            if (fallbackMessageId === null || fallbackMessageId === undefined) {
                throw new RequiredError('fallbackMessageId','Required parameter fallbackMessageId was null or undefined when calling updateFallbackMessage.');
            }
            const localVarPath = `/api/FallbackMessage/{fallbackMessageId}/update`
                .replace(`{${"fallbackMessageId"}}`, encodeURIComponent(String(fallbackMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateFallbackMessageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the content of the given fallback message id
         * @param {string} fallbackMessageId 
         * @param {UpdateFallbackMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFallbackMessageStub(fallbackMessageId: string, model?: UpdateFallbackMessageStubRequest, options: any = {}): FetchArgs {
            // verify required parameter 'fallbackMessageId' is not null or undefined
            if (fallbackMessageId === null || fallbackMessageId === undefined) {
                throw new RequiredError('fallbackMessageId','Required parameter fallbackMessageId was null or undefined when calling updateFallbackMessageStub.');
            }
            const localVarPath = `/api/FallbackMessage/{fallbackMessageId}/update/stub`
                .replace(`{${"fallbackMessageId"}}`, encodeURIComponent(String(fallbackMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateFallbackMessageStubRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {FallbackMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: FallbackMessageModel, options: any = {}): FetchArgs {
            // verify required parameter 'contentItemId' is not null or undefined
            if (contentItemId === null || contentItemId === undefined) {
                throw new RequiredError('contentItemId','Required parameter contentItemId was null or undefined when calling updateFullContentItem.');
            }
            const localVarPath = `/api/FallbackMessage/{contentItemId}/full`
                .replace(`{${"contentItemId"}}`, encodeURIComponent(String(contentItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FallbackMessageModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateUserDefinedParameter.');
            }
            const localVarPath = `/api/FallbackMessage/webhook/{instanceWebhookId}/userParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDefinedWebhookParameterUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateWebhookParameter.');
            }
            const localVarPath = `/api/FallbackMessage/webhook/{instanceWebhookId}/webhookParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParameterUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FallbackMessageApi - functional programming interface
 * @export
 */
export const FallbackMessageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds an audio file to the fallback message
         * @param {string} fallbackMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFileImage(fallbackMessageId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FallbackMessageModel> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).addAudioFileImage(fallbackMessageId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a new fallback message to the given application
         * @param {string} applicationId 
         * @param {NewFallbackMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFallbackMessage(applicationId: string, model?: NewFallbackMessageRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FallbackMessageModel> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).addFallbackMessage(applicationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a new fallback message to the given application
         * @param {string} applicationId 
         * @param {NewFallbackMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFallbackMessageStub(applicationId: string, model?: NewFallbackMessageStubRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FallbackMessageModel> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).addFallbackMessageStub(applicationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a large image to the fallback message
         * @param {string} fallbackMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(fallbackMessageId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FallbackMessageModel> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).addLargeImage(fallbackMessageId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a small image to the fallback message
         * @param {string} fallbackMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(fallbackMessageId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FallbackMessageModel> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).addSmallImage(fallbackMessageId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a video file to the fallback message
         * @param {string} fallbackMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(fallbackMessageId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FallbackMessageModel> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).addVideoFile(fallbackMessageId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} fallbackMessageId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(fallbackMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FallbackMessageWebhookModel> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).addWebhook(fallbackMessageId, webhookId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} fallbackMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(fallbackMessageId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FallbackMessageModel> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).copyContentItem(fallbackMessageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {FallbackMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: FallbackMessageModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FallbackMessageModel> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).createFullContentItem(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).createUserDefinedParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes the given message
         * @param {string} fallbackMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFallbackMessage(fallbackMessageId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FallbackMessageModel> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).deleteFallbackMessage(fallbackMessageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FallbackMessageModel> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).findFullById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FallbackMessageModel>> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).getByApplicationFeature(applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FallbackMessageCategoryModel>> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).getCategories(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the fallback messages for the given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFallbackMessagesForApplication(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FallbackMessageModel>> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).getFallbackMessagesForApplication(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} fallbackMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(fallbackMessageId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FallbackMessageWebhookModel>> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).getWebhooks(fallbackMessageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FallbackMessageModel> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} fallbackMessageWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(fallbackMessageWebhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FallbackMessageWebhookModel> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).removeWebhook(fallbackMessageWebhookId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Toggles whether the given fallback Message is live or not
         * @param {string} fallbackMessageId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleIsLive(fallbackMessageId: string, model?: ToggleLiveRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FallbackMessageModel> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).toggleIsLive(fallbackMessageId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} fallbackMessageId 
         * @param {string} instanceWebhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(fallbackMessageId: string, instanceWebhookId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FallbackMessageWebhookModel> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).updateAttachedWebhook(fallbackMessageId, instanceWebhookId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the content of the given fallback message id
         * @param {string} fallbackMessageId 
         * @param {UpdateFallbackMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFallbackMessage(fallbackMessageId: string, model?: UpdateFallbackMessageRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FallbackMessageModel> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).updateFallbackMessage(fallbackMessageId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the content of the given fallback message id
         * @param {string} fallbackMessageId 
         * @param {UpdateFallbackMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFallbackMessageStub(fallbackMessageId: string, model?: UpdateFallbackMessageStubRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FallbackMessageModel> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).updateFallbackMessageStub(fallbackMessageId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {FallbackMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: FallbackMessageModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FallbackMessageModel> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).updateFullContentItem(contentItemId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).updateUserDefinedParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = FallbackMessageApiFetchParamCreator(configuration).updateWebhookParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FallbackMessageApi - factory interface
 * @export
 */
export const FallbackMessageApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Adds an audio file to the fallback message
         * @param {string} fallbackMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFileImage(fallbackMessageId: string, mediaItemId: string, options?: any) {
            return FallbackMessageApiFp(configuration).addAudioFileImage(fallbackMessageId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a new fallback message to the given application
         * @param {string} applicationId 
         * @param {NewFallbackMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFallbackMessage(applicationId: string, model?: NewFallbackMessageRequest, options?: any) {
            return FallbackMessageApiFp(configuration).addFallbackMessage(applicationId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a new fallback message to the given application
         * @param {string} applicationId 
         * @param {NewFallbackMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFallbackMessageStub(applicationId: string, model?: NewFallbackMessageStubRequest, options?: any) {
            return FallbackMessageApiFp(configuration).addFallbackMessageStub(applicationId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a large image to the fallback message
         * @param {string} fallbackMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(fallbackMessageId: string, mediaItemId: string, options?: any) {
            return FallbackMessageApiFp(configuration).addLargeImage(fallbackMessageId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a small image to the fallback message
         * @param {string} fallbackMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(fallbackMessageId: string, mediaItemId: string, options?: any) {
            return FallbackMessageApiFp(configuration).addSmallImage(fallbackMessageId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a video file to the fallback message
         * @param {string} fallbackMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(fallbackMessageId: string, mediaItemId: string, options?: any) {
            return FallbackMessageApiFp(configuration).addVideoFile(fallbackMessageId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} fallbackMessageId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(fallbackMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
            return FallbackMessageApiFp(configuration).addWebhook(fallbackMessageId, webhookId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} fallbackMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(fallbackMessageId: string, options?: any) {
            return FallbackMessageApiFp(configuration).copyContentItem(fallbackMessageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {FallbackMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: FallbackMessageModel, options?: any) {
            return FallbackMessageApiFp(configuration).createFullContentItem(model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any) {
            return FallbackMessageApiFp(configuration).createUserDefinedParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes the given message
         * @param {string} fallbackMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFallbackMessage(fallbackMessageId: string, options?: any) {
            return FallbackMessageApiFp(configuration).deleteFallbackMessage(fallbackMessageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options?: any) {
            return FallbackMessageApiFp(configuration).findFullById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options?: any) {
            return FallbackMessageApiFp(configuration).getByApplicationFeature(applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(options?: any) {
            return FallbackMessageApiFp(configuration).getCategories(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the fallback messages for the given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFallbackMessagesForApplication(applicationId: string, options?: any) {
            return FallbackMessageApiFp(configuration).getFallbackMessagesForApplication(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} fallbackMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(fallbackMessageId: string, options?: any) {
            return FallbackMessageApiFp(configuration).getWebhooks(fallbackMessageId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any) {
            return FallbackMessageApiFp(configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any) {
            return FallbackMessageApiFp(configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} fallbackMessageWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(fallbackMessageWebhookId: string, options?: any) {
            return FallbackMessageApiFp(configuration).removeWebhook(fallbackMessageWebhookId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Toggles whether the given fallback Message is live or not
         * @param {string} fallbackMessageId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleIsLive(fallbackMessageId: string, model?: ToggleLiveRequest, options?: any) {
            return FallbackMessageApiFp(configuration).toggleIsLive(fallbackMessageId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} fallbackMessageId 
         * @param {string} instanceWebhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(fallbackMessageId: string, instanceWebhookId: string, parameters?: WebhookParametersRequest, options?: any) {
            return FallbackMessageApiFp(configuration).updateAttachedWebhook(fallbackMessageId, instanceWebhookId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the content of the given fallback message id
         * @param {string} fallbackMessageId 
         * @param {UpdateFallbackMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFallbackMessage(fallbackMessageId: string, model?: UpdateFallbackMessageRequest, options?: any) {
            return FallbackMessageApiFp(configuration).updateFallbackMessage(fallbackMessageId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the content of the given fallback message id
         * @param {string} fallbackMessageId 
         * @param {UpdateFallbackMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFallbackMessageStub(fallbackMessageId: string, model?: UpdateFallbackMessageStubRequest, options?: any) {
            return FallbackMessageApiFp(configuration).updateFallbackMessageStub(fallbackMessageId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {FallbackMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: FallbackMessageModel, options?: any) {
            return FallbackMessageApiFp(configuration).updateFullContentItem(contentItemId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any) {
            return FallbackMessageApiFp(configuration).updateUserDefinedParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any) {
            return FallbackMessageApiFp(configuration).updateWebhookParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
    };
};

/**
 * FallbackMessageApi - interface
 * @export
 * @interface FallbackMessageApi
 */
export interface FallbackMessageApiInterface {
    /**
     * 
     * @summary Adds an audio file to the fallback message
     * @param {string} fallbackMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    addAudioFileImage(fallbackMessageId: string, mediaItemId: string, options?: any): Promise<FallbackMessageModel>;

    /**
     * 
     * @summary Adds a new fallback message to the given application
     * @param {string} applicationId 
     * @param {NewFallbackMessageRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    addFallbackMessage(applicationId: string, model?: NewFallbackMessageRequest, options?: any): Promise<FallbackMessageModel>;

    /**
     * 
     * @summary Adds a new fallback message to the given application
     * @param {string} applicationId 
     * @param {NewFallbackMessageStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    addFallbackMessageStub(applicationId: string, model?: NewFallbackMessageStubRequest, options?: any): Promise<FallbackMessageModel>;

    /**
     * 
     * @summary Adds a large image to the fallback message
     * @param {string} fallbackMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    addLargeImage(fallbackMessageId: string, mediaItemId: string, options?: any): Promise<FallbackMessageModel>;

    /**
     * 
     * @summary Adds a small image to the fallback message
     * @param {string} fallbackMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    addSmallImage(fallbackMessageId: string, mediaItemId: string, options?: any): Promise<FallbackMessageModel>;

    /**
     * 
     * @summary Adds a video file to the fallback message
     * @param {string} fallbackMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    addVideoFile(fallbackMessageId: string, mediaItemId: string, options?: any): Promise<FallbackMessageModel>;

    /**
     * 
     * @param {string} fallbackMessageId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    addWebhook(fallbackMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): Promise<FallbackMessageWebhookModel>;

    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param {string} fallbackMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    copyContentItem(fallbackMessageId: string, options?: any): Promise<FallbackMessageModel>;

    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param {FallbackMessageModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    createFullContentItem(model?: FallbackMessageModel, options?: any): Promise<FallbackMessageModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterCreateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @summary Deletes the given message
     * @param {string} fallbackMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    deleteFallbackMessage(fallbackMessageId: string, options?: any): Promise<FallbackMessageModel>;

    /**
     * 
     * @summary Finds the full content item by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    findFullById(id: string, options?: any): Promise<FallbackMessageModel>;

    /**
     * 
     * @summary Gets the content for the given application feature
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    getByApplicationFeature(applicationFeatureId: string, options?: any): Promise<Array<FallbackMessageModel>>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    getCategories(options?: any): Promise<Array<FallbackMessageCategoryModel>>;

    /**
     * 
     * @summary Gets the fallback messages for the given application
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    getFallbackMessagesForApplication(applicationId: string, options?: any): Promise<Array<FallbackMessageModel>>;

    /**
     * 
     * @param {string} fallbackMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    getWebhooks(fallbackMessageId: string, options?: any): Promise<Array<FallbackMessageWebhookModel>>;

    /**
     * 
     * @param {string} contentItemId 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any): Promise<FallbackMessageModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {string} parameterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} fallbackMessageWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    removeWebhook(fallbackMessageWebhookId: string, options?: any): Promise<FallbackMessageWebhookModel>;

    /**
     * 
     * @summary Toggles whether the given fallback Message is live or not
     * @param {string} fallbackMessageId 
     * @param {ToggleLiveRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    toggleIsLive(fallbackMessageId: string, model?: ToggleLiveRequest, options?: any): Promise<FallbackMessageModel>;

    /**
     * 
     * @param {string} fallbackMessageId 
     * @param {string} instanceWebhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    updateAttachedWebhook(fallbackMessageId: string, instanceWebhookId: string, parameters?: WebhookParametersRequest, options?: any): Promise<FallbackMessageWebhookModel>;

    /**
     * 
     * @summary Updates the content of the given fallback message id
     * @param {string} fallbackMessageId 
     * @param {UpdateFallbackMessageRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    updateFallbackMessage(fallbackMessageId: string, model?: UpdateFallbackMessageRequest, options?: any): Promise<FallbackMessageModel>;

    /**
     * 
     * @summary Updates the content of the given fallback message id
     * @param {string} fallbackMessageId 
     * @param {UpdateFallbackMessageStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    updateFallbackMessageStub(fallbackMessageId: string, model?: UpdateFallbackMessageStubRequest, options?: any): Promise<FallbackMessageModel>;

    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param {string} contentItemId 
     * @param {FallbackMessageModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    updateFullContentItem(contentItemId: string, model?: FallbackMessageModel, options?: any): Promise<FallbackMessageModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {WebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApiInterface
     */
    updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any): Promise<boolean>;

}

/**
 * FallbackMessageApi - object-oriented interface
 * @export
 * @class FallbackMessageApi
 * @extends {BaseAPI}
 */
export class FallbackMessageApi extends BaseAPI implements FallbackMessageApiInterface {
    /**
     * 
     * @summary Adds an audio file to the fallback message
     * @param {string} fallbackMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public addAudioFileImage(fallbackMessageId: string, mediaItemId: string, options?: any) {
        return FallbackMessageApiFp(this.configuration).addAudioFileImage(fallbackMessageId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a new fallback message to the given application
     * @param {string} applicationId 
     * @param {NewFallbackMessageRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public addFallbackMessage(applicationId: string, model?: NewFallbackMessageRequest, options?: any) {
        return FallbackMessageApiFp(this.configuration).addFallbackMessage(applicationId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a new fallback message to the given application
     * @param {string} applicationId 
     * @param {NewFallbackMessageStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public addFallbackMessageStub(applicationId: string, model?: NewFallbackMessageStubRequest, options?: any) {
        return FallbackMessageApiFp(this.configuration).addFallbackMessageStub(applicationId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a large image to the fallback message
     * @param {string} fallbackMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public addLargeImage(fallbackMessageId: string, mediaItemId: string, options?: any) {
        return FallbackMessageApiFp(this.configuration).addLargeImage(fallbackMessageId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a small image to the fallback message
     * @param {string} fallbackMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public addSmallImage(fallbackMessageId: string, mediaItemId: string, options?: any) {
        return FallbackMessageApiFp(this.configuration).addSmallImage(fallbackMessageId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a video file to the fallback message
     * @param {string} fallbackMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public addVideoFile(fallbackMessageId: string, mediaItemId: string, options?: any) {
        return FallbackMessageApiFp(this.configuration).addVideoFile(fallbackMessageId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} fallbackMessageId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public addWebhook(fallbackMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
        return FallbackMessageApiFp(this.configuration).addWebhook(fallbackMessageId, webhookId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param {string} fallbackMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public copyContentItem(fallbackMessageId: string, options?: any) {
        return FallbackMessageApiFp(this.configuration).copyContentItem(fallbackMessageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param {FallbackMessageModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public createFullContentItem(model?: FallbackMessageModel, options?: any) {
        return FallbackMessageApiFp(this.configuration).createFullContentItem(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterCreateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any) {
        return FallbackMessageApiFp(this.configuration).createUserDefinedParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes the given message
     * @param {string} fallbackMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public deleteFallbackMessage(fallbackMessageId: string, options?: any) {
        return FallbackMessageApiFp(this.configuration).deleteFallbackMessage(fallbackMessageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Finds the full content item by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public findFullById(id: string, options?: any) {
        return FallbackMessageApiFp(this.configuration).findFullById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the content for the given application feature
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public getByApplicationFeature(applicationFeatureId: string, options?: any) {
        return FallbackMessageApiFp(this.configuration).getByApplicationFeature(applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public getCategories(options?: any) {
        return FallbackMessageApiFp(this.configuration).getCategories(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the fallback messages for the given application
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public getFallbackMessagesForApplication(applicationId: string, options?: any) {
        return FallbackMessageApiFp(this.configuration).getFallbackMessagesForApplication(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} fallbackMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public getWebhooks(fallbackMessageId: string, options?: any) {
        return FallbackMessageApiFp(this.configuration).getWebhooks(fallbackMessageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} contentItemId 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any) {
        return FallbackMessageApiFp(this.configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {string} parameterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any) {
        return FallbackMessageApiFp(this.configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} fallbackMessageWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public removeWebhook(fallbackMessageWebhookId: string, options?: any) {
        return FallbackMessageApiFp(this.configuration).removeWebhook(fallbackMessageWebhookId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Toggles whether the given fallback Message is live or not
     * @param {string} fallbackMessageId 
     * @param {ToggleLiveRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public toggleIsLive(fallbackMessageId: string, model?: ToggleLiveRequest, options?: any) {
        return FallbackMessageApiFp(this.configuration).toggleIsLive(fallbackMessageId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} fallbackMessageId 
     * @param {string} instanceWebhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public updateAttachedWebhook(fallbackMessageId: string, instanceWebhookId: string, parameters?: WebhookParametersRequest, options?: any) {
        return FallbackMessageApiFp(this.configuration).updateAttachedWebhook(fallbackMessageId, instanceWebhookId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the content of the given fallback message id
     * @param {string} fallbackMessageId 
     * @param {UpdateFallbackMessageRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public updateFallbackMessage(fallbackMessageId: string, model?: UpdateFallbackMessageRequest, options?: any) {
        return FallbackMessageApiFp(this.configuration).updateFallbackMessage(fallbackMessageId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the content of the given fallback message id
     * @param {string} fallbackMessageId 
     * @param {UpdateFallbackMessageStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public updateFallbackMessageStub(fallbackMessageId: string, model?: UpdateFallbackMessageStubRequest, options?: any) {
        return FallbackMessageApiFp(this.configuration).updateFallbackMessageStub(fallbackMessageId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param {string} contentItemId 
     * @param {FallbackMessageModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public updateFullContentItem(contentItemId: string, model?: FallbackMessageModel, options?: any) {
        return FallbackMessageApiFp(this.configuration).updateFullContentItem(contentItemId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any) {
        return FallbackMessageApiFp(this.configuration).updateUserDefinedParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {WebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FallbackMessageApi
     */
    public updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any) {
        return FallbackMessageApiFp(this.configuration).updateWebhookParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

}

/**
 * FeatureApi - fetch parameter creator
 * @export
 */
export const FeatureApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a top level application feature
         * @param {string} applicationId 
         * @param {CreateApplicationFeatureRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeatureAsync(applicationId: string, request?: CreateApplicationFeatureRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling addFeatureAsync.');
            }
            const localVarPath = `/api/Feature/{applicationId}/AddFeature`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateApplicationFeatureRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(applicationFeatureId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling addWebhook.');
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId','Required parameter webhookId was null or undefined when calling addWebhook.');
            }
            const localVarPath = `/api/Feature/{applicationFeatureId}/webhooks/{webhookId}`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {string} applicationModuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeModule(applicationFeatureId: string, applicationModuleId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling changeModule.');
            }
            // verify required parameter 'applicationModuleId' is not null or undefined
            if (applicationModuleId === null || applicationModuleId === undefined) {
                throw new RequiredError('applicationModuleId','Required parameter applicationModuleId was null or undefined when calling changeModule.');
            }
            const localVarPath = `/api/Feature/{applicationFeatureId}/changeModule/{applicationModuleId}`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)))
                .replace(`{${"applicationModuleId"}}`, encodeURIComponent(String(applicationModuleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling createUserDefinedParameter.');
            }
            const localVarPath = `/api/Feature/webhook/{instanceWebhookId}/userParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDefinedWebhookParameterCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes the given feature
         * @param {string} applicationFeatureId The id of the application feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeature(applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling deleteFeature.');
            }
            const localVarPath = `/api/Feature/{applicationFeatureId}`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disables the given feature
         * @param {string} applicationFeatureId The id of the application feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableFeature(applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling disableFeature.');
            }
            const localVarPath = `/api/Feature/{applicationFeatureId}/disable`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Enables the given feature
         * @param {string} applicationFeatureId The id of the application feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableFeature(applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling enableFeature.');
            }
            const localVarPath = `/api/Feature/{applicationFeatureId}/enable`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppFeaturesWithCounts(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getAppFeaturesWithCounts.');
            }
            const localVarPath = `/api/Feature/{applicationId}/features/conversationCounts`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the list of available features for an application
         * @param {string} applicationId The Id of an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableApplicationFeatures(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getAvailableApplicationFeatures.');
            }
            const localVarPath = `/api/Feature/{applicationId}/Available`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the built in features supported by Voicify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuiltInFeatures(options: any = {}): FetchArgs {
            const localVarPath = `/api/Feature/BuiltIn`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentItemsForApplicationFeature(applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling getContentItemsForApplicationFeature.');
            }
            const localVarPath = `/api/Feature/{applicationFeatureId}/content`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all the available feature types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureTypes(options: any = {}): FetchArgs {
            const localVarPath = `/api/Feature/Types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the features for the given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeaturesForApplication(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getFeaturesForApplication.');
            }
            const localVarPath = `/api/Feature/{applicationId}/features`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling getWebhooks.');
            }
            const localVarPath = `/api/Feature/{applicationFeatureId}/webhooks`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling removeUserDefinedParameter.');
            }
            // verify required parameter 'parameterName' is not null or undefined
            if (parameterName === null || parameterName === undefined) {
                throw new RequiredError('parameterName','Required parameter parameterName was null or undefined when calling removeUserDefinedParameter.');
            }
            const localVarPath = `/api/Feature/webhook/{instanceWebhookId}/userParameters/{parameterName}`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)))
                .replace(`{${"parameterName"}}`, encodeURIComponent(String(parameterName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationFeatureWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(applicationFeatureWebhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureWebhookId' is not null or undefined
            if (applicationFeatureWebhookId === null || applicationFeatureWebhookId === undefined) {
                throw new RequiredError('applicationFeatureWebhookId','Required parameter applicationFeatureWebhookId was null or undefined when calling removeWebhook.');
            }
            const localVarPath = `/api/Feature/webhook/{applicationFeatureWebhookId}`
                .replace(`{${"applicationFeatureWebhookId"}}`, encodeURIComponent(String(applicationFeatureWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [parentApplicationFeatureId] 
         * @param {Array<string>} [applicationFeatureIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setApplicationFeatureOrder(applicationId: string, parentApplicationFeatureId?: string, applicationFeatureIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling setApplicationFeatureOrder.');
            }
            const localVarPath = `/api/Feature/{applicationId}/reorderFeatures`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (parentApplicationFeatureId !== undefined) {
                localVarQueryParameter['parentApplicationFeatureId'] = parentApplicationFeatureId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(applicationFeatureIds || {}) : (applicationFeatureIds || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {UpdateApplicationFeatureRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationFeature(applicationFeatureId: string, model?: UpdateApplicationFeatureRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling updateApplicationFeature.');
            }
            const localVarPath = `/api/Feature/{applicationFeatureId}/update`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateApplicationFeatureRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(applicationFeatureId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling updateAttachedWebhook.');
            }
            // verify required parameter 'webhookInstanceId' is not null or undefined
            if (webhookInstanceId === null || webhookInstanceId === undefined) {
                throw new RequiredError('webhookInstanceId','Required parameter webhookInstanceId was null or undefined when calling updateAttachedWebhook.');
            }
            const localVarPath = `/api/Feature/{applicationFeatureId}/webhooks/{webhookInstanceId}`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)))
                .replace(`{${"webhookInstanceId"}}`, encodeURIComponent(String(webhookInstanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {string} parentApplicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParentForApplicationFeature(applicationFeatureId: string, parentApplicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling updateParentForApplicationFeature.');
            }
            // verify required parameter 'parentApplicationFeatureId' is not null or undefined
            if (parentApplicationFeatureId === null || parentApplicationFeatureId === undefined) {
                throw new RequiredError('parentApplicationFeatureId','Required parameter parentApplicationFeatureId was null or undefined when calling updateParentForApplicationFeature.');
            }
            const localVarPath = `/api/Feature/{applicationFeatureId}/updateParent/{parentApplicationFeatureId}`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)))
                .replace(`{${"parentApplicationFeatureId"}}`, encodeURIComponent(String(parentApplicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateUserDefinedParameter.');
            }
            const localVarPath = `/api/Feature/webhook/{instanceWebhookId}/userParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDefinedWebhookParameterUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateWebhookParameter.');
            }
            const localVarPath = `/api/Feature/webhook/{instanceWebhookId}/webhookParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParameterUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeatureApi - functional programming interface
 * @export
 */
export const FeatureApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a top level application feature
         * @param {string} applicationId 
         * @param {CreateApplicationFeatureRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeatureAsync(applicationId: string, request?: CreateApplicationFeatureRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationFeatureModel> {
            const localVarFetchArgs = FeatureApiFetchParamCreator(configuration).addFeatureAsync(applicationId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(applicationFeatureId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationFeatureWebhookModel> {
            const localVarFetchArgs = FeatureApiFetchParamCreator(configuration).addWebhook(applicationFeatureId, webhookId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {string} applicationModuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeModule(applicationFeatureId: string, applicationModuleId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationFeatureModel> {
            const localVarFetchArgs = FeatureApiFetchParamCreator(configuration).changeModule(applicationFeatureId, applicationModuleId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = FeatureApiFetchParamCreator(configuration).createUserDefinedParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes the given feature
         * @param {string} applicationFeatureId The id of the application feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeature(applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationFeatureModel> {
            const localVarFetchArgs = FeatureApiFetchParamCreator(configuration).deleteFeature(applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Disables the given feature
         * @param {string} applicationFeatureId The id of the application feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableFeature(applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationFeatureModel> {
            const localVarFetchArgs = FeatureApiFetchParamCreator(configuration).disableFeature(applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Enables the given feature
         * @param {string} applicationFeatureId The id of the application feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableFeature(applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationFeatureModel> {
            const localVarFetchArgs = FeatureApiFetchParamCreator(configuration).enableFeature(applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppFeaturesWithCounts(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ConversationCountModel>> {
            const localVarFetchArgs = FeatureApiFetchParamCreator(configuration).getAppFeaturesWithCounts(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the list of available features for an application
         * @param {string} applicationId The Id of an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableApplicationFeatures(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FeatureModel>> {
            const localVarFetchArgs = FeatureApiFetchParamCreator(configuration).getAvailableApplicationFeatures(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the built in features supported by Voicify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuiltInFeatures(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FeatureModel>> {
            const localVarFetchArgs = FeatureApiFetchParamCreator(configuration).getBuiltInFeatures(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentItemsForApplicationFeature(applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GenericContentModel>> {
            const localVarFetchArgs = FeatureApiFetchParamCreator(configuration).getContentItemsForApplicationFeature(applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets all the available feature types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureTypes(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FeatureTypeModel>> {
            const localVarFetchArgs = FeatureApiFetchParamCreator(configuration).getFeatureTypes(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the features for the given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeaturesForApplication(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ApplicationFeatureModel>> {
            const localVarFetchArgs = FeatureApiFetchParamCreator(configuration).getFeaturesForApplication(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ApplicationFeatureWebhookModel>> {
            const localVarFetchArgs = FeatureApiFetchParamCreator(configuration).getWebhooks(applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = FeatureApiFetchParamCreator(configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationFeatureWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(applicationFeatureWebhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationFeatureWebhookModel> {
            const localVarFetchArgs = FeatureApiFetchParamCreator(configuration).removeWebhook(applicationFeatureWebhookId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [parentApplicationFeatureId] 
         * @param {Array<string>} [applicationFeatureIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setApplicationFeatureOrder(applicationId: string, parentApplicationFeatureId?: string, applicationFeatureIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ApplicationFeatureModel>> {
            const localVarFetchArgs = FeatureApiFetchParamCreator(configuration).setApplicationFeatureOrder(applicationId, parentApplicationFeatureId, applicationFeatureIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {UpdateApplicationFeatureRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationFeature(applicationFeatureId: string, model?: UpdateApplicationFeatureRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationFeatureModel> {
            const localVarFetchArgs = FeatureApiFetchParamCreator(configuration).updateApplicationFeature(applicationFeatureId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(applicationFeatureId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationFeatureWebhookModel> {
            const localVarFetchArgs = FeatureApiFetchParamCreator(configuration).updateAttachedWebhook(applicationFeatureId, webhookInstanceId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {string} parentApplicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParentForApplicationFeature(applicationFeatureId: string, parentApplicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApplicationFeatureModel> {
            const localVarFetchArgs = FeatureApiFetchParamCreator(configuration).updateParentForApplicationFeature(applicationFeatureId, parentApplicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = FeatureApiFetchParamCreator(configuration).updateUserDefinedParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = FeatureApiFetchParamCreator(configuration).updateWebhookParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FeatureApi - factory interface
 * @export
 */
export const FeatureApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Create a top level application feature
         * @param {string} applicationId 
         * @param {CreateApplicationFeatureRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeatureAsync(applicationId: string, request?: CreateApplicationFeatureRequest, options?: any) {
            return FeatureApiFp(configuration).addFeatureAsync(applicationId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(applicationFeatureId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
            return FeatureApiFp(configuration).addWebhook(applicationFeatureId, webhookId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {string} applicationModuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeModule(applicationFeatureId: string, applicationModuleId: string, options?: any) {
            return FeatureApiFp(configuration).changeModule(applicationFeatureId, applicationModuleId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any) {
            return FeatureApiFp(configuration).createUserDefinedParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes the given feature
         * @param {string} applicationFeatureId The id of the application feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeature(applicationFeatureId: string, options?: any) {
            return FeatureApiFp(configuration).deleteFeature(applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Disables the given feature
         * @param {string} applicationFeatureId The id of the application feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableFeature(applicationFeatureId: string, options?: any) {
            return FeatureApiFp(configuration).disableFeature(applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Enables the given feature
         * @param {string} applicationFeatureId The id of the application feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableFeature(applicationFeatureId: string, options?: any) {
            return FeatureApiFp(configuration).enableFeature(applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppFeaturesWithCounts(applicationId: string, options?: any) {
            return FeatureApiFp(configuration).getAppFeaturesWithCounts(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the list of available features for an application
         * @param {string} applicationId The Id of an application
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableApplicationFeatures(applicationId: string, options?: any) {
            return FeatureApiFp(configuration).getAvailableApplicationFeatures(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the built in features supported by Voicify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuiltInFeatures(options?: any) {
            return FeatureApiFp(configuration).getBuiltInFeatures(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentItemsForApplicationFeature(applicationFeatureId: string, options?: any) {
            return FeatureApiFp(configuration).getContentItemsForApplicationFeature(applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets all the available feature types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeatureTypes(options?: any) {
            return FeatureApiFp(configuration).getFeatureTypes(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the features for the given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeaturesForApplication(applicationId: string, options?: any) {
            return FeatureApiFp(configuration).getFeaturesForApplication(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(applicationFeatureId: string, options?: any) {
            return FeatureApiFp(configuration).getWebhooks(applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any) {
            return FeatureApiFp(configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationFeatureWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(applicationFeatureWebhookId: string, options?: any) {
            return FeatureApiFp(configuration).removeWebhook(applicationFeatureWebhookId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [parentApplicationFeatureId] 
         * @param {Array<string>} [applicationFeatureIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setApplicationFeatureOrder(applicationId: string, parentApplicationFeatureId?: string, applicationFeatureIds?: Array<string>, options?: any) {
            return FeatureApiFp(configuration).setApplicationFeatureOrder(applicationId, parentApplicationFeatureId, applicationFeatureIds, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {UpdateApplicationFeatureRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationFeature(applicationFeatureId: string, model?: UpdateApplicationFeatureRequest, options?: any) {
            return FeatureApiFp(configuration).updateApplicationFeature(applicationFeatureId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(applicationFeatureId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any) {
            return FeatureApiFp(configuration).updateAttachedWebhook(applicationFeatureId, webhookInstanceId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {string} parentApplicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateParentForApplicationFeature(applicationFeatureId: string, parentApplicationFeatureId: string, options?: any) {
            return FeatureApiFp(configuration).updateParentForApplicationFeature(applicationFeatureId, parentApplicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any) {
            return FeatureApiFp(configuration).updateUserDefinedParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any) {
            return FeatureApiFp(configuration).updateWebhookParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
    };
};

/**
 * FeatureApi - interface
 * @export
 * @interface FeatureApi
 */
export interface FeatureApiInterface {
    /**
     * 
     * @summary Create a top level application feature
     * @param {string} applicationId 
     * @param {CreateApplicationFeatureRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApiInterface
     */
    addFeatureAsync(applicationId: string, request?: CreateApplicationFeatureRequest, options?: any): Promise<ApplicationFeatureModel>;

    /**
     * 
     * @param {string} applicationFeatureId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApiInterface
     */
    addWebhook(applicationFeatureId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): Promise<ApplicationFeatureWebhookModel>;

    /**
     * 
     * @param {string} applicationFeatureId 
     * @param {string} applicationModuleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApiInterface
     */
    changeModule(applicationFeatureId: string, applicationModuleId: string, options?: any): Promise<ApplicationFeatureModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterCreateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApiInterface
     */
    createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @summary Deletes the given feature
     * @param {string} applicationFeatureId The id of the application feature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApiInterface
     */
    deleteFeature(applicationFeatureId: string, options?: any): Promise<ApplicationFeatureModel>;

    /**
     * 
     * @summary Disables the given feature
     * @param {string} applicationFeatureId The id of the application feature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApiInterface
     */
    disableFeature(applicationFeatureId: string, options?: any): Promise<ApplicationFeatureModel>;

    /**
     * 
     * @summary Enables the given feature
     * @param {string} applicationFeatureId The id of the application feature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApiInterface
     */
    enableFeature(applicationFeatureId: string, options?: any): Promise<ApplicationFeatureModel>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApiInterface
     */
    getAppFeaturesWithCounts(applicationId: string, options?: any): Promise<Array<ConversationCountModel>>;

    /**
     * 
     * @summary Get the list of available features for an application
     * @param {string} applicationId The Id of an application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApiInterface
     */
    getAvailableApplicationFeatures(applicationId: string, options?: any): Promise<Array<FeatureModel>>;

    /**
     * 
     * @summary Get the built in features supported by Voicify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApiInterface
     */
    getBuiltInFeatures(options?: any): Promise<Array<FeatureModel>>;

    /**
     * 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApiInterface
     */
    getContentItemsForApplicationFeature(applicationFeatureId: string, options?: any): Promise<Array<GenericContentModel>>;

    /**
     * 
     * @summary Gets all the available feature types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApiInterface
     */
    getFeatureTypes(options?: any): Promise<Array<FeatureTypeModel>>;

    /**
     * 
     * @summary Get the features for the given application
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApiInterface
     */
    getFeaturesForApplication(applicationId: string, options?: any): Promise<Array<ApplicationFeatureModel>>;

    /**
     * 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApiInterface
     */
    getWebhooks(applicationFeatureId: string, options?: any): Promise<Array<ApplicationFeatureWebhookModel>>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {string} parameterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApiInterface
     */
    removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} applicationFeatureWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApiInterface
     */
    removeWebhook(applicationFeatureWebhookId: string, options?: any): Promise<ApplicationFeatureWebhookModel>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} [parentApplicationFeatureId] 
     * @param {Array<string>} [applicationFeatureIds] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApiInterface
     */
    setApplicationFeatureOrder(applicationId: string, parentApplicationFeatureId?: string, applicationFeatureIds?: Array<string>, options?: any): Promise<Array<ApplicationFeatureModel>>;

    /**
     * 
     * @param {string} applicationFeatureId 
     * @param {UpdateApplicationFeatureRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApiInterface
     */
    updateApplicationFeature(applicationFeatureId: string, model?: UpdateApplicationFeatureRequest, options?: any): Promise<ApplicationFeatureModel>;

    /**
     * 
     * @param {string} applicationFeatureId 
     * @param {string} webhookInstanceId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApiInterface
     */
    updateAttachedWebhook(applicationFeatureId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any): Promise<ApplicationFeatureWebhookModel>;

    /**
     * 
     * @param {string} applicationFeatureId 
     * @param {string} parentApplicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApiInterface
     */
    updateParentForApplicationFeature(applicationFeatureId: string, parentApplicationFeatureId: string, options?: any): Promise<ApplicationFeatureModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApiInterface
     */
    updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {WebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApiInterface
     */
    updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any): Promise<boolean>;

}

/**
 * FeatureApi - object-oriented interface
 * @export
 * @class FeatureApi
 * @extends {BaseAPI}
 */
export class FeatureApi extends BaseAPI implements FeatureApiInterface {
    /**
     * 
     * @summary Create a top level application feature
     * @param {string} applicationId 
     * @param {CreateApplicationFeatureRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public addFeatureAsync(applicationId: string, request?: CreateApplicationFeatureRequest, options?: any) {
        return FeatureApiFp(this.configuration).addFeatureAsync(applicationId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationFeatureId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public addWebhook(applicationFeatureId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
        return FeatureApiFp(this.configuration).addWebhook(applicationFeatureId, webhookId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationFeatureId 
     * @param {string} applicationModuleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public changeModule(applicationFeatureId: string, applicationModuleId: string, options?: any) {
        return FeatureApiFp(this.configuration).changeModule(applicationFeatureId, applicationModuleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterCreateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any) {
        return FeatureApiFp(this.configuration).createUserDefinedParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes the given feature
     * @param {string} applicationFeatureId The id of the application feature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public deleteFeature(applicationFeatureId: string, options?: any) {
        return FeatureApiFp(this.configuration).deleteFeature(applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Disables the given feature
     * @param {string} applicationFeatureId The id of the application feature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public disableFeature(applicationFeatureId: string, options?: any) {
        return FeatureApiFp(this.configuration).disableFeature(applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Enables the given feature
     * @param {string} applicationFeatureId The id of the application feature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public enableFeature(applicationFeatureId: string, options?: any) {
        return FeatureApiFp(this.configuration).enableFeature(applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public getAppFeaturesWithCounts(applicationId: string, options?: any) {
        return FeatureApiFp(this.configuration).getAppFeaturesWithCounts(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the list of available features for an application
     * @param {string} applicationId The Id of an application
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public getAvailableApplicationFeatures(applicationId: string, options?: any) {
        return FeatureApiFp(this.configuration).getAvailableApplicationFeatures(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the built in features supported by Voicify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public getBuiltInFeatures(options?: any) {
        return FeatureApiFp(this.configuration).getBuiltInFeatures(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public getContentItemsForApplicationFeature(applicationFeatureId: string, options?: any) {
        return FeatureApiFp(this.configuration).getContentItemsForApplicationFeature(applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets all the available feature types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public getFeatureTypes(options?: any) {
        return FeatureApiFp(this.configuration).getFeatureTypes(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the features for the given application
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public getFeaturesForApplication(applicationId: string, options?: any) {
        return FeatureApiFp(this.configuration).getFeaturesForApplication(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public getWebhooks(applicationFeatureId: string, options?: any) {
        return FeatureApiFp(this.configuration).getWebhooks(applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {string} parameterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any) {
        return FeatureApiFp(this.configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationFeatureWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public removeWebhook(applicationFeatureWebhookId: string, options?: any) {
        return FeatureApiFp(this.configuration).removeWebhook(applicationFeatureWebhookId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} [parentApplicationFeatureId] 
     * @param {Array<string>} [applicationFeatureIds] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public setApplicationFeatureOrder(applicationId: string, parentApplicationFeatureId?: string, applicationFeatureIds?: Array<string>, options?: any) {
        return FeatureApiFp(this.configuration).setApplicationFeatureOrder(applicationId, parentApplicationFeatureId, applicationFeatureIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationFeatureId 
     * @param {UpdateApplicationFeatureRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public updateApplicationFeature(applicationFeatureId: string, model?: UpdateApplicationFeatureRequest, options?: any) {
        return FeatureApiFp(this.configuration).updateApplicationFeature(applicationFeatureId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationFeatureId 
     * @param {string} webhookInstanceId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public updateAttachedWebhook(applicationFeatureId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any) {
        return FeatureApiFp(this.configuration).updateAttachedWebhook(applicationFeatureId, webhookInstanceId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationFeatureId 
     * @param {string} parentApplicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public updateParentForApplicationFeature(applicationFeatureId: string, parentApplicationFeatureId: string, options?: any) {
        return FeatureApiFp(this.configuration).updateParentForApplicationFeature(applicationFeatureId, parentApplicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any) {
        return FeatureApiFp(this.configuration).updateUserDefinedParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {WebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureApi
     */
    public updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any) {
        return FeatureApiFp(this.configuration).updateWebhookParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

}

/**
 * FollowUpApi - fetch parameter creator
 * @export
 */
export const FollowUpApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {CreateFollowUpRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFollowUp(applicationId: string, model?: CreateFollowUpRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling createFollowUp.');
            }
            const localVarPath = `/api/FollowUp/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateFollowUpRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} followUpId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFollowUp(followUpId: string, options: any = {}): FetchArgs {
            // verify required parameter 'followUpId' is not null or undefined
            if (followUpId === null || followUpId === undefined) {
                throw new RequiredError('followUpId','Required parameter followUpId was null or undefined when calling deleteFollowUp.');
            }
            const localVarPath = `/api/FollowUp/{followUpId}`
                .replace(`{${"followUpId"}}`, encodeURIComponent(String(followUpId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} followUpId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findChildContentContainer(followUpId: string, options: any = {}): FetchArgs {
            // verify required parameter 'followUpId' is not null or undefined
            if (followUpId === null || followUpId === undefined) {
                throw new RequiredError('followUpId','Required parameter followUpId was null or undefined when calling findChildContentContainer.');
            }
            const localVarPath = `/api/FollowUp/find/{followUpId}/children`
                .replace(`{${"followUpId"}}`, encodeURIComponent(String(followUpId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} followUpId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFollowUp(followUpId: string, options: any = {}): FetchArgs {
            // verify required parameter 'followUpId' is not null or undefined
            if (followUpId === null || followUpId === undefined) {
                throw new RequiredError('followUpId','Required parameter followUpId was null or undefined when calling findFollowUp.');
            }
            const localVarPath = `/api/FollowUp/find/{followUpId}`
                .replace(`{${"followUpId"}}`, encodeURIComponent(String(followUpId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForApplication(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getForApplication.');
            }
            const localVarPath = `/api/FollowUp/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} featureTypeId 
         * @param {string} contentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentContentItems(featureTypeId: string, contentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'featureTypeId' is not null or undefined
            if (featureTypeId === null || featureTypeId === undefined) {
                throw new RequiredError('featureTypeId','Required parameter featureTypeId was null or undefined when calling getParentContentItems.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getParentContentItems.');
            }
            const localVarPath = `/api/FollowUp/parents/{featureTypeId}/{contentId}/content`
                .replace(`{${"featureTypeId"}}`, encodeURIComponent(String(featureTypeId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} featureTypeId 
         * @param {string} contentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentsOfContent(featureTypeId: string, contentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'featureTypeId' is not null or undefined
            if (featureTypeId === null || featureTypeId === undefined) {
                throw new RequiredError('featureTypeId','Required parameter featureTypeId was null or undefined when calling getParentsOfContent.');
            }
            // verify required parameter 'contentId' is not null or undefined
            if (contentId === null || contentId === undefined) {
                throw new RequiredError('contentId','Required parameter contentId was null or undefined when calling getParentsOfContent.');
            }
            const localVarPath = `/api/FollowUp/parents/{featureTypeId}/{contentId}`
                .replace(`{${"featureTypeId"}}`, encodeURIComponent(String(featureTypeId)))
                .replace(`{${"contentId"}}`, encodeURIComponent(String(contentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateFollowUpRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFollowUp(model?: UpdateFollowUpRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/FollowUp`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateFollowUpRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FollowUpApi - functional programming interface
 * @export
 */
export const FollowUpApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {CreateFollowUpRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFollowUp(applicationId: string, model?: CreateFollowUpRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FollowUpModel> {
            const localVarFetchArgs = FollowUpApiFetchParamCreator(configuration).createFollowUp(applicationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} followUpId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFollowUp(followUpId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FollowUpModel> {
            const localVarFetchArgs = FollowUpApiFetchParamCreator(configuration).deleteFollowUp(followUpId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} followUpId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findChildContentContainer(followUpId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ChildContentContainerModel> {
            const localVarFetchArgs = FollowUpApiFetchParamCreator(configuration).findChildContentContainer(followUpId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} followUpId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFollowUp(followUpId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FollowUpModel> {
            const localVarFetchArgs = FollowUpApiFetchParamCreator(configuration).findFollowUp(followUpId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForApplication(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FollowUpModel>> {
            const localVarFetchArgs = FollowUpApiFetchParamCreator(configuration).getForApplication(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} featureTypeId 
         * @param {string} contentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentContentItems(featureTypeId: string, contentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ParentContentContainerModel> {
            const localVarFetchArgs = FollowUpApiFetchParamCreator(configuration).getParentContentItems(featureTypeId, contentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} featureTypeId 
         * @param {string} contentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentsOfContent(featureTypeId: string, contentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<FollowUpModel>> {
            const localVarFetchArgs = FollowUpApiFetchParamCreator(configuration).getParentsOfContent(featureTypeId, contentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UpdateFollowUpRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFollowUp(model?: UpdateFollowUpRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FollowUpModel> {
            const localVarFetchArgs = FollowUpApiFetchParamCreator(configuration).updateFollowUp(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FollowUpApi - factory interface
 * @export
 */
export const FollowUpApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {CreateFollowUpRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFollowUp(applicationId: string, model?: CreateFollowUpRequest, options?: any) {
            return FollowUpApiFp(configuration).createFollowUp(applicationId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} followUpId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFollowUp(followUpId: string, options?: any) {
            return FollowUpApiFp(configuration).deleteFollowUp(followUpId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} followUpId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findChildContentContainer(followUpId: string, options?: any) {
            return FollowUpApiFp(configuration).findChildContentContainer(followUpId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} followUpId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFollowUp(followUpId: string, options?: any) {
            return FollowUpApiFp(configuration).findFollowUp(followUpId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForApplication(applicationId: string, options?: any) {
            return FollowUpApiFp(configuration).getForApplication(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} featureTypeId 
         * @param {string} contentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentContentItems(featureTypeId: string, contentId: string, options?: any) {
            return FollowUpApiFp(configuration).getParentContentItems(featureTypeId, contentId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} featureTypeId 
         * @param {string} contentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParentsOfContent(featureTypeId: string, contentId: string, options?: any) {
            return FollowUpApiFp(configuration).getParentsOfContent(featureTypeId, contentId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {UpdateFollowUpRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFollowUp(model?: UpdateFollowUpRequest, options?: any) {
            return FollowUpApiFp(configuration).updateFollowUp(model, options)(fetch, basePath);
        },
    };
};

/**
 * FollowUpApi - interface
 * @export
 * @interface FollowUpApi
 */
export interface FollowUpApiInterface {
    /**
     * 
     * @param {string} applicationId 
     * @param {CreateFollowUpRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowUpApiInterface
     */
    createFollowUp(applicationId: string, model?: CreateFollowUpRequest, options?: any): Promise<FollowUpModel>;

    /**
     * 
     * @param {string} followUpId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowUpApiInterface
     */
    deleteFollowUp(followUpId: string, options?: any): Promise<FollowUpModel>;

    /**
     * 
     * @param {string} followUpId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowUpApiInterface
     */
    findChildContentContainer(followUpId: string, options?: any): Promise<ChildContentContainerModel>;

    /**
     * 
     * @param {string} followUpId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowUpApiInterface
     */
    findFollowUp(followUpId: string, options?: any): Promise<FollowUpModel>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowUpApiInterface
     */
    getForApplication(applicationId: string, options?: any): Promise<Array<FollowUpModel>>;

    /**
     * 
     * @param {string} featureTypeId 
     * @param {string} contentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowUpApiInterface
     */
    getParentContentItems(featureTypeId: string, contentId: string, options?: any): Promise<ParentContentContainerModel>;

    /**
     * 
     * @param {string} featureTypeId 
     * @param {string} contentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowUpApiInterface
     */
    getParentsOfContent(featureTypeId: string, contentId: string, options?: any): Promise<Array<FollowUpModel>>;

    /**
     * 
     * @param {UpdateFollowUpRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowUpApiInterface
     */
    updateFollowUp(model?: UpdateFollowUpRequest, options?: any): Promise<FollowUpModel>;

}

/**
 * FollowUpApi - object-oriented interface
 * @export
 * @class FollowUpApi
 * @extends {BaseAPI}
 */
export class FollowUpApi extends BaseAPI implements FollowUpApiInterface {
    /**
     * 
     * @param {string} applicationId 
     * @param {CreateFollowUpRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowUpApi
     */
    public createFollowUp(applicationId: string, model?: CreateFollowUpRequest, options?: any) {
        return FollowUpApiFp(this.configuration).createFollowUp(applicationId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} followUpId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowUpApi
     */
    public deleteFollowUp(followUpId: string, options?: any) {
        return FollowUpApiFp(this.configuration).deleteFollowUp(followUpId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} followUpId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowUpApi
     */
    public findChildContentContainer(followUpId: string, options?: any) {
        return FollowUpApiFp(this.configuration).findChildContentContainer(followUpId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} followUpId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowUpApi
     */
    public findFollowUp(followUpId: string, options?: any) {
        return FollowUpApiFp(this.configuration).findFollowUp(followUpId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowUpApi
     */
    public getForApplication(applicationId: string, options?: any) {
        return FollowUpApiFp(this.configuration).getForApplication(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} featureTypeId 
     * @param {string} contentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowUpApi
     */
    public getParentContentItems(featureTypeId: string, contentId: string, options?: any) {
        return FollowUpApiFp(this.configuration).getParentContentItems(featureTypeId, contentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} featureTypeId 
     * @param {string} contentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowUpApi
     */
    public getParentsOfContent(featureTypeId: string, contentId: string, options?: any) {
        return FollowUpApiFp(this.configuration).getParentsOfContent(featureTypeId, contentId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {UpdateFollowUpRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowUpApi
     */
    public updateFollowUp(model?: UpdateFollowUpRequest, options?: any) {
        return FollowUpApiFp(this.configuration).updateFollowUp(model, options)(this.fetch, this.basePath);
    }

}

/**
 * GoogleAuthorizationApi - fetch parameter creator
 * @export
 */
export const GoogleAuthorizationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableGoogleCredentialsAsync(organizationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling getAvailableGoogleCredentialsAsync.');
            }
            const localVarPath = `/api/GoogleAuthorization/Credentials/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {string} [error] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleAuthCallbackAsync(code?: string, state?: string, error?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/GoogleAuthorization/Callback`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (error !== undefined) {
                localVarQueryParameter['error'] = error;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCredential(tokenId: string, options: any = {}): FetchArgs {
            // verify required parameter 'tokenId' is not null or undefined
            if (tokenId === null || tokenId === undefined) {
                throw new RequiredError('tokenId','Required parameter tokenId was null or undefined when calling removeCredential.');
            }
            const localVarPath = `/api/GoogleAuthorization/Credentials/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [organizationId] 
         * @param {string} [applicationId] 
         * @param {string} [salt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestAuthenticationUrl(organizationId?: string, applicationId?: string, salt?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/GoogleAuthorization/AuthorizationUrl`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (salt !== undefined) {
                localVarQueryParameter['salt'] = salt;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GoogleAuthorizationApi - functional programming interface
 * @export
 */
export const GoogleAuthorizationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableGoogleCredentialsAsync(organizationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TokenResponse>> {
            const localVarFetchArgs = GoogleAuthorizationApiFetchParamCreator(configuration).getAvailableGoogleCredentialsAsync(organizationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {string} [error] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleAuthCallbackAsync(code?: string, state?: string, error?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = GoogleAuthorizationApiFetchParamCreator(configuration).googleAuthCallbackAsync(code, state, error, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCredential(tokenId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = GoogleAuthorizationApiFetchParamCreator(configuration).removeCredential(tokenId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [organizationId] 
         * @param {string} [applicationId] 
         * @param {string} [salt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestAuthenticationUrl(organizationId?: string, applicationId?: string, salt?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = GoogleAuthorizationApiFetchParamCreator(configuration).requestAuthenticationUrl(organizationId, applicationId, salt, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * GoogleAuthorizationApi - factory interface
 * @export
 */
export const GoogleAuthorizationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableGoogleCredentialsAsync(organizationId: string, options?: any) {
            return GoogleAuthorizationApiFp(configuration).getAvailableGoogleCredentialsAsync(organizationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {string} [error] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        googleAuthCallbackAsync(code?: string, state?: string, error?: string, options?: any) {
            return GoogleAuthorizationApiFp(configuration).googleAuthCallbackAsync(code, state, error, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCredential(tokenId: string, options?: any) {
            return GoogleAuthorizationApiFp(configuration).removeCredential(tokenId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [organizationId] 
         * @param {string} [applicationId] 
         * @param {string} [salt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestAuthenticationUrl(organizationId?: string, applicationId?: string, salt?: string, options?: any) {
            return GoogleAuthorizationApiFp(configuration).requestAuthenticationUrl(organizationId, applicationId, salt, options)(fetch, basePath);
        },
    };
};

/**
 * GoogleAuthorizationApi - interface
 * @export
 * @interface GoogleAuthorizationApi
 */
export interface GoogleAuthorizationApiInterface {
    /**
     * 
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAuthorizationApiInterface
     */
    getAvailableGoogleCredentialsAsync(organizationId: string, options?: any): Promise<Array<TokenResponse>>;

    /**
     * 
     * @param {string} [code] 
     * @param {string} [state] 
     * @param {string} [error] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAuthorizationApiInterface
     */
    googleAuthCallbackAsync(code?: string, state?: string, error?: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} tokenId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAuthorizationApiInterface
     */
    removeCredential(tokenId: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} [organizationId] 
     * @param {string} [applicationId] 
     * @param {string} [salt] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAuthorizationApiInterface
     */
    requestAuthenticationUrl(organizationId?: string, applicationId?: string, salt?: string, options?: any): Promise<string>;

}

/**
 * GoogleAuthorizationApi - object-oriented interface
 * @export
 * @class GoogleAuthorizationApi
 * @extends {BaseAPI}
 */
export class GoogleAuthorizationApi extends BaseAPI implements GoogleAuthorizationApiInterface {
    /**
     * 
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAuthorizationApi
     */
    public getAvailableGoogleCredentialsAsync(organizationId: string, options?: any) {
        return GoogleAuthorizationApiFp(this.configuration).getAvailableGoogleCredentialsAsync(organizationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [code] 
     * @param {string} [state] 
     * @param {string} [error] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAuthorizationApi
     */
    public googleAuthCallbackAsync(code?: string, state?: string, error?: string, options?: any) {
        return GoogleAuthorizationApiFp(this.configuration).googleAuthCallbackAsync(code, state, error, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} tokenId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAuthorizationApi
     */
    public removeCredential(tokenId: string, options?: any) {
        return GoogleAuthorizationApiFp(this.configuration).removeCredential(tokenId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [organizationId] 
     * @param {string} [applicationId] 
     * @param {string} [salt] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GoogleAuthorizationApi
     */
    public requestAuthenticationUrl(organizationId?: string, applicationId?: string, salt?: string, options?: any) {
        return GoogleAuthorizationApiFp(this.configuration).requestAuthenticationUrl(organizationId, applicationId, salt, options)(this.fetch, this.basePath);
    }

}

/**
 * HealthCheckApi - fetch parameter creator
 * @export
 */
export const HealthCheckApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(options: any = {}): FetchArgs {
            const localVarPath = `/api/HealthCheck`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthCheckApi - functional programming interface
 * @export
 */
export const HealthCheckApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = HealthCheckApiFetchParamCreator(configuration).healthCheck(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HealthCheckApi - factory interface
 * @export
 */
export const HealthCheckApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheck(options?: any) {
            return HealthCheckApiFp(configuration).healthCheck(options)(fetch, basePath);
        },
    };
};

/**
 * HealthCheckApi - interface
 * @export
 * @interface HealthCheckApi
 */
export interface HealthCheckApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckApiInterface
     */
    healthCheck(options?: any): Promise<{}>;

}

/**
 * HealthCheckApi - object-oriented interface
 * @export
 * @class HealthCheckApi
 * @extends {BaseAPI}
 */
export class HealthCheckApi extends BaseAPI implements HealthCheckApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthCheckApi
     */
    public healthCheck(options?: any) {
        return HealthCheckApiFp(this.configuration).healthCheck(options)(this.fetch, this.basePath);
    }

}

/**
 * HelpMessageApi - fetch parameter creator
 * @export
 */
export const HelpMessageApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds an audio file to the help message
         * @param {string} helpMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFileImage(helpMessageId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'helpMessageId' is not null or undefined
            if (helpMessageId === null || helpMessageId === undefined) {
                throw new RequiredError('helpMessageId','Required parameter helpMessageId was null or undefined when calling addAudioFileImage.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addAudioFileImage.');
            }
            const localVarPath = `/api/HelpMessage/{helpMessageId}/addAudioFile/{mediaItemId}`
                .replace(`{${"helpMessageId"}}`, encodeURIComponent(String(helpMessageId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a new help message to the given application
         * @param {string} applicationId 
         * @param {NewHelpMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addHelpMessage(applicationId: string, model?: NewHelpMessageRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling addHelpMessage.');
            }
            const localVarPath = `/api/HelpMessage/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewHelpMessageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a new help message to the given application
         * @param {string} applicationId 
         * @param {NewHelpMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addHelpMessageStub(applicationId: string, model?: NewHelpMessageStubRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling addHelpMessageStub.');
            }
            const localVarPath = `/api/HelpMessage/{applicationId}/stub`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewHelpMessageStubRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a large image to the help message
         * @param {string} helpMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(helpMessageId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'helpMessageId' is not null or undefined
            if (helpMessageId === null || helpMessageId === undefined) {
                throw new RequiredError('helpMessageId','Required parameter helpMessageId was null or undefined when calling addLargeImage.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addLargeImage.');
            }
            const localVarPath = `/api/HelpMessage/{helpMessageId}/addLargeImage/{mediaItemId}`
                .replace(`{${"helpMessageId"}}`, encodeURIComponent(String(helpMessageId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a small image to the help message
         * @param {string} helpMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(helpMessageId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'helpMessageId' is not null or undefined
            if (helpMessageId === null || helpMessageId === undefined) {
                throw new RequiredError('helpMessageId','Required parameter helpMessageId was null or undefined when calling addSmallImage.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addSmallImage.');
            }
            const localVarPath = `/api/HelpMessage/{helpMessageId}/addSmallImage/{mediaItemId}`
                .replace(`{${"helpMessageId"}}`, encodeURIComponent(String(helpMessageId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a video file to the help message
         * @param {string} helpMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(helpMessageId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'helpMessageId' is not null or undefined
            if (helpMessageId === null || helpMessageId === undefined) {
                throw new RequiredError('helpMessageId','Required parameter helpMessageId was null or undefined when calling addVideoFile.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addVideoFile.');
            }
            const localVarPath = `/api/HelpMessage/{helpMessageId}/addVideoFile/{mediaItemId}`
                .replace(`{${"helpMessageId"}}`, encodeURIComponent(String(helpMessageId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} helpMessageId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(helpMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'helpMessageId' is not null or undefined
            if (helpMessageId === null || helpMessageId === undefined) {
                throw new RequiredError('helpMessageId','Required parameter helpMessageId was null or undefined when calling addWebhook.');
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId','Required parameter webhookId was null or undefined when calling addWebhook.');
            }
            const localVarPath = `/api/HelpMessage/{helpMessageId}/webhooks/{webhookId}`
                .replace(`{${"helpMessageId"}}`, encodeURIComponent(String(helpMessageId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} helpMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(helpMessageId: string, options: any = {}): FetchArgs {
            // verify required parameter 'helpMessageId' is not null or undefined
            if (helpMessageId === null || helpMessageId === undefined) {
                throw new RequiredError('helpMessageId','Required parameter helpMessageId was null or undefined when calling copyContentItem.');
            }
            const localVarPath = `/api/HelpMessage/{helpMessageId}/copy`
                .replace(`{${"helpMessageId"}}`, encodeURIComponent(String(helpMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {HelpMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: HelpMessageModel, options: any = {}): FetchArgs {
            const localVarPath = `/api/HelpMessage/full`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"HelpMessageModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling createUserDefinedParameter.');
            }
            const localVarPath = `/api/HelpMessage/webhook/{instanceWebhookId}/userParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDefinedWebhookParameterCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes the given message
         * @param {string} helpMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHelpMessage(helpMessageId: string, options: any = {}): FetchArgs {
            // verify required parameter 'helpMessageId' is not null or undefined
            if (helpMessageId === null || helpMessageId === undefined) {
                throw new RequiredError('helpMessageId','Required parameter helpMessageId was null or undefined when calling deleteHelpMessage.');
            }
            const localVarPath = `/api/HelpMessage/{helpMessageId}`
                .replace(`{${"helpMessageId"}}`, encodeURIComponent(String(helpMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling findFullById.');
            }
            const localVarPath = `/api/HelpMessage/full/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling getByApplicationFeature.');
            }
            const localVarPath = `/api/HelpMessage/byFeature/{applicationFeatureId}`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the help messages for the given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelpMessagesForApplication(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getHelpMessagesForApplication.');
            }
            const localVarPath = `/api/HelpMessage/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} helpMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(helpMessageId: string, options: any = {}): FetchArgs {
            // verify required parameter 'helpMessageId' is not null or undefined
            if (helpMessageId === null || helpMessageId === undefined) {
                throw new RequiredError('helpMessageId','Required parameter helpMessageId was null or undefined when calling getWebhooks.');
            }
            const localVarPath = `/api/HelpMessage/{helpMessageId}/webhooks`
                .replace(`{${"helpMessageId"}}`, encodeURIComponent(String(helpMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'contentItemId' is not null or undefined
            if (contentItemId === null || contentItemId === undefined) {
                throw new RequiredError('contentItemId','Required parameter contentItemId was null or undefined when calling moveContentItemToApplicationFeature.');
            }
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling moveContentItemToApplicationFeature.');
            }
            const localVarPath = `/api/HelpMessage/{contentItemId}/MoveToFeature/{applicationFeatureId}`
                .replace(`{${"contentItemId"}}`, encodeURIComponent(String(contentItemId)))
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling removeUserDefinedParameter.');
            }
            // verify required parameter 'parameterName' is not null or undefined
            if (parameterName === null || parameterName === undefined) {
                throw new RequiredError('parameterName','Required parameter parameterName was null or undefined when calling removeUserDefinedParameter.');
            }
            const localVarPath = `/api/HelpMessage/webhook/{instanceWebhookId}/userParameters/{parameterName}`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)))
                .replace(`{${"parameterName"}}`, encodeURIComponent(String(parameterName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} helpMessageWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(helpMessageWebhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'helpMessageWebhookId' is not null or undefined
            if (helpMessageWebhookId === null || helpMessageWebhookId === undefined) {
                throw new RequiredError('helpMessageWebhookId','Required parameter helpMessageWebhookId was null or undefined when calling removeWebhook.');
            }
            const localVarPath = `/api/HelpMessage/webhook/{helpMessageWebhookId}`
                .replace(`{${"helpMessageWebhookId"}}`, encodeURIComponent(String(helpMessageWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggles whether the given help Message is live or not
         * @param {string} helpMessageId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleIsLive(helpMessageId: string, model?: ToggleLiveRequest, options: any = {}): FetchArgs {
            // verify required parameter 'helpMessageId' is not null or undefined
            if (helpMessageId === null || helpMessageId === undefined) {
                throw new RequiredError('helpMessageId','Required parameter helpMessageId was null or undefined when calling toggleIsLive.');
            }
            const localVarPath = `/api/HelpMessage/{helpMessageId}/isLive`
                .replace(`{${"helpMessageId"}}`, encodeURIComponent(String(helpMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ToggleLiveRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} helpMessageId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(helpMessageId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'helpMessageId' is not null or undefined
            if (helpMessageId === null || helpMessageId === undefined) {
                throw new RequiredError('helpMessageId','Required parameter helpMessageId was null or undefined when calling updateAttachedWebhook.');
            }
            // verify required parameter 'webhookInstanceId' is not null or undefined
            if (webhookInstanceId === null || webhookInstanceId === undefined) {
                throw new RequiredError('webhookInstanceId','Required parameter webhookInstanceId was null or undefined when calling updateAttachedWebhook.');
            }
            const localVarPath = `/api/HelpMessage/{helpMessageId}/webhooks/{webhookInstanceId}`
                .replace(`{${"helpMessageId"}}`, encodeURIComponent(String(helpMessageId)))
                .replace(`{${"webhookInstanceId"}}`, encodeURIComponent(String(webhookInstanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {HelpMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: HelpMessageModel, options: any = {}): FetchArgs {
            // verify required parameter 'contentItemId' is not null or undefined
            if (contentItemId === null || contentItemId === undefined) {
                throw new RequiredError('contentItemId','Required parameter contentItemId was null or undefined when calling updateFullContentItem.');
            }
            const localVarPath = `/api/HelpMessage/{contentItemId}/full`
                .replace(`{${"contentItemId"}}`, encodeURIComponent(String(contentItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"HelpMessageModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the content of the given help message id
         * @param {string} helpMessageId 
         * @param {UpdateHelpMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHelpMessage(helpMessageId: string, model?: UpdateHelpMessageRequest, options: any = {}): FetchArgs {
            // verify required parameter 'helpMessageId' is not null or undefined
            if (helpMessageId === null || helpMessageId === undefined) {
                throw new RequiredError('helpMessageId','Required parameter helpMessageId was null or undefined when calling updateHelpMessage.');
            }
            const localVarPath = `/api/HelpMessage/{helpMessageId}/update`
                .replace(`{${"helpMessageId"}}`, encodeURIComponent(String(helpMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateHelpMessageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the content of the given help message id
         * @param {string} helpMessageId 
         * @param {UpdateHelpMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHelpMessageStub(helpMessageId: string, model?: UpdateHelpMessageStubRequest, options: any = {}): FetchArgs {
            // verify required parameter 'helpMessageId' is not null or undefined
            if (helpMessageId === null || helpMessageId === undefined) {
                throw new RequiredError('helpMessageId','Required parameter helpMessageId was null or undefined when calling updateHelpMessageStub.');
            }
            const localVarPath = `/api/HelpMessage/{helpMessageId}/update/stub`
                .replace(`{${"helpMessageId"}}`, encodeURIComponent(String(helpMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateHelpMessageStubRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateUserDefinedParameter.');
            }
            const localVarPath = `/api/HelpMessage/webhook/{instanceWebhookId}/userParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDefinedWebhookParameterUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateWebhookParameter.');
            }
            const localVarPath = `/api/HelpMessage/webhook/{instanceWebhookId}/webhookParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParameterUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelpMessageApi - functional programming interface
 * @export
 */
export const HelpMessageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds an audio file to the help message
         * @param {string} helpMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFileImage(helpMessageId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HelpMessageModel> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).addAudioFileImage(helpMessageId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a new help message to the given application
         * @param {string} applicationId 
         * @param {NewHelpMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addHelpMessage(applicationId: string, model?: NewHelpMessageRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HelpMessageModel> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).addHelpMessage(applicationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a new help message to the given application
         * @param {string} applicationId 
         * @param {NewHelpMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addHelpMessageStub(applicationId: string, model?: NewHelpMessageStubRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HelpMessageModel> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).addHelpMessageStub(applicationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a large image to the help message
         * @param {string} helpMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(helpMessageId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HelpMessageModel> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).addLargeImage(helpMessageId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a small image to the help message
         * @param {string} helpMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(helpMessageId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HelpMessageModel> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).addSmallImage(helpMessageId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a video file to the help message
         * @param {string} helpMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(helpMessageId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HelpMessageModel> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).addVideoFile(helpMessageId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} helpMessageId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(helpMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HelpMessageWebhookModel> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).addWebhook(helpMessageId, webhookId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} helpMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(helpMessageId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HelpMessageModel> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).copyContentItem(helpMessageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {HelpMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: HelpMessageModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HelpMessageModel> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).createFullContentItem(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).createUserDefinedParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes the given message
         * @param {string} helpMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHelpMessage(helpMessageId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HelpMessageModel> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).deleteHelpMessage(helpMessageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HelpMessageModel> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).findFullById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<HelpMessageModel>> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).getByApplicationFeature(applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the help messages for the given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelpMessagesForApplication(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<HelpMessageModel>> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).getHelpMessagesForApplication(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} helpMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(helpMessageId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<HelpMessageWebhookModel>> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).getWebhooks(helpMessageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HelpMessageModel> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} helpMessageWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(helpMessageWebhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HelpMessageWebhookModel> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).removeWebhook(helpMessageWebhookId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Toggles whether the given help Message is live or not
         * @param {string} helpMessageId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleIsLive(helpMessageId: string, model?: ToggleLiveRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HelpMessageModel> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).toggleIsLive(helpMessageId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} helpMessageId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(helpMessageId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HelpMessageWebhookModel> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).updateAttachedWebhook(helpMessageId, webhookInstanceId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {HelpMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: HelpMessageModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HelpMessageModel> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).updateFullContentItem(contentItemId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the content of the given help message id
         * @param {string} helpMessageId 
         * @param {UpdateHelpMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHelpMessage(helpMessageId: string, model?: UpdateHelpMessageRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HelpMessageModel> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).updateHelpMessage(helpMessageId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the content of the given help message id
         * @param {string} helpMessageId 
         * @param {UpdateHelpMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHelpMessageStub(helpMessageId: string, model?: UpdateHelpMessageStubRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<HelpMessageModel> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).updateHelpMessageStub(helpMessageId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).updateUserDefinedParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = HelpMessageApiFetchParamCreator(configuration).updateWebhookParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HelpMessageApi - factory interface
 * @export
 */
export const HelpMessageApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Adds an audio file to the help message
         * @param {string} helpMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFileImage(helpMessageId: string, mediaItemId: string, options?: any) {
            return HelpMessageApiFp(configuration).addAudioFileImage(helpMessageId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a new help message to the given application
         * @param {string} applicationId 
         * @param {NewHelpMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addHelpMessage(applicationId: string, model?: NewHelpMessageRequest, options?: any) {
            return HelpMessageApiFp(configuration).addHelpMessage(applicationId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a new help message to the given application
         * @param {string} applicationId 
         * @param {NewHelpMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addHelpMessageStub(applicationId: string, model?: NewHelpMessageStubRequest, options?: any) {
            return HelpMessageApiFp(configuration).addHelpMessageStub(applicationId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a large image to the help message
         * @param {string} helpMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(helpMessageId: string, mediaItemId: string, options?: any) {
            return HelpMessageApiFp(configuration).addLargeImage(helpMessageId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a small image to the help message
         * @param {string} helpMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(helpMessageId: string, mediaItemId: string, options?: any) {
            return HelpMessageApiFp(configuration).addSmallImage(helpMessageId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a video file to the help message
         * @param {string} helpMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(helpMessageId: string, mediaItemId: string, options?: any) {
            return HelpMessageApiFp(configuration).addVideoFile(helpMessageId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} helpMessageId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(helpMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
            return HelpMessageApiFp(configuration).addWebhook(helpMessageId, webhookId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} helpMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(helpMessageId: string, options?: any) {
            return HelpMessageApiFp(configuration).copyContentItem(helpMessageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {HelpMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: HelpMessageModel, options?: any) {
            return HelpMessageApiFp(configuration).createFullContentItem(model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any) {
            return HelpMessageApiFp(configuration).createUserDefinedParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes the given message
         * @param {string} helpMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteHelpMessage(helpMessageId: string, options?: any) {
            return HelpMessageApiFp(configuration).deleteHelpMessage(helpMessageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options?: any) {
            return HelpMessageApiFp(configuration).findFullById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options?: any) {
            return HelpMessageApiFp(configuration).getByApplicationFeature(applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the help messages for the given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelpMessagesForApplication(applicationId: string, options?: any) {
            return HelpMessageApiFp(configuration).getHelpMessagesForApplication(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} helpMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(helpMessageId: string, options?: any) {
            return HelpMessageApiFp(configuration).getWebhooks(helpMessageId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any) {
            return HelpMessageApiFp(configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any) {
            return HelpMessageApiFp(configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} helpMessageWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(helpMessageWebhookId: string, options?: any) {
            return HelpMessageApiFp(configuration).removeWebhook(helpMessageWebhookId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Toggles whether the given help Message is live or not
         * @param {string} helpMessageId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleIsLive(helpMessageId: string, model?: ToggleLiveRequest, options?: any) {
            return HelpMessageApiFp(configuration).toggleIsLive(helpMessageId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} helpMessageId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(helpMessageId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any) {
            return HelpMessageApiFp(configuration).updateAttachedWebhook(helpMessageId, webhookInstanceId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {HelpMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: HelpMessageModel, options?: any) {
            return HelpMessageApiFp(configuration).updateFullContentItem(contentItemId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the content of the given help message id
         * @param {string} helpMessageId 
         * @param {UpdateHelpMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHelpMessage(helpMessageId: string, model?: UpdateHelpMessageRequest, options?: any) {
            return HelpMessageApiFp(configuration).updateHelpMessage(helpMessageId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the content of the given help message id
         * @param {string} helpMessageId 
         * @param {UpdateHelpMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHelpMessageStub(helpMessageId: string, model?: UpdateHelpMessageStubRequest, options?: any) {
            return HelpMessageApiFp(configuration).updateHelpMessageStub(helpMessageId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any) {
            return HelpMessageApiFp(configuration).updateUserDefinedParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any) {
            return HelpMessageApiFp(configuration).updateWebhookParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
    };
};

/**
 * HelpMessageApi - interface
 * @export
 * @interface HelpMessageApi
 */
export interface HelpMessageApiInterface {
    /**
     * 
     * @summary Adds an audio file to the help message
     * @param {string} helpMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    addAudioFileImage(helpMessageId: string, mediaItemId: string, options?: any): Promise<HelpMessageModel>;

    /**
     * 
     * @summary Adds a new help message to the given application
     * @param {string} applicationId 
     * @param {NewHelpMessageRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    addHelpMessage(applicationId: string, model?: NewHelpMessageRequest, options?: any): Promise<HelpMessageModel>;

    /**
     * 
     * @summary Adds a new help message to the given application
     * @param {string} applicationId 
     * @param {NewHelpMessageStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    addHelpMessageStub(applicationId: string, model?: NewHelpMessageStubRequest, options?: any): Promise<HelpMessageModel>;

    /**
     * 
     * @summary Adds a large image to the help message
     * @param {string} helpMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    addLargeImage(helpMessageId: string, mediaItemId: string, options?: any): Promise<HelpMessageModel>;

    /**
     * 
     * @summary Adds a small image to the help message
     * @param {string} helpMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    addSmallImage(helpMessageId: string, mediaItemId: string, options?: any): Promise<HelpMessageModel>;

    /**
     * 
     * @summary Adds a video file to the help message
     * @param {string} helpMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    addVideoFile(helpMessageId: string, mediaItemId: string, options?: any): Promise<HelpMessageModel>;

    /**
     * 
     * @param {string} helpMessageId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    addWebhook(helpMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): Promise<HelpMessageWebhookModel>;

    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param {string} helpMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    copyContentItem(helpMessageId: string, options?: any): Promise<HelpMessageModel>;

    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param {HelpMessageModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    createFullContentItem(model?: HelpMessageModel, options?: any): Promise<HelpMessageModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterCreateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @summary Deletes the given message
     * @param {string} helpMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    deleteHelpMessage(helpMessageId: string, options?: any): Promise<HelpMessageModel>;

    /**
     * 
     * @summary Finds the full content item by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    findFullById(id: string, options?: any): Promise<HelpMessageModel>;

    /**
     * 
     * @summary Gets the content for the given application feature
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    getByApplicationFeature(applicationFeatureId: string, options?: any): Promise<Array<HelpMessageModel>>;

    /**
     * 
     * @summary Gets the help messages for the given application
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    getHelpMessagesForApplication(applicationId: string, options?: any): Promise<Array<HelpMessageModel>>;

    /**
     * 
     * @param {string} helpMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    getWebhooks(helpMessageId: string, options?: any): Promise<Array<HelpMessageWebhookModel>>;

    /**
     * 
     * @param {string} contentItemId 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any): Promise<HelpMessageModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {string} parameterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} helpMessageWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    removeWebhook(helpMessageWebhookId: string, options?: any): Promise<HelpMessageWebhookModel>;

    /**
     * 
     * @summary Toggles whether the given help Message is live or not
     * @param {string} helpMessageId 
     * @param {ToggleLiveRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    toggleIsLive(helpMessageId: string, model?: ToggleLiveRequest, options?: any): Promise<HelpMessageModel>;

    /**
     * 
     * @param {string} helpMessageId 
     * @param {string} webhookInstanceId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    updateAttachedWebhook(helpMessageId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any): Promise<HelpMessageWebhookModel>;

    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param {string} contentItemId 
     * @param {HelpMessageModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    updateFullContentItem(contentItemId: string, model?: HelpMessageModel, options?: any): Promise<HelpMessageModel>;

    /**
     * 
     * @summary Updates the content of the given help message id
     * @param {string} helpMessageId 
     * @param {UpdateHelpMessageRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    updateHelpMessage(helpMessageId: string, model?: UpdateHelpMessageRequest, options?: any): Promise<HelpMessageModel>;

    /**
     * 
     * @summary Updates the content of the given help message id
     * @param {string} helpMessageId 
     * @param {UpdateHelpMessageStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    updateHelpMessageStub(helpMessageId: string, model?: UpdateHelpMessageStubRequest, options?: any): Promise<HelpMessageModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {WebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApiInterface
     */
    updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any): Promise<boolean>;

}

/**
 * HelpMessageApi - object-oriented interface
 * @export
 * @class HelpMessageApi
 * @extends {BaseAPI}
 */
export class HelpMessageApi extends BaseAPI implements HelpMessageApiInterface {
    /**
     * 
     * @summary Adds an audio file to the help message
     * @param {string} helpMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public addAudioFileImage(helpMessageId: string, mediaItemId: string, options?: any) {
        return HelpMessageApiFp(this.configuration).addAudioFileImage(helpMessageId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a new help message to the given application
     * @param {string} applicationId 
     * @param {NewHelpMessageRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public addHelpMessage(applicationId: string, model?: NewHelpMessageRequest, options?: any) {
        return HelpMessageApiFp(this.configuration).addHelpMessage(applicationId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a new help message to the given application
     * @param {string} applicationId 
     * @param {NewHelpMessageStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public addHelpMessageStub(applicationId: string, model?: NewHelpMessageStubRequest, options?: any) {
        return HelpMessageApiFp(this.configuration).addHelpMessageStub(applicationId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a large image to the help message
     * @param {string} helpMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public addLargeImage(helpMessageId: string, mediaItemId: string, options?: any) {
        return HelpMessageApiFp(this.configuration).addLargeImage(helpMessageId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a small image to the help message
     * @param {string} helpMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public addSmallImage(helpMessageId: string, mediaItemId: string, options?: any) {
        return HelpMessageApiFp(this.configuration).addSmallImage(helpMessageId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a video file to the help message
     * @param {string} helpMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public addVideoFile(helpMessageId: string, mediaItemId: string, options?: any) {
        return HelpMessageApiFp(this.configuration).addVideoFile(helpMessageId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} helpMessageId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public addWebhook(helpMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
        return HelpMessageApiFp(this.configuration).addWebhook(helpMessageId, webhookId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param {string} helpMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public copyContentItem(helpMessageId: string, options?: any) {
        return HelpMessageApiFp(this.configuration).copyContentItem(helpMessageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param {HelpMessageModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public createFullContentItem(model?: HelpMessageModel, options?: any) {
        return HelpMessageApiFp(this.configuration).createFullContentItem(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterCreateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any) {
        return HelpMessageApiFp(this.configuration).createUserDefinedParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes the given message
     * @param {string} helpMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public deleteHelpMessage(helpMessageId: string, options?: any) {
        return HelpMessageApiFp(this.configuration).deleteHelpMessage(helpMessageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Finds the full content item by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public findFullById(id: string, options?: any) {
        return HelpMessageApiFp(this.configuration).findFullById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the content for the given application feature
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public getByApplicationFeature(applicationFeatureId: string, options?: any) {
        return HelpMessageApiFp(this.configuration).getByApplicationFeature(applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the help messages for the given application
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public getHelpMessagesForApplication(applicationId: string, options?: any) {
        return HelpMessageApiFp(this.configuration).getHelpMessagesForApplication(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} helpMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public getWebhooks(helpMessageId: string, options?: any) {
        return HelpMessageApiFp(this.configuration).getWebhooks(helpMessageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} contentItemId 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any) {
        return HelpMessageApiFp(this.configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {string} parameterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any) {
        return HelpMessageApiFp(this.configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} helpMessageWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public removeWebhook(helpMessageWebhookId: string, options?: any) {
        return HelpMessageApiFp(this.configuration).removeWebhook(helpMessageWebhookId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Toggles whether the given help Message is live or not
     * @param {string} helpMessageId 
     * @param {ToggleLiveRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public toggleIsLive(helpMessageId: string, model?: ToggleLiveRequest, options?: any) {
        return HelpMessageApiFp(this.configuration).toggleIsLive(helpMessageId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} helpMessageId 
     * @param {string} webhookInstanceId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public updateAttachedWebhook(helpMessageId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any) {
        return HelpMessageApiFp(this.configuration).updateAttachedWebhook(helpMessageId, webhookInstanceId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param {string} contentItemId 
     * @param {HelpMessageModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public updateFullContentItem(contentItemId: string, model?: HelpMessageModel, options?: any) {
        return HelpMessageApiFp(this.configuration).updateFullContentItem(contentItemId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the content of the given help message id
     * @param {string} helpMessageId 
     * @param {UpdateHelpMessageRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public updateHelpMessage(helpMessageId: string, model?: UpdateHelpMessageRequest, options?: any) {
        return HelpMessageApiFp(this.configuration).updateHelpMessage(helpMessageId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the content of the given help message id
     * @param {string} helpMessageId 
     * @param {UpdateHelpMessageStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public updateHelpMessageStub(helpMessageId: string, model?: UpdateHelpMessageStubRequest, options?: any) {
        return HelpMessageApiFp(this.configuration).updateHelpMessageStub(helpMessageId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any) {
        return HelpMessageApiFp(this.configuration).updateUserDefinedParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {WebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpMessageApi
     */
    public updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any) {
        return HelpMessageApiFp(this.configuration).updateWebhookParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

}

/**
 * ImportExportApi - fetch parameter creator
 * @export
 */
export const ImportExportApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Exports the application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportApplication(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling exportApplication.');
            }
            const localVarPath = `/api/ImportExport/export/application/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Exports the application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportApplicationFile(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling exportApplicationFile.');
            }
            const localVarPath = `/api/ImportExport/export/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Exports the application's interaction model only
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportApplicationInteractionModel(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling exportApplicationInteractionModel.');
            }
            const localVarPath = `/api/ImportExport/export/interactionModel/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Exports the application's interaction model to file
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportApplicationInteractionModelFile(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling exportApplicationInteractionModelFile.');
            }
            const localVarPath = `/api/ImportExport/export/interactionModel/{applicationId}/file`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Exports custom content based off of request
         * @param {BulkContentRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportContent(request?: BulkContentRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/ImportExport/export/content`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkContentRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Exports custom content based off of request
         * @param {BulkContentRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportContentToFile(request?: BulkContentRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/ImportExport/export/contentToFile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkContentRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Imports the application
         * @param {string} applicationId 
         * @param {ExportModel} [exportModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importIntoApplication(applicationId: string, exportModel?: ExportModel, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling importIntoApplication.');
            }
            const localVarPath = `/api/ImportExport/import/intoApplication/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExportModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(exportModel || {}) : (exportModel || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import content to a feature with an export model
         * @param {string} applicationFeatureId 
         * @param {ExportModel} [exportModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importIntoApplicationFeature(applicationFeatureId: string, exportModel?: ExportModel, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling importIntoApplicationFeature.');
            }
            const localVarPath = `/api/ImportExport/import/intoApplicationFeature/{applicationFeatureId}`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExportModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(exportModel || {}) : (exportModel || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import content to a feature by file
         * @param {string} applicationFeatureId 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importIntoApplicationFeatureFromFile(applicationFeatureId: string, file?: any, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling importIntoApplicationFeatureFromFile.');
            }
            const localVarPath = `/api/ImportExport/import/intoApplicationFeatureFromFile/{applicationFeatureId}`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uploads the file and saves the media item to the application
         * @param {string} applicationId 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importIntoApplicationFromFile(applicationId: string, file?: any, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling importIntoApplicationFromFile.');
            }
            const localVarPath = `/api/ImportExport/import/intoApplicationFromFile/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImportExportApi - functional programming interface
 * @export
 */
export const ImportExportApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Exports the application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportApplication(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExportModel> {
            const localVarFetchArgs = ImportExportApiFetchParamCreator(configuration).exportApplication(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Exports the application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportApplicationFile(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ImportExportApiFetchParamCreator(configuration).exportApplicationFile(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Exports the application's interaction model only
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportApplicationInteractionModel(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExportModel> {
            const localVarFetchArgs = ImportExportApiFetchParamCreator(configuration).exportApplicationInteractionModel(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Exports the application's interaction model to file
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportApplicationInteractionModelFile(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ImportExportApiFetchParamCreator(configuration).exportApplicationInteractionModelFile(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Exports custom content based off of request
         * @param {BulkContentRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportContent(request?: BulkContentRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExportModel> {
            const localVarFetchArgs = ImportExportApiFetchParamCreator(configuration).exportContent(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Exports custom content based off of request
         * @param {BulkContentRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportContentToFile(request?: BulkContentRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ImportExportApiFetchParamCreator(configuration).exportContentToFile(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Imports the application
         * @param {string} applicationId 
         * @param {ExportModel} [exportModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importIntoApplication(applicationId: string, exportModel?: ExportModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ImportExportApiFetchParamCreator(configuration).importIntoApplication(applicationId, exportModel, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Import content to a feature with an export model
         * @param {string} applicationFeatureId 
         * @param {ExportModel} [exportModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importIntoApplicationFeature(applicationFeatureId: string, exportModel?: ExportModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ImportExportApiFetchParamCreator(configuration).importIntoApplicationFeature(applicationFeatureId, exportModel, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Import content to a feature by file
         * @param {string} applicationFeatureId 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importIntoApplicationFeatureFromFile(applicationFeatureId: string, file?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ImportExportApiFetchParamCreator(configuration).importIntoApplicationFeatureFromFile(applicationFeatureId, file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Uploads the file and saves the media item to the application
         * @param {string} applicationId 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importIntoApplicationFromFile(applicationId: string, file?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ImportExportApiFetchParamCreator(configuration).importIntoApplicationFromFile(applicationId, file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ImportExportApi - factory interface
 * @export
 */
export const ImportExportApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Exports the application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportApplication(applicationId: string, options?: any) {
            return ImportExportApiFp(configuration).exportApplication(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Exports the application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportApplicationFile(applicationId: string, options?: any) {
            return ImportExportApiFp(configuration).exportApplicationFile(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Exports the application's interaction model only
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportApplicationInteractionModel(applicationId: string, options?: any) {
            return ImportExportApiFp(configuration).exportApplicationInteractionModel(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Exports the application's interaction model to file
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportApplicationInteractionModelFile(applicationId: string, options?: any) {
            return ImportExportApiFp(configuration).exportApplicationInteractionModelFile(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Exports custom content based off of request
         * @param {BulkContentRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportContent(request?: BulkContentRequest, options?: any) {
            return ImportExportApiFp(configuration).exportContent(request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Exports custom content based off of request
         * @param {BulkContentRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportContentToFile(request?: BulkContentRequest, options?: any) {
            return ImportExportApiFp(configuration).exportContentToFile(request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Imports the application
         * @param {string} applicationId 
         * @param {ExportModel} [exportModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importIntoApplication(applicationId: string, exportModel?: ExportModel, options?: any) {
            return ImportExportApiFp(configuration).importIntoApplication(applicationId, exportModel, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Import content to a feature with an export model
         * @param {string} applicationFeatureId 
         * @param {ExportModel} [exportModel] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importIntoApplicationFeature(applicationFeatureId: string, exportModel?: ExportModel, options?: any) {
            return ImportExportApiFp(configuration).importIntoApplicationFeature(applicationFeatureId, exportModel, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Import content to a feature by file
         * @param {string} applicationFeatureId 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importIntoApplicationFeatureFromFile(applicationFeatureId: string, file?: any, options?: any) {
            return ImportExportApiFp(configuration).importIntoApplicationFeatureFromFile(applicationFeatureId, file, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Uploads the file and saves the media item to the application
         * @param {string} applicationId 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importIntoApplicationFromFile(applicationId: string, file?: any, options?: any) {
            return ImportExportApiFp(configuration).importIntoApplicationFromFile(applicationId, file, options)(fetch, basePath);
        },
    };
};

/**
 * ImportExportApi - interface
 * @export
 * @interface ImportExportApi
 */
export interface ImportExportApiInterface {
    /**
     * 
     * @summary Exports the application
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportExportApiInterface
     */
    exportApplication(applicationId: string, options?: any): Promise<ExportModel>;

    /**
     * 
     * @summary Exports the application
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportExportApiInterface
     */
    exportApplicationFile(applicationId: string, options?: any): Promise<string>;

    /**
     * 
     * @summary Exports the application's interaction model only
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportExportApiInterface
     */
    exportApplicationInteractionModel(applicationId: string, options?: any): Promise<ExportModel>;

    /**
     * 
     * @summary Exports the application's interaction model to file
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportExportApiInterface
     */
    exportApplicationInteractionModelFile(applicationId: string, options?: any): Promise<string>;

    /**
     * 
     * @summary Exports custom content based off of request
     * @param {BulkContentRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportExportApiInterface
     */
    exportContent(request?: BulkContentRequest, options?: any): Promise<ExportModel>;

    /**
     * 
     * @summary Exports custom content based off of request
     * @param {BulkContentRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportExportApiInterface
     */
    exportContentToFile(request?: BulkContentRequest, options?: any): Promise<string>;

    /**
     * 
     * @summary Imports the application
     * @param {string} applicationId 
     * @param {ExportModel} [exportModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportExportApiInterface
     */
    importIntoApplication(applicationId: string, exportModel?: ExportModel, options?: any): Promise<string>;

    /**
     * 
     * @summary Import content to a feature with an export model
     * @param {string} applicationFeatureId 
     * @param {ExportModel} [exportModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportExportApiInterface
     */
    importIntoApplicationFeature(applicationFeatureId: string, exportModel?: ExportModel, options?: any): Promise<string>;

    /**
     * 
     * @summary Import content to a feature by file
     * @param {string} applicationFeatureId 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportExportApiInterface
     */
    importIntoApplicationFeatureFromFile(applicationFeatureId: string, file?: any, options?: any): Promise<string>;

    /**
     * 
     * @summary Uploads the file and saves the media item to the application
     * @param {string} applicationId 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportExportApiInterface
     */
    importIntoApplicationFromFile(applicationId: string, file?: any, options?: any): Promise<string>;

}

/**
 * ImportExportApi - object-oriented interface
 * @export
 * @class ImportExportApi
 * @extends {BaseAPI}
 */
export class ImportExportApi extends BaseAPI implements ImportExportApiInterface {
    /**
     * 
     * @summary Exports the application
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportExportApi
     */
    public exportApplication(applicationId: string, options?: any) {
        return ImportExportApiFp(this.configuration).exportApplication(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Exports the application
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportExportApi
     */
    public exportApplicationFile(applicationId: string, options?: any) {
        return ImportExportApiFp(this.configuration).exportApplicationFile(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Exports the application's interaction model only
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportExportApi
     */
    public exportApplicationInteractionModel(applicationId: string, options?: any) {
        return ImportExportApiFp(this.configuration).exportApplicationInteractionModel(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Exports the application's interaction model to file
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportExportApi
     */
    public exportApplicationInteractionModelFile(applicationId: string, options?: any) {
        return ImportExportApiFp(this.configuration).exportApplicationInteractionModelFile(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Exports custom content based off of request
     * @param {BulkContentRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportExportApi
     */
    public exportContent(request?: BulkContentRequest, options?: any) {
        return ImportExportApiFp(this.configuration).exportContent(request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Exports custom content based off of request
     * @param {BulkContentRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportExportApi
     */
    public exportContentToFile(request?: BulkContentRequest, options?: any) {
        return ImportExportApiFp(this.configuration).exportContentToFile(request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Imports the application
     * @param {string} applicationId 
     * @param {ExportModel} [exportModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportExportApi
     */
    public importIntoApplication(applicationId: string, exportModel?: ExportModel, options?: any) {
        return ImportExportApiFp(this.configuration).importIntoApplication(applicationId, exportModel, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Import content to a feature with an export model
     * @param {string} applicationFeatureId 
     * @param {ExportModel} [exportModel] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportExportApi
     */
    public importIntoApplicationFeature(applicationFeatureId: string, exportModel?: ExportModel, options?: any) {
        return ImportExportApiFp(this.configuration).importIntoApplicationFeature(applicationFeatureId, exportModel, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Import content to a feature by file
     * @param {string} applicationFeatureId 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportExportApi
     */
    public importIntoApplicationFeatureFromFile(applicationFeatureId: string, file?: any, options?: any) {
        return ImportExportApiFp(this.configuration).importIntoApplicationFeatureFromFile(applicationFeatureId, file, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Uploads the file and saves the media item to the application
     * @param {string} applicationId 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImportExportApi
     */
    public importIntoApplicationFromFile(applicationId: string, file?: any, options?: any) {
        return ImportExportApiFp(this.configuration).importIntoApplicationFromFile(applicationId, file, options)(this.fetch, this.basePath);
    }

}

/**
 * InteractionModelApi - fetch parameter creator
 * @export
 */
export const InteractionModelApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaseInteractionModel(options: any = {}): FetchArgs {
            const localVarPath = `/api/InteractionModel`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [locale] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionModelForApplication(applicationId: string, locale?: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getInteractionModelForApplication.');
            }
            const localVarPath = `/api/InteractionModel/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionModelStatus(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getInteractionModelStatus.');
            }
            const localVarPath = `/api/InteractionModel/{applicationId}/status`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} locale 
         * @param {InteractionModelUpdate} [update] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInteractionModelForApplication(applicationId: string, locale: string, update?: InteractionModelUpdate, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling updateInteractionModelForApplication.');
            }
            // verify required parameter 'locale' is not null or undefined
            if (locale === null || locale === undefined) {
                throw new RequiredError('locale','Required parameter locale was null or undefined when calling updateInteractionModelForApplication.');
            }
            const localVarPath = `/api/InteractionModel/{applicationId}/{locale}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)))
                .replace(`{${"locale"}}`, encodeURIComponent(String(locale)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"InteractionModelUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(update || {}) : (update || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InteractionModelApi - functional programming interface
 * @export
 */
export const InteractionModelApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaseInteractionModel(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InteractionModel> {
            const localVarFetchArgs = InteractionModelApiFetchParamCreator(configuration).getBaseInteractionModel(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [locale] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionModelForApplication(applicationId: string, locale?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InteractionModel> {
            const localVarFetchArgs = InteractionModelApiFetchParamCreator(configuration).getInteractionModelForApplication(applicationId, locale, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionModelStatus(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InteractionModelStatus> {
            const localVarFetchArgs = InteractionModelApiFetchParamCreator(configuration).getInteractionModelStatus(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} locale 
         * @param {InteractionModelUpdate} [update] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInteractionModelForApplication(applicationId: string, locale: string, update?: InteractionModelUpdate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = InteractionModelApiFetchParamCreator(configuration).updateInteractionModelForApplication(applicationId, locale, update, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InteractionModelApi - factory interface
 * @export
 */
export const InteractionModelApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBaseInteractionModel(options?: any) {
            return InteractionModelApiFp(configuration).getBaseInteractionModel(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [locale] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionModelForApplication(applicationId: string, locale?: string, options?: any) {
            return InteractionModelApiFp(configuration).getInteractionModelForApplication(applicationId, locale, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInteractionModelStatus(applicationId: string, options?: any) {
            return InteractionModelApiFp(configuration).getInteractionModelStatus(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} locale 
         * @param {InteractionModelUpdate} [update] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInteractionModelForApplication(applicationId: string, locale: string, update?: InteractionModelUpdate, options?: any) {
            return InteractionModelApiFp(configuration).updateInteractionModelForApplication(applicationId, locale, update, options)(fetch, basePath);
        },
    };
};

/**
 * InteractionModelApi - interface
 * @export
 * @interface InteractionModelApi
 */
export interface InteractionModelApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionModelApiInterface
     */
    getBaseInteractionModel(options?: any): Promise<InteractionModel>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} [locale] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionModelApiInterface
     */
    getInteractionModelForApplication(applicationId: string, locale?: string, options?: any): Promise<InteractionModel>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionModelApiInterface
     */
    getInteractionModelStatus(applicationId: string, options?: any): Promise<InteractionModelStatus>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} locale 
     * @param {InteractionModelUpdate} [update] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionModelApiInterface
     */
    updateInteractionModelForApplication(applicationId: string, locale: string, update?: InteractionModelUpdate, options?: any): Promise<boolean>;

}

/**
 * InteractionModelApi - object-oriented interface
 * @export
 * @class InteractionModelApi
 * @extends {BaseAPI}
 */
export class InteractionModelApi extends BaseAPI implements InteractionModelApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionModelApi
     */
    public getBaseInteractionModel(options?: any) {
        return InteractionModelApiFp(this.configuration).getBaseInteractionModel(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} [locale] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionModelApi
     */
    public getInteractionModelForApplication(applicationId: string, locale?: string, options?: any) {
        return InteractionModelApiFp(this.configuration).getInteractionModelForApplication(applicationId, locale, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionModelApi
     */
    public getInteractionModelStatus(applicationId: string, options?: any) {
        return InteractionModelApiFp(this.configuration).getInteractionModelStatus(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} locale 
     * @param {InteractionModelUpdate} [update] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InteractionModelApi
     */
    public updateInteractionModelForApplication(applicationId: string, locale: string, update?: InteractionModelUpdate, options?: any) {
        return InteractionModelApiFp(this.configuration).updateInteractionModelForApplication(applicationId, locale, update, options)(this.fetch, this.basePath);
    }

}

/**
 * InvitationApi - fetch parameter creator
 * @export
 */
export const InvitationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Accepts the given invitation
         * @param {string} invitationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite(invitationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'invitationId' is not null or undefined
            if (invitationId === null || invitationId === undefined) {
                throw new RequiredError('invitationId','Required parameter invitationId was null or undefined when calling acceptInvite.');
            }
            const localVarPath = `/api/Invitation/accept/{invitationId}`
                .replace(`{${"invitationId"}}`, encodeURIComponent(String(invitationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Accepts the given invitation
         * @param {string} invitationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineInvite(invitationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'invitationId' is not null or undefined
            if (invitationId === null || invitationId === undefined) {
                throw new RequiredError('invitationId','Required parameter invitationId was null or undefined when calling declineInvite.');
            }
            const localVarPath = `/api/Invitation/decline/{invitationId}`
                .replace(`{${"invitationId"}}`, encodeURIComponent(String(invitationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all the user's pending invitations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvitations(options: any = {}): FetchArgs {
            const localVarPath = `/api/Invitation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Revokes an invite that was already created
         * @param {string} invitationId The id of the invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeInvite(invitationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'invitationId' is not null or undefined
            if (invitationId === null || invitationId === undefined) {
                throw new RequiredError('invitationId','Required parameter invitationId was null or undefined when calling revokeInvite.');
            }
            const localVarPath = `/api/Invitation/{invitationId}`
                .replace(`{${"invitationId"}}`, encodeURIComponent(String(invitationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sends an invitation for the given organization
         * @param {string} organizationId 
         * @param {NewInvitationRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInvite(organizationId: string, model?: NewInvitationRequest, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling sendInvite.');
            }
            const localVarPath = `/api/Invitation/{organizationId}/withRole`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewInvitationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {BasicInvitationRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInvite_1(organizationId: string, model?: BasicInvitationRequest, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling sendInvite_1.');
            }
            const localVarPath = `/api/Invitation/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BasicInvitationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvitationApi - functional programming interface
 * @export
 */
export const InvitationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Accepts the given invitation
         * @param {string} invitationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite(invitationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrganizationMemberModel> {
            const localVarFetchArgs = InvitationApiFetchParamCreator(configuration).acceptInvite(invitationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Accepts the given invitation
         * @param {string} invitationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineInvite(invitationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvitationModel> {
            const localVarFetchArgs = InvitationApiFetchParamCreator(configuration).declineInvite(invitationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets all the user's pending invitations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvitations(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<InvitationModel>> {
            const localVarFetchArgs = InvitationApiFetchParamCreator(configuration).getInvitations(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Revokes an invite that was already created
         * @param {string} invitationId The id of the invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeInvite(invitationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvitationModel> {
            const localVarFetchArgs = InvitationApiFetchParamCreator(configuration).revokeInvite(invitationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Sends an invitation for the given organization
         * @param {string} organizationId 
         * @param {NewInvitationRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInvite(organizationId: string, model?: NewInvitationRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvitationModel> {
            const localVarFetchArgs = InvitationApiFetchParamCreator(configuration).sendInvite(organizationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {BasicInvitationRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInvite_1(organizationId: string, model?: BasicInvitationRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InvitationModel> {
            const localVarFetchArgs = InvitationApiFetchParamCreator(configuration).sendInvite_1(organizationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InvitationApi - factory interface
 * @export
 */
export const InvitationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Accepts the given invitation
         * @param {string} invitationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acceptInvite(invitationId: string, options?: any) {
            return InvitationApiFp(configuration).acceptInvite(invitationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Accepts the given invitation
         * @param {string} invitationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        declineInvite(invitationId: string, options?: any) {
            return InvitationApiFp(configuration).declineInvite(invitationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets all the user's pending invitations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvitations(options?: any) {
            return InvitationApiFp(configuration).getInvitations(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Revokes an invite that was already created
         * @param {string} invitationId The id of the invitation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeInvite(invitationId: string, options?: any) {
            return InvitationApiFp(configuration).revokeInvite(invitationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Sends an invitation for the given organization
         * @param {string} organizationId 
         * @param {NewInvitationRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInvite(organizationId: string, model?: NewInvitationRequest, options?: any) {
            return InvitationApiFp(configuration).sendInvite(organizationId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {BasicInvitationRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInvite_1(organizationId: string, model?: BasicInvitationRequest, options?: any) {
            return InvitationApiFp(configuration).sendInvite_1(organizationId, model, options)(fetch, basePath);
        },
    };
};

/**
 * InvitationApi - interface
 * @export
 * @interface InvitationApi
 */
export interface InvitationApiInterface {
    /**
     * 
     * @summary Accepts the given invitation
     * @param {string} invitationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApiInterface
     */
    acceptInvite(invitationId: string, options?: any): Promise<OrganizationMemberModel>;

    /**
     * 
     * @summary Accepts the given invitation
     * @param {string} invitationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApiInterface
     */
    declineInvite(invitationId: string, options?: any): Promise<InvitationModel>;

    /**
     * 
     * @summary Gets all the user's pending invitations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApiInterface
     */
    getInvitations(options?: any): Promise<Array<InvitationModel>>;

    /**
     * 
     * @summary Revokes an invite that was already created
     * @param {string} invitationId The id of the invitation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApiInterface
     */
    revokeInvite(invitationId: string, options?: any): Promise<InvitationModel>;

    /**
     * 
     * @summary Sends an invitation for the given organization
     * @param {string} organizationId 
     * @param {NewInvitationRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApiInterface
     */
    sendInvite(organizationId: string, model?: NewInvitationRequest, options?: any): Promise<InvitationModel>;

    /**
     * 
     * @param {string} organizationId 
     * @param {BasicInvitationRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApiInterface
     */
    sendInvite_1(organizationId: string, model?: BasicInvitationRequest, options?: any): Promise<InvitationModel>;

}

/**
 * InvitationApi - object-oriented interface
 * @export
 * @class InvitationApi
 * @extends {BaseAPI}
 */
export class InvitationApi extends BaseAPI implements InvitationApiInterface {
    /**
     * 
     * @summary Accepts the given invitation
     * @param {string} invitationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public acceptInvite(invitationId: string, options?: any) {
        return InvitationApiFp(this.configuration).acceptInvite(invitationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Accepts the given invitation
     * @param {string} invitationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public declineInvite(invitationId: string, options?: any) {
        return InvitationApiFp(this.configuration).declineInvite(invitationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets all the user's pending invitations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public getInvitations(options?: any) {
        return InvitationApiFp(this.configuration).getInvitations(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Revokes an invite that was already created
     * @param {string} invitationId The id of the invitation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public revokeInvite(invitationId: string, options?: any) {
        return InvitationApiFp(this.configuration).revokeInvite(invitationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Sends an invitation for the given organization
     * @param {string} organizationId 
     * @param {NewInvitationRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public sendInvite(organizationId: string, model?: NewInvitationRequest, options?: any) {
        return InvitationApiFp(this.configuration).sendInvite(organizationId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} organizationId 
     * @param {BasicInvitationRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvitationApi
     */
    public sendInvite_1(organizationId: string, model?: BasicInvitationRequest, options?: any) {
        return InvitationApiFp(this.configuration).sendInvite_1(organizationId, model, options)(this.fetch, this.basePath);
    }

}

/**
 * LanguageValidationApi - fetch parameter creator
 * @export
 */
export const LanguageValidationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [inputText] 
         * @param {string} [locale] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBestMatch(applicationId: string, inputText?: string, locale?: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling findBestMatch.');
            }
            const localVarPath = `/api/LanguageValidation/{applicationId}/BestMatch`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inputText || {}) : (inputText || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [inputText] 
         * @param {string} [locale] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatches(applicationId: string, inputText?: string, locale?: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getMatches.');
            }
            const localVarPath = `/api/LanguageValidation/{applicationId}/Matches`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(inputText || {}) : (inputText || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LanguageValidationApi - functional programming interface
 * @export
 */
export const LanguageValidationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [inputText] 
         * @param {string} [locale] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBestMatch(applicationId: string, inputText?: string, locale?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessedLanguage> {
            const localVarFetchArgs = LanguageValidationApiFetchParamCreator(configuration).findBestMatch(applicationId, inputText, locale, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [inputText] 
         * @param {string} [locale] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatches(applicationId: string, inputText?: string, locale?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProcessedLanguage>> {
            const localVarFetchArgs = LanguageValidationApiFetchParamCreator(configuration).getMatches(applicationId, inputText, locale, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LanguageValidationApi - factory interface
 * @export
 */
export const LanguageValidationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [inputText] 
         * @param {string} [locale] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findBestMatch(applicationId: string, inputText?: string, locale?: string, options?: any) {
            return LanguageValidationApiFp(configuration).findBestMatch(applicationId, inputText, locale, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [inputText] 
         * @param {string} [locale] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMatches(applicationId: string, inputText?: string, locale?: string, options?: any) {
            return LanguageValidationApiFp(configuration).getMatches(applicationId, inputText, locale, options)(fetch, basePath);
        },
    };
};

/**
 * LanguageValidationApi - interface
 * @export
 * @interface LanguageValidationApi
 */
export interface LanguageValidationApiInterface {
    /**
     * 
     * @param {string} applicationId 
     * @param {string} [inputText] 
     * @param {string} [locale] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageValidationApiInterface
     */
    findBestMatch(applicationId: string, inputText?: string, locale?: string, options?: any): Promise<ProcessedLanguage>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} [inputText] 
     * @param {string} [locale] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageValidationApiInterface
     */
    getMatches(applicationId: string, inputText?: string, locale?: string, options?: any): Promise<Array<ProcessedLanguage>>;

}

/**
 * LanguageValidationApi - object-oriented interface
 * @export
 * @class LanguageValidationApi
 * @extends {BaseAPI}
 */
export class LanguageValidationApi extends BaseAPI implements LanguageValidationApiInterface {
    /**
     * 
     * @param {string} applicationId 
     * @param {string} [inputText] 
     * @param {string} [locale] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageValidationApi
     */
    public findBestMatch(applicationId: string, inputText?: string, locale?: string, options?: any) {
        return LanguageValidationApiFp(this.configuration).findBestMatch(applicationId, inputText, locale, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} [inputText] 
     * @param {string} [locale] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LanguageValidationApi
     */
    public getMatches(applicationId: string, inputText?: string, locale?: string, options?: any) {
        return LanguageValidationApiFp(this.configuration).getMatches(applicationId, inputText, locale, options)(this.fetch, this.basePath);
    }

}

/**
 * LatestMessageApi - fetch parameter creator
 * @export
 */
export const LatestMessageApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds an audio file to the given response
         * @param {string} latestMessageResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFile(latestMessageResponseId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'latestMessageResponseId' is not null or undefined
            if (latestMessageResponseId === null || latestMessageResponseId === undefined) {
                throw new RequiredError('latestMessageResponseId','Required parameter latestMessageResponseId was null or undefined when calling addAudioFile.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addAudioFile.');
            }
            const localVarPath = `/api/LatestMessage/{latestMessageResponseId}/addAudioFile/{mediaItemId}`
                .replace(`{${"latestMessageResponseId"}}`, encodeURIComponent(String(latestMessageResponseId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a large image to the given response
         * @param {string} latestMessageResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(latestMessageResponseId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'latestMessageResponseId' is not null or undefined
            if (latestMessageResponseId === null || latestMessageResponseId === undefined) {
                throw new RequiredError('latestMessageResponseId','Required parameter latestMessageResponseId was null or undefined when calling addLargeImage.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addLargeImage.');
            }
            const localVarPath = `/api/LatestMessage/{latestMessageResponseId}/addLargeImage/{mediaItemId}`
                .replace(`{${"latestMessageResponseId"}}`, encodeURIComponent(String(latestMessageResponseId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a small image item to the given response
         * @param {string} latestMessageResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(latestMessageResponseId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'latestMessageResponseId' is not null or undefined
            if (latestMessageResponseId === null || latestMessageResponseId === undefined) {
                throw new RequiredError('latestMessageResponseId','Required parameter latestMessageResponseId was null or undefined when calling addSmallImage.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addSmallImage.');
            }
            const localVarPath = `/api/LatestMessage/{latestMessageResponseId}/addSmallImage/{mediaItemId}`
                .replace(`{${"latestMessageResponseId"}}`, encodeURIComponent(String(latestMessageResponseId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a video file to the given response
         * @param {string} latestMessageResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(latestMessageResponseId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'latestMessageResponseId' is not null or undefined
            if (latestMessageResponseId === null || latestMessageResponseId === undefined) {
                throw new RequiredError('latestMessageResponseId','Required parameter latestMessageResponseId was null or undefined when calling addVideoFile.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addVideoFile.');
            }
            const localVarPath = `/api/LatestMessage/{latestMessageResponseId}/addVideoFile/{mediaItemId}`
                .replace(`{${"latestMessageResponseId"}}`, encodeURIComponent(String(latestMessageResponseId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} latestMessageId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(latestMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'latestMessageId' is not null or undefined
            if (latestMessageId === null || latestMessageId === undefined) {
                throw new RequiredError('latestMessageId','Required parameter latestMessageId was null or undefined when calling addWebhook.');
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId','Required parameter webhookId was null or undefined when calling addWebhook.');
            }
            const localVarPath = `/api/LatestMessage/{latestMessageId}/webhooks/{webhookId}`
                .replace(`{${"latestMessageId"}}`, encodeURIComponent(String(latestMessageId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} latestMessageId 
         * @param {BulkUpdateLatestMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateLatestMessage(latestMessageId: string, model?: BulkUpdateLatestMessageRequest, options: any = {}): FetchArgs {
            // verify required parameter 'latestMessageId' is not null or undefined
            if (latestMessageId === null || latestMessageId === undefined) {
                throw new RequiredError('latestMessageId','Required parameter latestMessageId was null or undefined when calling bulkUpdateLatestMessage.');
            }
            const localVarPath = `/api/LatestMessage/{latestMessageId}/bulkUpdate`
                .replace(`{${"latestMessageId"}}`, encodeURIComponent(String(latestMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkUpdateLatestMessageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} latestMessageId 
         * @param {BulkUpdateLatestMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateLatestMessageStub(latestMessageId: string, model?: BulkUpdateLatestMessageStubRequest, options: any = {}): FetchArgs {
            // verify required parameter 'latestMessageId' is not null or undefined
            if (latestMessageId === null || latestMessageId === undefined) {
                throw new RequiredError('latestMessageId','Required parameter latestMessageId was null or undefined when calling bulkUpdateLatestMessageStub.');
            }
            const localVarPath = `/api/LatestMessage/{latestMessageId}/bulkUpdate/stub`
                .replace(`{${"latestMessageId"}}`, encodeURIComponent(String(latestMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkUpdateLatestMessageStubRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} latestMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(latestMessageId: string, options: any = {}): FetchArgs {
            // verify required parameter 'latestMessageId' is not null or undefined
            if (latestMessageId === null || latestMessageId === undefined) {
                throw new RequiredError('latestMessageId','Required parameter latestMessageId was null or undefined when calling copyContentItem.');
            }
            const localVarPath = `/api/LatestMessage/{latestMessageId}/copy`
                .replace(`{${"latestMessageId"}}`, encodeURIComponent(String(latestMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {LatestMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: LatestMessageModel, options: any = {}): FetchArgs {
            const localVarPath = `/api/LatestMessage/full`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LatestMessageModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new latest message entity
         * @param {NewLatestMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLatestMessage(model?: NewLatestMessageRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/LatestMessage`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewLatestMessageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new latest message entity
         * @param {NewLatestMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLatestMessageStub(model?: NewLatestMessageStubRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/LatestMessage/stub`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewLatestMessageStubRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new response varation for the given message
         * @param {string} latestMessageId 
         * @param {NewLatestMessageResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResponse(latestMessageId: string, model?: NewLatestMessageResponseRequest, options: any = {}): FetchArgs {
            // verify required parameter 'latestMessageId' is not null or undefined
            if (latestMessageId === null || latestMessageId === undefined) {
                throw new RequiredError('latestMessageId','Required parameter latestMessageId was null or undefined when calling createResponse.');
            }
            const localVarPath = `/api/LatestMessage/{latestMessageId}/response`
                .replace(`{${"latestMessageId"}}`, encodeURIComponent(String(latestMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewLatestMessageResponseRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling createUserDefinedParameter.');
            }
            const localVarPath = `/api/LatestMessage/webhook/{instanceWebhookId}/userParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDefinedWebhookParameterCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the given latest message
         * @param {string} latestMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLatestMessage(latestMessageId: string, options: any = {}): FetchArgs {
            // verify required parameter 'latestMessageId' is not null or undefined
            if (latestMessageId === null || latestMessageId === undefined) {
                throw new RequiredError('latestMessageId','Required parameter latestMessageId was null or undefined when calling deleteLatestMessage.');
            }
            const localVarPath = `/api/LatestMessage/{latestMessageId}`
                .replace(`{${"latestMessageId"}}`, encodeURIComponent(String(latestMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes the given response
         * @param {string} latestMessageResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResponse(latestMessageResponseId: string, options: any = {}): FetchArgs {
            // verify required parameter 'latestMessageResponseId' is not null or undefined
            if (latestMessageResponseId === null || latestMessageResponseId === undefined) {
                throw new RequiredError('latestMessageResponseId','Required parameter latestMessageResponseId was null or undefined when calling deleteResponse.');
            }
            const localVarPath = `/api/LatestMessage/response/{latestMessageResponseId}`
                .replace(`{${"latestMessageResponseId"}}`, encodeURIComponent(String(latestMessageResponseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling findFullById.');
            }
            const localVarPath = `/api/LatestMessage/full/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling getByApplicationFeature.');
            }
            const localVarPath = `/api/LatestMessage/byFeature/{applicationFeatureId}`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} latestMessageResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaItemsForLatestMessage(latestMessageResponseId: string, options: any = {}): FetchArgs {
            // verify required parameter 'latestMessageResponseId' is not null or undefined
            if (latestMessageResponseId === null || latestMessageResponseId === undefined) {
                throw new RequiredError('latestMessageResponseId','Required parameter latestMessageResponseId was null or undefined when calling getMediaItemsForLatestMessage.');
            }
            const localVarPath = `/api/LatestMessage/response/{latestMessageResponseId}/media`
                .replace(`{${"latestMessageResponseId"}}`, encodeURIComponent(String(latestMessageResponseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the latest messages content for the given application  regardless of module
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesForApplication(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getMessagesForApplication.');
            }
            const localVarPath = `/api/LatestMessage/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the latest messages for the given application module
         * @param {string} applicationModuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesForModule(applicationModuleId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationModuleId' is not null or undefined
            if (applicationModuleId === null || applicationModuleId === undefined) {
                throw new RequiredError('applicationModuleId','Required parameter applicationModuleId was null or undefined when calling getMessagesForModule.');
            }
            const localVarPath = `/api/LatestMessage/module/{applicationModuleId}`
                .replace(`{${"applicationModuleId"}}`, encodeURIComponent(String(applicationModuleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} latestMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(latestMessageId: string, options: any = {}): FetchArgs {
            // verify required parameter 'latestMessageId' is not null or undefined
            if (latestMessageId === null || latestMessageId === undefined) {
                throw new RequiredError('latestMessageId','Required parameter latestMessageId was null or undefined when calling getWebhooks.');
            }
            const localVarPath = `/api/LatestMessage/{latestMessageId}/webhooks`
                .replace(`{${"latestMessageId"}}`, encodeURIComponent(String(latestMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'contentItemId' is not null or undefined
            if (contentItemId === null || contentItemId === undefined) {
                throw new RequiredError('contentItemId','Required parameter contentItemId was null or undefined when calling moveContentItemToApplicationFeature.');
            }
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling moveContentItemToApplicationFeature.');
            }
            const localVarPath = `/api/LatestMessage/{contentItemId}/MoveToFeature/{applicationFeatureId}`
                .replace(`{${"contentItemId"}}`, encodeURIComponent(String(contentItemId)))
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling removeUserDefinedParameter.');
            }
            // verify required parameter 'parameterName' is not null or undefined
            if (parameterName === null || parameterName === undefined) {
                throw new RequiredError('parameterName','Required parameter parameterName was null or undefined when calling removeUserDefinedParameter.');
            }
            const localVarPath = `/api/LatestMessage/webhook/{instanceWebhookId}/userParameters/{parameterName}`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)))
                .replace(`{${"parameterName"}}`, encodeURIComponent(String(parameterName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} latestMessageWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(latestMessageWebhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'latestMessageWebhookId' is not null or undefined
            if (latestMessageWebhookId === null || latestMessageWebhookId === undefined) {
                throw new RequiredError('latestMessageWebhookId','Required parameter latestMessageWebhookId was null or undefined when calling removeWebhook.');
            }
            const localVarPath = `/api/LatestMessage/webhook/{latestMessageWebhookId}`
                .replace(`{${"latestMessageWebhookId"}}`, encodeURIComponent(String(latestMessageWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggles the given message as live or not
         * @param {string} latestMessageId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleLive(latestMessageId: string, model?: ToggleLiveRequest, options: any = {}): FetchArgs {
            // verify required parameter 'latestMessageId' is not null or undefined
            if (latestMessageId === null || latestMessageId === undefined) {
                throw new RequiredError('latestMessageId','Required parameter latestMessageId was null or undefined when calling toggleLive.');
            }
            const localVarPath = `/api/LatestMessage/{latestMessageId}/isLive`
                .replace(`{${"latestMessageId"}}`, encodeURIComponent(String(latestMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ToggleLiveRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} latestMessageId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(latestMessageId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'latestMessageId' is not null or undefined
            if (latestMessageId === null || latestMessageId === undefined) {
                throw new RequiredError('latestMessageId','Required parameter latestMessageId was null or undefined when calling updateAttachedWebhook.');
            }
            // verify required parameter 'webhookInstanceId' is not null or undefined
            if (webhookInstanceId === null || webhookInstanceId === undefined) {
                throw new RequiredError('webhookInstanceId','Required parameter webhookInstanceId was null or undefined when calling updateAttachedWebhook.');
            }
            const localVarPath = `/api/LatestMessage/{latestMessageId}/webhooks/{webhookInstanceId}`
                .replace(`{${"latestMessageId"}}`, encodeURIComponent(String(latestMessageId)))
                .replace(`{${"webhookInstanceId"}}`, encodeURIComponent(String(webhookInstanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {LatestMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: LatestMessageModel, options: any = {}): FetchArgs {
            // verify required parameter 'contentItemId' is not null or undefined
            if (contentItemId === null || contentItemId === undefined) {
                throw new RequiredError('contentItemId','Required parameter contentItemId was null or undefined when calling updateFullContentItem.');
            }
            const localVarPath = `/api/LatestMessage/{contentItemId}/full`
                .replace(`{${"contentItemId"}}`, encodeURIComponent(String(contentItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LatestMessageModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the latest message with the given fields  If you send null or no value for fields, they won't be updated
         * @param {string} latestMessageId 
         * @param {UpdateLatestMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessage(latestMessageId: string, model?: UpdateLatestMessageRequest, options: any = {}): FetchArgs {
            // verify required parameter 'latestMessageId' is not null or undefined
            if (latestMessageId === null || latestMessageId === undefined) {
                throw new RequiredError('latestMessageId','Required parameter latestMessageId was null or undefined when calling updateMessage.');
            }
            const localVarPath = `/api/LatestMessage/{latestMessageId}`
                .replace(`{${"latestMessageId"}}`, encodeURIComponent(String(latestMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateLatestMessageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the given response
         * @param {string} latestMessageResponseId 
         * @param {UpdateLatestMessageResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResponse(latestMessageResponseId: string, model?: UpdateLatestMessageResponseRequest, options: any = {}): FetchArgs {
            // verify required parameter 'latestMessageResponseId' is not null or undefined
            if (latestMessageResponseId === null || latestMessageResponseId === undefined) {
                throw new RequiredError('latestMessageResponseId','Required parameter latestMessageResponseId was null or undefined when calling updateResponse.');
            }
            const localVarPath = `/api/LatestMessage/response/{latestMessageResponseId}`
                .replace(`{${"latestMessageResponseId"}}`, encodeURIComponent(String(latestMessageResponseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateLatestMessageResponseRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateUserDefinedParameter.');
            }
            const localVarPath = `/api/LatestMessage/webhook/{instanceWebhookId}/userParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDefinedWebhookParameterUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateWebhookParameter.');
            }
            const localVarPath = `/api/LatestMessage/webhook/{instanceWebhookId}/webhookParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParameterUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LatestMessageApi - functional programming interface
 * @export
 */
export const LatestMessageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds an audio file to the given response
         * @param {string} latestMessageResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFile(latestMessageResponseId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LatestMessageResponseModel> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).addAudioFile(latestMessageResponseId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a large image to the given response
         * @param {string} latestMessageResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(latestMessageResponseId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LatestMessageResponseModel> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).addLargeImage(latestMessageResponseId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a small image item to the given response
         * @param {string} latestMessageResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(latestMessageResponseId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LatestMessageResponseModel> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).addSmallImage(latestMessageResponseId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a video file to the given response
         * @param {string} latestMessageResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(latestMessageResponseId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LatestMessageResponseModel> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).addVideoFile(latestMessageResponseId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} latestMessageId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(latestMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LatestMessageWebhookModel> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).addWebhook(latestMessageId, webhookId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} latestMessageId 
         * @param {BulkUpdateLatestMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateLatestMessage(latestMessageId: string, model?: BulkUpdateLatestMessageRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LatestMessageModel> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).bulkUpdateLatestMessage(latestMessageId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} latestMessageId 
         * @param {BulkUpdateLatestMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateLatestMessageStub(latestMessageId: string, model?: BulkUpdateLatestMessageStubRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LatestMessageModel> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).bulkUpdateLatestMessageStub(latestMessageId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} latestMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(latestMessageId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LatestMessageModel> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).copyContentItem(latestMessageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {LatestMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: LatestMessageModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LatestMessageModel> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).createFullContentItem(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new latest message entity
         * @param {NewLatestMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLatestMessage(model?: NewLatestMessageRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LatestMessageModel> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).createLatestMessage(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new latest message entity
         * @param {NewLatestMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLatestMessageStub(model?: NewLatestMessageStubRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LatestMessageModel> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).createLatestMessageStub(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new response varation for the given message
         * @param {string} latestMessageId 
         * @param {NewLatestMessageResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResponse(latestMessageId: string, model?: NewLatestMessageResponseRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LatestMessageResponseModel> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).createResponse(latestMessageId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).createUserDefinedParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete the given latest message
         * @param {string} latestMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLatestMessage(latestMessageId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LatestMessageModel> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).deleteLatestMessage(latestMessageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes the given response
         * @param {string} latestMessageResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResponse(latestMessageResponseId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LatestMessageResponseModel> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).deleteResponse(latestMessageResponseId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LatestMessageModel> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).findFullById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LatestMessageModel>> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).getByApplicationFeature(applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} latestMessageResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaItemsForLatestMessage(latestMessageResponseId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MediaItemModel>> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).getMediaItemsForLatestMessage(latestMessageResponseId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the latest messages content for the given application  regardless of module
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesForApplication(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LatestMessageModel>> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).getMessagesForApplication(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the latest messages for the given application module
         * @param {string} applicationModuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesForModule(applicationModuleId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LatestMessageModel>> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).getMessagesForModule(applicationModuleId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} latestMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(latestMessageId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LatestMessageWebhookModel>> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).getWebhooks(latestMessageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LatestMessageModel> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} latestMessageWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(latestMessageWebhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LatestMessageWebhookModel> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).removeWebhook(latestMessageWebhookId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Toggles the given message as live or not
         * @param {string} latestMessageId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleLive(latestMessageId: string, model?: ToggleLiveRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LatestMessageModel> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).toggleLive(latestMessageId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} latestMessageId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(latestMessageId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LatestMessageWebhookModel> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).updateAttachedWebhook(latestMessageId, webhookInstanceId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {LatestMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: LatestMessageModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LatestMessageModel> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).updateFullContentItem(contentItemId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the latest message with the given fields  If you send null or no value for fields, they won't be updated
         * @param {string} latestMessageId 
         * @param {UpdateLatestMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessage(latestMessageId: string, model?: UpdateLatestMessageRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LatestMessageModel> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).updateMessage(latestMessageId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the given response
         * @param {string} latestMessageResponseId 
         * @param {UpdateLatestMessageResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResponse(latestMessageResponseId: string, model?: UpdateLatestMessageResponseRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LatestMessageResponseModel> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).updateResponse(latestMessageResponseId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).updateUserDefinedParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = LatestMessageApiFetchParamCreator(configuration).updateWebhookParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LatestMessageApi - factory interface
 * @export
 */
export const LatestMessageApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Adds an audio file to the given response
         * @param {string} latestMessageResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFile(latestMessageResponseId: string, mediaItemId: string, options?: any) {
            return LatestMessageApiFp(configuration).addAudioFile(latestMessageResponseId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a large image to the given response
         * @param {string} latestMessageResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(latestMessageResponseId: string, mediaItemId: string, options?: any) {
            return LatestMessageApiFp(configuration).addLargeImage(latestMessageResponseId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a small image item to the given response
         * @param {string} latestMessageResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(latestMessageResponseId: string, mediaItemId: string, options?: any) {
            return LatestMessageApiFp(configuration).addSmallImage(latestMessageResponseId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a video file to the given response
         * @param {string} latestMessageResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(latestMessageResponseId: string, mediaItemId: string, options?: any) {
            return LatestMessageApiFp(configuration).addVideoFile(latestMessageResponseId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} latestMessageId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(latestMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
            return LatestMessageApiFp(configuration).addWebhook(latestMessageId, webhookId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} latestMessageId 
         * @param {BulkUpdateLatestMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateLatestMessage(latestMessageId: string, model?: BulkUpdateLatestMessageRequest, options?: any) {
            return LatestMessageApiFp(configuration).bulkUpdateLatestMessage(latestMessageId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} latestMessageId 
         * @param {BulkUpdateLatestMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateLatestMessageStub(latestMessageId: string, model?: BulkUpdateLatestMessageStubRequest, options?: any) {
            return LatestMessageApiFp(configuration).bulkUpdateLatestMessageStub(latestMessageId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} latestMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(latestMessageId: string, options?: any) {
            return LatestMessageApiFp(configuration).copyContentItem(latestMessageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {LatestMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: LatestMessageModel, options?: any) {
            return LatestMessageApiFp(configuration).createFullContentItem(model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new latest message entity
         * @param {NewLatestMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLatestMessage(model?: NewLatestMessageRequest, options?: any) {
            return LatestMessageApiFp(configuration).createLatestMessage(model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new latest message entity
         * @param {NewLatestMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLatestMessageStub(model?: NewLatestMessageStubRequest, options?: any) {
            return LatestMessageApiFp(configuration).createLatestMessageStub(model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new response varation for the given message
         * @param {string} latestMessageId 
         * @param {NewLatestMessageResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResponse(latestMessageId: string, model?: NewLatestMessageResponseRequest, options?: any) {
            return LatestMessageApiFp(configuration).createResponse(latestMessageId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any) {
            return LatestMessageApiFp(configuration).createUserDefinedParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the given latest message
         * @param {string} latestMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLatestMessage(latestMessageId: string, options?: any) {
            return LatestMessageApiFp(configuration).deleteLatestMessage(latestMessageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes the given response
         * @param {string} latestMessageResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResponse(latestMessageResponseId: string, options?: any) {
            return LatestMessageApiFp(configuration).deleteResponse(latestMessageResponseId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options?: any) {
            return LatestMessageApiFp(configuration).findFullById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options?: any) {
            return LatestMessageApiFp(configuration).getByApplicationFeature(applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} latestMessageResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaItemsForLatestMessage(latestMessageResponseId: string, options?: any) {
            return LatestMessageApiFp(configuration).getMediaItemsForLatestMessage(latestMessageResponseId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the latest messages content for the given application  regardless of module
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesForApplication(applicationId: string, options?: any) {
            return LatestMessageApiFp(configuration).getMessagesForApplication(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the latest messages for the given application module
         * @param {string} applicationModuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesForModule(applicationModuleId: string, options?: any) {
            return LatestMessageApiFp(configuration).getMessagesForModule(applicationModuleId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} latestMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(latestMessageId: string, options?: any) {
            return LatestMessageApiFp(configuration).getWebhooks(latestMessageId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any) {
            return LatestMessageApiFp(configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any) {
            return LatestMessageApiFp(configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} latestMessageWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(latestMessageWebhookId: string, options?: any) {
            return LatestMessageApiFp(configuration).removeWebhook(latestMessageWebhookId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Toggles the given message as live or not
         * @param {string} latestMessageId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleLive(latestMessageId: string, model?: ToggleLiveRequest, options?: any) {
            return LatestMessageApiFp(configuration).toggleLive(latestMessageId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} latestMessageId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(latestMessageId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any) {
            return LatestMessageApiFp(configuration).updateAttachedWebhook(latestMessageId, webhookInstanceId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {LatestMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: LatestMessageModel, options?: any) {
            return LatestMessageApiFp(configuration).updateFullContentItem(contentItemId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the latest message with the given fields  If you send null or no value for fields, they won't be updated
         * @param {string} latestMessageId 
         * @param {UpdateLatestMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessage(latestMessageId: string, model?: UpdateLatestMessageRequest, options?: any) {
            return LatestMessageApiFp(configuration).updateMessage(latestMessageId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the given response
         * @param {string} latestMessageResponseId 
         * @param {UpdateLatestMessageResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResponse(latestMessageResponseId: string, model?: UpdateLatestMessageResponseRequest, options?: any) {
            return LatestMessageApiFp(configuration).updateResponse(latestMessageResponseId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any) {
            return LatestMessageApiFp(configuration).updateUserDefinedParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any) {
            return LatestMessageApiFp(configuration).updateWebhookParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
    };
};

/**
 * LatestMessageApi - interface
 * @export
 * @interface LatestMessageApi
 */
export interface LatestMessageApiInterface {
    /**
     * 
     * @summary Adds an audio file to the given response
     * @param {string} latestMessageResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    addAudioFile(latestMessageResponseId: string, mediaItemId: string, options?: any): Promise<LatestMessageResponseModel>;

    /**
     * 
     * @summary Adds a large image to the given response
     * @param {string} latestMessageResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    addLargeImage(latestMessageResponseId: string, mediaItemId: string, options?: any): Promise<LatestMessageResponseModel>;

    /**
     * 
     * @summary Adds a small image item to the given response
     * @param {string} latestMessageResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    addSmallImage(latestMessageResponseId: string, mediaItemId: string, options?: any): Promise<LatestMessageResponseModel>;

    /**
     * 
     * @summary Adds a video file to the given response
     * @param {string} latestMessageResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    addVideoFile(latestMessageResponseId: string, mediaItemId: string, options?: any): Promise<LatestMessageResponseModel>;

    /**
     * 
     * @param {string} latestMessageId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    addWebhook(latestMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): Promise<LatestMessageWebhookModel>;

    /**
     * 
     * @param {string} latestMessageId 
     * @param {BulkUpdateLatestMessageRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    bulkUpdateLatestMessage(latestMessageId: string, model?: BulkUpdateLatestMessageRequest, options?: any): Promise<LatestMessageModel>;

    /**
     * 
     * @param {string} latestMessageId 
     * @param {BulkUpdateLatestMessageStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    bulkUpdateLatestMessageStub(latestMessageId: string, model?: BulkUpdateLatestMessageStubRequest, options?: any): Promise<LatestMessageModel>;

    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param {string} latestMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    copyContentItem(latestMessageId: string, options?: any): Promise<LatestMessageModel>;

    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param {LatestMessageModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    createFullContentItem(model?: LatestMessageModel, options?: any): Promise<LatestMessageModel>;

    /**
     * 
     * @summary Creates a new latest message entity
     * @param {NewLatestMessageRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    createLatestMessage(model?: NewLatestMessageRequest, options?: any): Promise<LatestMessageModel>;

    /**
     * 
     * @summary Creates a new latest message entity
     * @param {NewLatestMessageStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    createLatestMessageStub(model?: NewLatestMessageStubRequest, options?: any): Promise<LatestMessageModel>;

    /**
     * 
     * @summary Creates a new response varation for the given message
     * @param {string} latestMessageId 
     * @param {NewLatestMessageResponseRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    createResponse(latestMessageId: string, model?: NewLatestMessageResponseRequest, options?: any): Promise<LatestMessageResponseModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterCreateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @summary Delete the given latest message
     * @param {string} latestMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    deleteLatestMessage(latestMessageId: string, options?: any): Promise<LatestMessageModel>;

    /**
     * 
     * @summary Deletes the given response
     * @param {string} latestMessageResponseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    deleteResponse(latestMessageResponseId: string, options?: any): Promise<LatestMessageResponseModel>;

    /**
     * 
     * @summary Finds the full content item by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    findFullById(id: string, options?: any): Promise<LatestMessageModel>;

    /**
     * 
     * @summary Gets the content for the given application feature
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    getByApplicationFeature(applicationFeatureId: string, options?: any): Promise<Array<LatestMessageModel>>;

    /**
     * 
     * @param {string} latestMessageResponseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    getMediaItemsForLatestMessage(latestMessageResponseId: string, options?: any): Promise<Array<MediaItemModel>>;

    /**
     * 
     * @summary Gets the latest messages content for the given application  regardless of module
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    getMessagesForApplication(applicationId: string, options?: any): Promise<Array<LatestMessageModel>>;

    /**
     * 
     * @summary Gets the latest messages for the given application module
     * @param {string} applicationModuleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    getMessagesForModule(applicationModuleId: string, options?: any): Promise<Array<LatestMessageModel>>;

    /**
     * 
     * @param {string} latestMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    getWebhooks(latestMessageId: string, options?: any): Promise<Array<LatestMessageWebhookModel>>;

    /**
     * 
     * @param {string} contentItemId 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any): Promise<LatestMessageModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {string} parameterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} latestMessageWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    removeWebhook(latestMessageWebhookId: string, options?: any): Promise<LatestMessageWebhookModel>;

    /**
     * 
     * @summary Toggles the given message as live or not
     * @param {string} latestMessageId 
     * @param {ToggleLiveRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    toggleLive(latestMessageId: string, model?: ToggleLiveRequest, options?: any): Promise<LatestMessageModel>;

    /**
     * 
     * @param {string} latestMessageId 
     * @param {string} webhookInstanceId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    updateAttachedWebhook(latestMessageId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any): Promise<LatestMessageWebhookModel>;

    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param {string} contentItemId 
     * @param {LatestMessageModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    updateFullContentItem(contentItemId: string, model?: LatestMessageModel, options?: any): Promise<LatestMessageModel>;

    /**
     * 
     * @summary Updates the latest message with the given fields  If you send null or no value for fields, they won't be updated
     * @param {string} latestMessageId 
     * @param {UpdateLatestMessageRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    updateMessage(latestMessageId: string, model?: UpdateLatestMessageRequest, options?: any): Promise<LatestMessageModel>;

    /**
     * 
     * @summary Updates the given response
     * @param {string} latestMessageResponseId 
     * @param {UpdateLatestMessageResponseRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    updateResponse(latestMessageResponseId: string, model?: UpdateLatestMessageResponseRequest, options?: any): Promise<LatestMessageResponseModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {WebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApiInterface
     */
    updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any): Promise<boolean>;

}

/**
 * LatestMessageApi - object-oriented interface
 * @export
 * @class LatestMessageApi
 * @extends {BaseAPI}
 */
export class LatestMessageApi extends BaseAPI implements LatestMessageApiInterface {
    /**
     * 
     * @summary Adds an audio file to the given response
     * @param {string} latestMessageResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public addAudioFile(latestMessageResponseId: string, mediaItemId: string, options?: any) {
        return LatestMessageApiFp(this.configuration).addAudioFile(latestMessageResponseId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a large image to the given response
     * @param {string} latestMessageResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public addLargeImage(latestMessageResponseId: string, mediaItemId: string, options?: any) {
        return LatestMessageApiFp(this.configuration).addLargeImage(latestMessageResponseId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a small image item to the given response
     * @param {string} latestMessageResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public addSmallImage(latestMessageResponseId: string, mediaItemId: string, options?: any) {
        return LatestMessageApiFp(this.configuration).addSmallImage(latestMessageResponseId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a video file to the given response
     * @param {string} latestMessageResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public addVideoFile(latestMessageResponseId: string, mediaItemId: string, options?: any) {
        return LatestMessageApiFp(this.configuration).addVideoFile(latestMessageResponseId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} latestMessageId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public addWebhook(latestMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
        return LatestMessageApiFp(this.configuration).addWebhook(latestMessageId, webhookId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} latestMessageId 
     * @param {BulkUpdateLatestMessageRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public bulkUpdateLatestMessage(latestMessageId: string, model?: BulkUpdateLatestMessageRequest, options?: any) {
        return LatestMessageApiFp(this.configuration).bulkUpdateLatestMessage(latestMessageId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} latestMessageId 
     * @param {BulkUpdateLatestMessageStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public bulkUpdateLatestMessageStub(latestMessageId: string, model?: BulkUpdateLatestMessageStubRequest, options?: any) {
        return LatestMessageApiFp(this.configuration).bulkUpdateLatestMessageStub(latestMessageId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param {string} latestMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public copyContentItem(latestMessageId: string, options?: any) {
        return LatestMessageApiFp(this.configuration).copyContentItem(latestMessageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param {LatestMessageModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public createFullContentItem(model?: LatestMessageModel, options?: any) {
        return LatestMessageApiFp(this.configuration).createFullContentItem(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new latest message entity
     * @param {NewLatestMessageRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public createLatestMessage(model?: NewLatestMessageRequest, options?: any) {
        return LatestMessageApiFp(this.configuration).createLatestMessage(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new latest message entity
     * @param {NewLatestMessageStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public createLatestMessageStub(model?: NewLatestMessageStubRequest, options?: any) {
        return LatestMessageApiFp(this.configuration).createLatestMessageStub(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new response varation for the given message
     * @param {string} latestMessageId 
     * @param {NewLatestMessageResponseRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public createResponse(latestMessageId: string, model?: NewLatestMessageResponseRequest, options?: any) {
        return LatestMessageApiFp(this.configuration).createResponse(latestMessageId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterCreateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any) {
        return LatestMessageApiFp(this.configuration).createUserDefinedParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete the given latest message
     * @param {string} latestMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public deleteLatestMessage(latestMessageId: string, options?: any) {
        return LatestMessageApiFp(this.configuration).deleteLatestMessage(latestMessageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes the given response
     * @param {string} latestMessageResponseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public deleteResponse(latestMessageResponseId: string, options?: any) {
        return LatestMessageApiFp(this.configuration).deleteResponse(latestMessageResponseId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Finds the full content item by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public findFullById(id: string, options?: any) {
        return LatestMessageApiFp(this.configuration).findFullById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the content for the given application feature
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public getByApplicationFeature(applicationFeatureId: string, options?: any) {
        return LatestMessageApiFp(this.configuration).getByApplicationFeature(applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} latestMessageResponseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public getMediaItemsForLatestMessage(latestMessageResponseId: string, options?: any) {
        return LatestMessageApiFp(this.configuration).getMediaItemsForLatestMessage(latestMessageResponseId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the latest messages content for the given application  regardless of module
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public getMessagesForApplication(applicationId: string, options?: any) {
        return LatestMessageApiFp(this.configuration).getMessagesForApplication(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the latest messages for the given application module
     * @param {string} applicationModuleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public getMessagesForModule(applicationModuleId: string, options?: any) {
        return LatestMessageApiFp(this.configuration).getMessagesForModule(applicationModuleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} latestMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public getWebhooks(latestMessageId: string, options?: any) {
        return LatestMessageApiFp(this.configuration).getWebhooks(latestMessageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} contentItemId 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any) {
        return LatestMessageApiFp(this.configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {string} parameterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any) {
        return LatestMessageApiFp(this.configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} latestMessageWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public removeWebhook(latestMessageWebhookId: string, options?: any) {
        return LatestMessageApiFp(this.configuration).removeWebhook(latestMessageWebhookId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Toggles the given message as live or not
     * @param {string} latestMessageId 
     * @param {ToggleLiveRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public toggleLive(latestMessageId: string, model?: ToggleLiveRequest, options?: any) {
        return LatestMessageApiFp(this.configuration).toggleLive(latestMessageId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} latestMessageId 
     * @param {string} webhookInstanceId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public updateAttachedWebhook(latestMessageId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any) {
        return LatestMessageApiFp(this.configuration).updateAttachedWebhook(latestMessageId, webhookInstanceId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param {string} contentItemId 
     * @param {LatestMessageModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public updateFullContentItem(contentItemId: string, model?: LatestMessageModel, options?: any) {
        return LatestMessageApiFp(this.configuration).updateFullContentItem(contentItemId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the latest message with the given fields  If you send null or no value for fields, they won't be updated
     * @param {string} latestMessageId 
     * @param {UpdateLatestMessageRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public updateMessage(latestMessageId: string, model?: UpdateLatestMessageRequest, options?: any) {
        return LatestMessageApiFp(this.configuration).updateMessage(latestMessageId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the given response
     * @param {string} latestMessageResponseId 
     * @param {UpdateLatestMessageResponseRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public updateResponse(latestMessageResponseId: string, model?: UpdateLatestMessageResponseRequest, options?: any) {
        return LatestMessageApiFp(this.configuration).updateResponse(latestMessageResponseId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any) {
        return LatestMessageApiFp(this.configuration).updateUserDefinedParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {WebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LatestMessageApi
     */
    public updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any) {
        return LatestMessageApiFp(this.configuration).updateWebhookParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

}

/**
 * MediaItemApi - fetch parameter creator
 * @export
 */
export const MediaItemApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convertToSsml(mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling convertToSsml.');
            }
            const localVarPath = `/api/MediaItem/convert/ssml/{mediaItemId}`
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Uploads the file and saves the media item to the application
         * @param {string} applicationId 
         * @param {string} [name] 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMediaItem(applicationId: string, name?: string, file?: any, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling createMediaItem.');
            }
            const localVarPath = `/api/MediaItem/{applicationId}/upload`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {NewMediaItemRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMediaItem_1(applicationId: string, model?: NewMediaItemRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling createMediaItem_1.');
            }
            const localVarPath = `/api/MediaItem/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewMediaItemRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes the given media item
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMediaItem(mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling deleteMediaItem.');
            }
            const localVarPath = `/api/MediaItem/{mediaItemId}`
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes the given media item
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMediaItem(mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling disableMediaItem.');
            }
            const localVarPath = `/api/MediaItem/{mediaItemId}/disable`
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets deleted media items for the given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisabledMediaItemsForApplication(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getDisabledMediaItemsForApplication.');
            }
            const localVarPath = `/api/MediaItem/{applicationId}/disabled`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the media items for the given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaItemsForApplication(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getMediaItemsForApplication.');
            }
            const localVarPath = `/api/MediaItem/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} [name] 
         * @param {string} [fileName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUploadUrl(organizationId: string, name?: string, fileName?: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling getOrganizationUploadUrl.');
            }
            const localVarPath = `/api/MediaItem/{organizationId}/orgUploadUrl`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['Name'] = name;
            }

            if (fileName !== undefined) {
                localVarQueryParameter['FileName'] = fileName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [name] 
         * @param {string} [fileName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadUrl(applicationId: string, name?: string, fileName?: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getUploadUrl.');
            }
            const localVarPath = `/api/MediaItem/{applicationId}/uploadUrl`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['Name'] = name;
            }

            if (fileName !== undefined) {
                localVarQueryParameter['FileName'] = fileName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} mediaItemId 
         * @param {UpdateMediaItemRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaItem(mediaItemId: string, request?: UpdateMediaItemRequest, options: any = {}): FetchArgs {
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling updateMediaItem.');
            }
            const localVarPath = `/api/MediaItem/{mediaItemId}`
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateMediaItemRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaItemApi - functional programming interface
 * @export
 */
export const MediaItemApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convertToSsml(mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MediaItemModel> {
            const localVarFetchArgs = MediaItemApiFetchParamCreator(configuration).convertToSsml(mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Uploads the file and saves the media item to the application
         * @param {string} applicationId 
         * @param {string} [name] 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMediaItem(applicationId: string, name?: string, file?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MediaItemModel> {
            const localVarFetchArgs = MediaItemApiFetchParamCreator(configuration).createMediaItem(applicationId, name, file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {NewMediaItemRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMediaItem_1(applicationId: string, model?: NewMediaItemRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MediaItemModel> {
            const localVarFetchArgs = MediaItemApiFetchParamCreator(configuration).createMediaItem_1(applicationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes the given media item
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMediaItem(mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MediaItemModel> {
            const localVarFetchArgs = MediaItemApiFetchParamCreator(configuration).deleteMediaItem(mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes the given media item
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMediaItem(mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MediaItemModel> {
            const localVarFetchArgs = MediaItemApiFetchParamCreator(configuration).disableMediaItem(mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets deleted media items for the given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisabledMediaItemsForApplication(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MediaItemModel>> {
            const localVarFetchArgs = MediaItemApiFetchParamCreator(configuration).getDisabledMediaItemsForApplication(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the media items for the given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaItemsForApplication(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MediaItemModel>> {
            const localVarFetchArgs = MediaItemApiFetchParamCreator(configuration).getMediaItemsForApplication(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} [name] 
         * @param {string} [fileName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUploadUrl(organizationId: string, name?: string, fileName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = MediaItemApiFetchParamCreator(configuration).getOrganizationUploadUrl(organizationId, name, fileName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [name] 
         * @param {string} [fileName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadUrl(applicationId: string, name?: string, fileName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = MediaItemApiFetchParamCreator(configuration).getUploadUrl(applicationId, name, fileName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} mediaItemId 
         * @param {UpdateMediaItemRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaItem(mediaItemId: string, request?: UpdateMediaItemRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MediaItemModel> {
            const localVarFetchArgs = MediaItemApiFetchParamCreator(configuration).updateMediaItem(mediaItemId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MediaItemApi - factory interface
 * @export
 */
export const MediaItemApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convertToSsml(mediaItemId: string, options?: any) {
            return MediaItemApiFp(configuration).convertToSsml(mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Uploads the file and saves the media item to the application
         * @param {string} applicationId 
         * @param {string} [name] 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMediaItem(applicationId: string, name?: string, file?: any, options?: any) {
            return MediaItemApiFp(configuration).createMediaItem(applicationId, name, file, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {NewMediaItemRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMediaItem_1(applicationId: string, model?: NewMediaItemRequest, options?: any) {
            return MediaItemApiFp(configuration).createMediaItem_1(applicationId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes the given media item
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMediaItem(mediaItemId: string, options?: any) {
            return MediaItemApiFp(configuration).deleteMediaItem(mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes the given media item
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableMediaItem(mediaItemId: string, options?: any) {
            return MediaItemApiFp(configuration).disableMediaItem(mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets deleted media items for the given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDisabledMediaItemsForApplication(applicationId: string, options?: any) {
            return MediaItemApiFp(configuration).getDisabledMediaItemsForApplication(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the media items for the given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMediaItemsForApplication(applicationId: string, options?: any) {
            return MediaItemApiFp(configuration).getMediaItemsForApplication(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {string} [name] 
         * @param {string} [fileName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationUploadUrl(organizationId: string, name?: string, fileName?: string, options?: any) {
            return MediaItemApiFp(configuration).getOrganizationUploadUrl(organizationId, name, fileName, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {string} [name] 
         * @param {string} [fileName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadUrl(applicationId: string, name?: string, fileName?: string, options?: any) {
            return MediaItemApiFp(configuration).getUploadUrl(applicationId, name, fileName, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} mediaItemId 
         * @param {UpdateMediaItemRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaItem(mediaItemId: string, request?: UpdateMediaItemRequest, options?: any) {
            return MediaItemApiFp(configuration).updateMediaItem(mediaItemId, request, options)(fetch, basePath);
        },
    };
};

/**
 * MediaItemApi - interface
 * @export
 * @interface MediaItemApi
 */
export interface MediaItemApiInterface {
    /**
     * 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaItemApiInterface
     */
    convertToSsml(mediaItemId: string, options?: any): Promise<MediaItemModel>;

    /**
     * 
     * @summary Uploads the file and saves the media item to the application
     * @param {string} applicationId 
     * @param {string} [name] 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaItemApiInterface
     */
    createMediaItem(applicationId: string, name?: string, file?: any, options?: any): Promise<MediaItemModel>;

    /**
     * 
     * @param {string} applicationId 
     * @param {NewMediaItemRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaItemApiInterface
     */
    createMediaItem_1(applicationId: string, model?: NewMediaItemRequest, options?: any): Promise<MediaItemModel>;

    /**
     * 
     * @summary Deletes the given media item
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaItemApiInterface
     */
    deleteMediaItem(mediaItemId: string, options?: any): Promise<MediaItemModel>;

    /**
     * 
     * @summary Deletes the given media item
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaItemApiInterface
     */
    disableMediaItem(mediaItemId: string, options?: any): Promise<MediaItemModel>;

    /**
     * 
     * @summary Gets deleted media items for the given application
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaItemApiInterface
     */
    getDisabledMediaItemsForApplication(applicationId: string, options?: any): Promise<Array<MediaItemModel>>;

    /**
     * 
     * @summary Gets the media items for the given application
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaItemApiInterface
     */
    getMediaItemsForApplication(applicationId: string, options?: any): Promise<Array<MediaItemModel>>;

    /**
     * 
     * @param {string} organizationId 
     * @param {string} [name] 
     * @param {string} [fileName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaItemApiInterface
     */
    getOrganizationUploadUrl(organizationId: string, name?: string, fileName?: string, options?: any): Promise<string>;

    /**
     * 
     * @param {string} applicationId 
     * @param {string} [name] 
     * @param {string} [fileName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaItemApiInterface
     */
    getUploadUrl(applicationId: string, name?: string, fileName?: string, options?: any): Promise<string>;

    /**
     * 
     * @param {string} mediaItemId 
     * @param {UpdateMediaItemRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaItemApiInterface
     */
    updateMediaItem(mediaItemId: string, request?: UpdateMediaItemRequest, options?: any): Promise<MediaItemModel>;

}

/**
 * MediaItemApi - object-oriented interface
 * @export
 * @class MediaItemApi
 * @extends {BaseAPI}
 */
export class MediaItemApi extends BaseAPI implements MediaItemApiInterface {
    /**
     * 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaItemApi
     */
    public convertToSsml(mediaItemId: string, options?: any) {
        return MediaItemApiFp(this.configuration).convertToSsml(mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Uploads the file and saves the media item to the application
     * @param {string} applicationId 
     * @param {string} [name] 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaItemApi
     */
    public createMediaItem(applicationId: string, name?: string, file?: any, options?: any) {
        return MediaItemApiFp(this.configuration).createMediaItem(applicationId, name, file, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {NewMediaItemRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaItemApi
     */
    public createMediaItem_1(applicationId: string, model?: NewMediaItemRequest, options?: any) {
        return MediaItemApiFp(this.configuration).createMediaItem_1(applicationId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes the given media item
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaItemApi
     */
    public deleteMediaItem(mediaItemId: string, options?: any) {
        return MediaItemApiFp(this.configuration).deleteMediaItem(mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes the given media item
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaItemApi
     */
    public disableMediaItem(mediaItemId: string, options?: any) {
        return MediaItemApiFp(this.configuration).disableMediaItem(mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets deleted media items for the given application
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaItemApi
     */
    public getDisabledMediaItemsForApplication(applicationId: string, options?: any) {
        return MediaItemApiFp(this.configuration).getDisabledMediaItemsForApplication(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the media items for the given application
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaItemApi
     */
    public getMediaItemsForApplication(applicationId: string, options?: any) {
        return MediaItemApiFp(this.configuration).getMediaItemsForApplication(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} organizationId 
     * @param {string} [name] 
     * @param {string} [fileName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaItemApi
     */
    public getOrganizationUploadUrl(organizationId: string, name?: string, fileName?: string, options?: any) {
        return MediaItemApiFp(this.configuration).getOrganizationUploadUrl(organizationId, name, fileName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {string} [name] 
     * @param {string} [fileName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaItemApi
     */
    public getUploadUrl(applicationId: string, name?: string, fileName?: string, options?: any) {
        return MediaItemApiFp(this.configuration).getUploadUrl(applicationId, name, fileName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} mediaItemId 
     * @param {UpdateMediaItemRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaItemApi
     */
    public updateMediaItem(mediaItemId: string, request?: UpdateMediaItemRequest, options?: any) {
        return MediaItemApiFp(this.configuration).updateMediaItem(mediaItemId, request, options)(this.fetch, this.basePath);
    }

}

/**
 * MediaResponseApi - fetch parameter creator
 * @export
 */
export const MediaResponseApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {NewMediaResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMediaResponse(model?: NewMediaResponseRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/MediaResponse`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewMediaResponseRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NewMediaResponseContainerRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMediaResponseContainer(model?: NewMediaResponseContainerRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/MediaResponse/containers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewMediaResponseContainerRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NewBulkMediaResponseContainerRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMediaResponseContainer_1(model?: NewBulkMediaResponseContainerRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/MediaResponse/containers/bulk`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewBulkMediaResponseContainerRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NewResponseTemplateTypeRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResponseTemplateType(model?: NewResponseTemplateTypeRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/MediaResponse/templateType`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewResponseTemplateTypeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} mediaResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMediaResponse(mediaResponseId: string, options: any = {}): FetchArgs {
            // verify required parameter 'mediaResponseId' is not null or undefined
            if (mediaResponseId === null || mediaResponseId === undefined) {
                throw new RequiredError('mediaResponseId','Required parameter mediaResponseId was null or undefined when calling deleteMediaResponse.');
            }
            const localVarPath = `/api/MediaResponse/{mediaResponseId}`
                .replace(`{${"mediaResponseId"}}`, encodeURIComponent(String(mediaResponseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMediaResponseContainer(containerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling deleteMediaResponseContainer.');
            }
            const localVarPath = `/api/MediaResponse/containers/{containerId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} templateId 
         * @param {string} [responseTemplateId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResponseTemplate(templateId: string, responseTemplateId?: string, options: any = {}): FetchArgs {
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId','Required parameter templateId was null or undefined when calling deleteResponseTemplate.');
            }
            const localVarPath = `/api/MediaResponse/templateType/{templateId}`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (responseTemplateId !== undefined) {
                localVarQueryParameter['responseTemplateId'] = responseTemplateId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllResponseTemplates(options: any = {}): FetchArgs {
            const localVarPath = `/api/MediaResponse/templateType`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnabledResponseTemplates(options: any = {}): FetchArgs {
            const localVarPath = `/api/MediaResponse/templateType/enabled`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResponseContainerById(containerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling getResponseContainerById.');
            }
            const localVarPath = `/api/MediaResponse/containers/{containerId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResponseContainersForApp(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getResponseContainersForApp.');
            }
            const localVarPath = `/api/MediaResponse/containers/forApp/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} responseTemplateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResponseTemplateById(responseTemplateId: string, options: any = {}): FetchArgs {
            // verify required parameter 'responseTemplateId' is not null or undefined
            if (responseTemplateId === null || responseTemplateId === undefined) {
                throw new RequiredError('responseTemplateId','Required parameter responseTemplateId was null or undefined when calling getResponseTemplateById.');
            }
            const localVarPath = `/api/MediaResponse/templateType/{responseTemplateId}`
                .replace(`{${"responseTemplateId"}}`, encodeURIComponent(String(responseTemplateId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} assistant 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResponseTemplatesByAssistant(assistant: string, options: any = {}): FetchArgs {
            // verify required parameter 'assistant' is not null or undefined
            if (assistant === null || assistant === undefined) {
                throw new RequiredError('assistant','Required parameter assistant was null or undefined when calling getResponseTemplatesByAssistant.');
            }
            const localVarPath = `/api/MediaResponse/templateType/assistant/{assistant}`
                .replace(`{${"assistant"}}`, encodeURIComponent(String(assistant)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} deviceTargetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResponseTemplatesByDeviceTarget(deviceTargetId: string, options: any = {}): FetchArgs {
            // verify required parameter 'deviceTargetId' is not null or undefined
            if (deviceTargetId === null || deviceTargetId === undefined) {
                throw new RequiredError('deviceTargetId','Required parameter deviceTargetId was null or undefined when calling getResponseTemplatesByDeviceTarget.');
            }
            const localVarPath = `/api/MediaResponse/templateType/deviceTarget/{deviceTargetId}`
                .replace(`{${"deviceTargetId"}}`, encodeURIComponent(String(deviceTargetId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} responseId 
         * @param {UpdateMediaResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaResponse(responseId: string, model?: UpdateMediaResponseRequest, options: any = {}): FetchArgs {
            // verify required parameter 'responseId' is not null or undefined
            if (responseId === null || responseId === undefined) {
                throw new RequiredError('responseId','Required parameter responseId was null or undefined when calling updateMediaResponse.');
            }
            const localVarPath = `/api/MediaResponse/{responseId}`
                .replace(`{${"responseId"}}`, encodeURIComponent(String(responseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateMediaResponseRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} containerId 
         * @param {UpdateMediaResponseContainerRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaResponseContainer(containerId: string, model?: UpdateMediaResponseContainerRequest, options: any = {}): FetchArgs {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling updateMediaResponseContainer.');
            }
            const localVarPath = `/api/MediaResponse/containers/{containerId}`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateMediaResponseContainerRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} containerId 
         * @param {UpdateBulkMediaResponseContainerRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaResponseContainer_2(containerId: string, model?: UpdateBulkMediaResponseContainerRequest, options: any = {}): FetchArgs {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling updateMediaResponseContainer_2.');
            }
            const localVarPath = `/api/MediaResponse/containers/{containerId}/bulk`
                .replace(`{${"containerId"}}`, encodeURIComponent(String(containerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateBulkMediaResponseContainerRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} templateId 
         * @param {UpdateResponseTemplateTypeRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResponseTemplateType(templateId: string, model?: UpdateResponseTemplateTypeRequest, options: any = {}): FetchArgs {
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId','Required parameter templateId was null or undefined when calling updateResponseTemplateType.');
            }
            const localVarPath = `/api/MediaResponse/templateType/{templateId}`
                .replace(`{${"templateId"}}`, encodeURIComponent(String(templateId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateResponseTemplateTypeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaResponseApi - functional programming interface
 * @export
 */
export const MediaResponseApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {NewMediaResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMediaResponse(model?: NewMediaResponseRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MediaResponseModel> {
            const localVarFetchArgs = MediaResponseApiFetchParamCreator(configuration).createMediaResponse(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {NewMediaResponseContainerRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMediaResponseContainer(model?: NewMediaResponseContainerRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MediaResponseContainerModel> {
            const localVarFetchArgs = MediaResponseApiFetchParamCreator(configuration).createMediaResponseContainer(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {NewBulkMediaResponseContainerRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMediaResponseContainer_1(model?: NewBulkMediaResponseContainerRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MediaResponseContainerModel> {
            const localVarFetchArgs = MediaResponseApiFetchParamCreator(configuration).createMediaResponseContainer_1(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {NewResponseTemplateTypeRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResponseTemplateType(model?: NewResponseTemplateTypeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseTemplateTypeModel> {
            const localVarFetchArgs = MediaResponseApiFetchParamCreator(configuration).createResponseTemplateType(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} mediaResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMediaResponse(mediaResponseId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MediaResponseModel> {
            const localVarFetchArgs = MediaResponseApiFetchParamCreator(configuration).deleteMediaResponse(mediaResponseId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMediaResponseContainer(containerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MediaResponseContainerModel> {
            const localVarFetchArgs = MediaResponseApiFetchParamCreator(configuration).deleteMediaResponseContainer(containerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} templateId 
         * @param {string} [responseTemplateId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResponseTemplate(templateId: string, responseTemplateId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseTemplateTypeModel> {
            const localVarFetchArgs = MediaResponseApiFetchParamCreator(configuration).deleteResponseTemplate(templateId, responseTemplateId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllResponseTemplates(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ResponseTemplateTypeModel>> {
            const localVarFetchArgs = MediaResponseApiFetchParamCreator(configuration).getAllResponseTemplates(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnabledResponseTemplates(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ResponseTemplateTypeModel>> {
            const localVarFetchArgs = MediaResponseApiFetchParamCreator(configuration).getEnabledResponseTemplates(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResponseContainerById(containerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MediaResponseContainerModel> {
            const localVarFetchArgs = MediaResponseApiFetchParamCreator(configuration).getResponseContainerById(containerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResponseContainersForApp(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MediaResponseContainerModel>> {
            const localVarFetchArgs = MediaResponseApiFetchParamCreator(configuration).getResponseContainersForApp(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} responseTemplateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResponseTemplateById(responseTemplateId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseTemplateTypeModel> {
            const localVarFetchArgs = MediaResponseApiFetchParamCreator(configuration).getResponseTemplateById(responseTemplateId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} assistant 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResponseTemplatesByAssistant(assistant: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ResponseTemplateTypeModel>> {
            const localVarFetchArgs = MediaResponseApiFetchParamCreator(configuration).getResponseTemplatesByAssistant(assistant, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} deviceTargetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResponseTemplatesByDeviceTarget(deviceTargetId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ResponseTemplateTypeModel>> {
            const localVarFetchArgs = MediaResponseApiFetchParamCreator(configuration).getResponseTemplatesByDeviceTarget(deviceTargetId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} responseId 
         * @param {UpdateMediaResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaResponse(responseId: string, model?: UpdateMediaResponseRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MediaResponseModel> {
            const localVarFetchArgs = MediaResponseApiFetchParamCreator(configuration).updateMediaResponse(responseId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} containerId 
         * @param {UpdateMediaResponseContainerRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaResponseContainer(containerId: string, model?: UpdateMediaResponseContainerRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MediaResponseContainerModel> {
            const localVarFetchArgs = MediaResponseApiFetchParamCreator(configuration).updateMediaResponseContainer(containerId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} containerId 
         * @param {UpdateBulkMediaResponseContainerRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaResponseContainer_2(containerId: string, model?: UpdateBulkMediaResponseContainerRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MediaResponseContainerModel> {
            const localVarFetchArgs = MediaResponseApiFetchParamCreator(configuration).updateMediaResponseContainer_2(containerId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} templateId 
         * @param {UpdateResponseTemplateTypeRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResponseTemplateType(templateId: string, model?: UpdateResponseTemplateTypeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResponseTemplateTypeModel> {
            const localVarFetchArgs = MediaResponseApiFetchParamCreator(configuration).updateResponseTemplateType(templateId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MediaResponseApi - factory interface
 * @export
 */
export const MediaResponseApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {NewMediaResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMediaResponse(model?: NewMediaResponseRequest, options?: any) {
            return MediaResponseApiFp(configuration).createMediaResponse(model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {NewMediaResponseContainerRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMediaResponseContainer(model?: NewMediaResponseContainerRequest, options?: any) {
            return MediaResponseApiFp(configuration).createMediaResponseContainer(model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {NewBulkMediaResponseContainerRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMediaResponseContainer_1(model?: NewBulkMediaResponseContainerRequest, options?: any) {
            return MediaResponseApiFp(configuration).createMediaResponseContainer_1(model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {NewResponseTemplateTypeRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResponseTemplateType(model?: NewResponseTemplateTypeRequest, options?: any) {
            return MediaResponseApiFp(configuration).createResponseTemplateType(model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} mediaResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMediaResponse(mediaResponseId: string, options?: any) {
            return MediaResponseApiFp(configuration).deleteMediaResponse(mediaResponseId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMediaResponseContainer(containerId: string, options?: any) {
            return MediaResponseApiFp(configuration).deleteMediaResponseContainer(containerId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} templateId 
         * @param {string} [responseTemplateId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResponseTemplate(templateId: string, responseTemplateId?: string, options?: any) {
            return MediaResponseApiFp(configuration).deleteResponseTemplate(templateId, responseTemplateId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllResponseTemplates(options?: any) {
            return MediaResponseApiFp(configuration).getAllResponseTemplates(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEnabledResponseTemplates(options?: any) {
            return MediaResponseApiFp(configuration).getEnabledResponseTemplates(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResponseContainerById(containerId: string, options?: any) {
            return MediaResponseApiFp(configuration).getResponseContainerById(containerId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResponseContainersForApp(applicationId: string, options?: any) {
            return MediaResponseApiFp(configuration).getResponseContainersForApp(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} responseTemplateId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResponseTemplateById(responseTemplateId: string, options?: any) {
            return MediaResponseApiFp(configuration).getResponseTemplateById(responseTemplateId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} assistant 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResponseTemplatesByAssistant(assistant: string, options?: any) {
            return MediaResponseApiFp(configuration).getResponseTemplatesByAssistant(assistant, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} deviceTargetId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getResponseTemplatesByDeviceTarget(deviceTargetId: string, options?: any) {
            return MediaResponseApiFp(configuration).getResponseTemplatesByDeviceTarget(deviceTargetId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} responseId 
         * @param {UpdateMediaResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaResponse(responseId: string, model?: UpdateMediaResponseRequest, options?: any) {
            return MediaResponseApiFp(configuration).updateMediaResponse(responseId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} containerId 
         * @param {UpdateMediaResponseContainerRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaResponseContainer(containerId: string, model?: UpdateMediaResponseContainerRequest, options?: any) {
            return MediaResponseApiFp(configuration).updateMediaResponseContainer(containerId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} containerId 
         * @param {UpdateBulkMediaResponseContainerRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMediaResponseContainer_2(containerId: string, model?: UpdateBulkMediaResponseContainerRequest, options?: any) {
            return MediaResponseApiFp(configuration).updateMediaResponseContainer_2(containerId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} templateId 
         * @param {UpdateResponseTemplateTypeRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResponseTemplateType(templateId: string, model?: UpdateResponseTemplateTypeRequest, options?: any) {
            return MediaResponseApiFp(configuration).updateResponseTemplateType(templateId, model, options)(fetch, basePath);
        },
    };
};

/**
 * MediaResponseApi - interface
 * @export
 * @interface MediaResponseApi
 */
export interface MediaResponseApiInterface {
    /**
     * 
     * @param {NewMediaResponseRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApiInterface
     */
    createMediaResponse(model?: NewMediaResponseRequest, options?: any): Promise<MediaResponseModel>;

    /**
     * 
     * @param {NewMediaResponseContainerRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApiInterface
     */
    createMediaResponseContainer(model?: NewMediaResponseContainerRequest, options?: any): Promise<MediaResponseContainerModel>;

    /**
     * 
     * @param {NewBulkMediaResponseContainerRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApiInterface
     */
    createMediaResponseContainer_1(model?: NewBulkMediaResponseContainerRequest, options?: any): Promise<MediaResponseContainerModel>;

    /**
     * 
     * @param {NewResponseTemplateTypeRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApiInterface
     */
    createResponseTemplateType(model?: NewResponseTemplateTypeRequest, options?: any): Promise<ResponseTemplateTypeModel>;

    /**
     * 
     * @param {string} mediaResponseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApiInterface
     */
    deleteMediaResponse(mediaResponseId: string, options?: any): Promise<MediaResponseModel>;

    /**
     * 
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApiInterface
     */
    deleteMediaResponseContainer(containerId: string, options?: any): Promise<MediaResponseContainerModel>;

    /**
     * 
     * @param {string} templateId 
     * @param {string} [responseTemplateId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApiInterface
     */
    deleteResponseTemplate(templateId: string, responseTemplateId?: string, options?: any): Promise<ResponseTemplateTypeModel>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApiInterface
     */
    getAllResponseTemplates(options?: any): Promise<Array<ResponseTemplateTypeModel>>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApiInterface
     */
    getEnabledResponseTemplates(options?: any): Promise<Array<ResponseTemplateTypeModel>>;

    /**
     * 
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApiInterface
     */
    getResponseContainerById(containerId: string, options?: any): Promise<MediaResponseContainerModel>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApiInterface
     */
    getResponseContainersForApp(applicationId: string, options?: any): Promise<Array<MediaResponseContainerModel>>;

    /**
     * 
     * @param {string} responseTemplateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApiInterface
     */
    getResponseTemplateById(responseTemplateId: string, options?: any): Promise<ResponseTemplateTypeModel>;

    /**
     * 
     * @param {string} assistant 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApiInterface
     */
    getResponseTemplatesByAssistant(assistant: string, options?: any): Promise<Array<ResponseTemplateTypeModel>>;

    /**
     * 
     * @param {string} deviceTargetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApiInterface
     */
    getResponseTemplatesByDeviceTarget(deviceTargetId: string, options?: any): Promise<Array<ResponseTemplateTypeModel>>;

    /**
     * 
     * @param {string} responseId 
     * @param {UpdateMediaResponseRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApiInterface
     */
    updateMediaResponse(responseId: string, model?: UpdateMediaResponseRequest, options?: any): Promise<MediaResponseModel>;

    /**
     * 
     * @param {string} containerId 
     * @param {UpdateMediaResponseContainerRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApiInterface
     */
    updateMediaResponseContainer(containerId: string, model?: UpdateMediaResponseContainerRequest, options?: any): Promise<MediaResponseContainerModel>;

    /**
     * 
     * @param {string} containerId 
     * @param {UpdateBulkMediaResponseContainerRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApiInterface
     */
    updateMediaResponseContainer_2(containerId: string, model?: UpdateBulkMediaResponseContainerRequest, options?: any): Promise<MediaResponseContainerModel>;

    /**
     * 
     * @param {string} templateId 
     * @param {UpdateResponseTemplateTypeRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApiInterface
     */
    updateResponseTemplateType(templateId: string, model?: UpdateResponseTemplateTypeRequest, options?: any): Promise<ResponseTemplateTypeModel>;

}

/**
 * MediaResponseApi - object-oriented interface
 * @export
 * @class MediaResponseApi
 * @extends {BaseAPI}
 */
export class MediaResponseApi extends BaseAPI implements MediaResponseApiInterface {
    /**
     * 
     * @param {NewMediaResponseRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApi
     */
    public createMediaResponse(model?: NewMediaResponseRequest, options?: any) {
        return MediaResponseApiFp(this.configuration).createMediaResponse(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {NewMediaResponseContainerRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApi
     */
    public createMediaResponseContainer(model?: NewMediaResponseContainerRequest, options?: any) {
        return MediaResponseApiFp(this.configuration).createMediaResponseContainer(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {NewBulkMediaResponseContainerRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApi
     */
    public createMediaResponseContainer_1(model?: NewBulkMediaResponseContainerRequest, options?: any) {
        return MediaResponseApiFp(this.configuration).createMediaResponseContainer_1(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {NewResponseTemplateTypeRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApi
     */
    public createResponseTemplateType(model?: NewResponseTemplateTypeRequest, options?: any) {
        return MediaResponseApiFp(this.configuration).createResponseTemplateType(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} mediaResponseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApi
     */
    public deleteMediaResponse(mediaResponseId: string, options?: any) {
        return MediaResponseApiFp(this.configuration).deleteMediaResponse(mediaResponseId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApi
     */
    public deleteMediaResponseContainer(containerId: string, options?: any) {
        return MediaResponseApiFp(this.configuration).deleteMediaResponseContainer(containerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} templateId 
     * @param {string} [responseTemplateId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApi
     */
    public deleteResponseTemplate(templateId: string, responseTemplateId?: string, options?: any) {
        return MediaResponseApiFp(this.configuration).deleteResponseTemplate(templateId, responseTemplateId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApi
     */
    public getAllResponseTemplates(options?: any) {
        return MediaResponseApiFp(this.configuration).getAllResponseTemplates(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApi
     */
    public getEnabledResponseTemplates(options?: any) {
        return MediaResponseApiFp(this.configuration).getEnabledResponseTemplates(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApi
     */
    public getResponseContainerById(containerId: string, options?: any) {
        return MediaResponseApiFp(this.configuration).getResponseContainerById(containerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApi
     */
    public getResponseContainersForApp(applicationId: string, options?: any) {
        return MediaResponseApiFp(this.configuration).getResponseContainersForApp(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} responseTemplateId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApi
     */
    public getResponseTemplateById(responseTemplateId: string, options?: any) {
        return MediaResponseApiFp(this.configuration).getResponseTemplateById(responseTemplateId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} assistant 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApi
     */
    public getResponseTemplatesByAssistant(assistant: string, options?: any) {
        return MediaResponseApiFp(this.configuration).getResponseTemplatesByAssistant(assistant, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} deviceTargetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApi
     */
    public getResponseTemplatesByDeviceTarget(deviceTargetId: string, options?: any) {
        return MediaResponseApiFp(this.configuration).getResponseTemplatesByDeviceTarget(deviceTargetId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} responseId 
     * @param {UpdateMediaResponseRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApi
     */
    public updateMediaResponse(responseId: string, model?: UpdateMediaResponseRequest, options?: any) {
        return MediaResponseApiFp(this.configuration).updateMediaResponse(responseId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} containerId 
     * @param {UpdateMediaResponseContainerRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApi
     */
    public updateMediaResponseContainer(containerId: string, model?: UpdateMediaResponseContainerRequest, options?: any) {
        return MediaResponseApiFp(this.configuration).updateMediaResponseContainer(containerId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} containerId 
     * @param {UpdateBulkMediaResponseContainerRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApi
     */
    public updateMediaResponseContainer_2(containerId: string, model?: UpdateBulkMediaResponseContainerRequest, options?: any) {
        return MediaResponseApiFp(this.configuration).updateMediaResponseContainer_2(containerId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} templateId 
     * @param {UpdateResponseTemplateTypeRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaResponseApi
     */
    public updateResponseTemplateType(templateId: string, model?: UpdateResponseTemplateTypeRequest, options?: any) {
        return MediaResponseApiFp(this.configuration).updateResponseTemplateType(templateId, model, options)(this.fetch, this.basePath);
    }

}

/**
 * MediaVerificationApi - fetch parameter creator
 * @export
 */
export const MediaVerificationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentItemsForMediaItem(mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling getContentItemsForMediaItem.');
            }
            const localVarPath = `/api/MediaVerification/contentItems/{mediaItemId}`
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaVerificationApi - functional programming interface
 * @export
 */
export const MediaVerificationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentItemsForMediaItem(mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MediaContentItems> {
            const localVarFetchArgs = MediaVerificationApiFetchParamCreator(configuration).getContentItemsForMediaItem(mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MediaVerificationApi - factory interface
 * @export
 */
export const MediaVerificationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContentItemsForMediaItem(mediaItemId: string, options?: any) {
            return MediaVerificationApiFp(configuration).getContentItemsForMediaItem(mediaItemId, options)(fetch, basePath);
        },
    };
};

/**
 * MediaVerificationApi - interface
 * @export
 * @interface MediaVerificationApi
 */
export interface MediaVerificationApiInterface {
    /**
     * 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaVerificationApiInterface
     */
    getContentItemsForMediaItem(mediaItemId: string, options?: any): Promise<MediaContentItems>;

}

/**
 * MediaVerificationApi - object-oriented interface
 * @export
 * @class MediaVerificationApi
 * @extends {BaseAPI}
 */
export class MediaVerificationApi extends BaseAPI implements MediaVerificationApiInterface {
    /**
     * 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaVerificationApi
     */
    public getContentItemsForMediaItem(mediaItemId: string, options?: any) {
        return MediaVerificationApiFp(this.configuration).getContentItemsForMediaItem(mediaItemId, options)(this.fetch, this.basePath);
    }

}

/**
 * MicrosoftAuthorizationApi - fetch parameter creator
 * @export
 */
export const MicrosoftAuthorizationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableCredentials(organizationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling getAvailableCredentials.');
            }
            const localVarPath = `/api/MicrosoftAuthorization/Credentials/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {string} [error] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        microsoftAuthCallbackAsync(code?: string, state?: string, error?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/MicrosoftAuthorization/Callback`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (error !== undefined) {
                localVarQueryParameter['error'] = error;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCredential(tokenId: string, options: any = {}): FetchArgs {
            // verify required parameter 'tokenId' is not null or undefined
            if (tokenId === null || tokenId === undefined) {
                throw new RequiredError('tokenId','Required parameter tokenId was null or undefined when calling removeCredential.');
            }
            const localVarPath = `/api/MicrosoftAuthorization/Credentials/{tokenId}`
                .replace(`{${"tokenId"}}`, encodeURIComponent(String(tokenId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [organizationId] 
         * @param {string} [applicationId] 
         * @param {string} [salt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestAuthenticationUrl(organizationId?: string, applicationId?: string, salt?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/MicrosoftAuthorization/AuthorizationUrl`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (organizationId !== undefined) {
                localVarQueryParameter['organizationId'] = organizationId;
            }

            if (applicationId !== undefined) {
                localVarQueryParameter['applicationId'] = applicationId;
            }

            if (salt !== undefined) {
                localVarQueryParameter['salt'] = salt;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MicrosoftAuthorizationApi - functional programming interface
 * @export
 */
export const MicrosoftAuthorizationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableCredentials(organizationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TokenResponse>> {
            const localVarFetchArgs = MicrosoftAuthorizationApiFetchParamCreator(configuration).getAvailableCredentials(organizationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {string} [error] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        microsoftAuthCallbackAsync(code?: string, state?: string, error?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = MicrosoftAuthorizationApiFetchParamCreator(configuration).microsoftAuthCallbackAsync(code, state, error, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCredential(tokenId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = MicrosoftAuthorizationApiFetchParamCreator(configuration).removeCredential(tokenId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [organizationId] 
         * @param {string} [applicationId] 
         * @param {string} [salt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestAuthenticationUrl(organizationId?: string, applicationId?: string, salt?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = MicrosoftAuthorizationApiFetchParamCreator(configuration).requestAuthenticationUrl(organizationId, applicationId, salt, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MicrosoftAuthorizationApi - factory interface
 * @export
 */
export const MicrosoftAuthorizationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableCredentials(organizationId: string, options?: any) {
            return MicrosoftAuthorizationApiFp(configuration).getAvailableCredentials(organizationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {string} [error] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        microsoftAuthCallbackAsync(code?: string, state?: string, error?: string, options?: any) {
            return MicrosoftAuthorizationApiFp(configuration).microsoftAuthCallbackAsync(code, state, error, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} tokenId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCredential(tokenId: string, options?: any) {
            return MicrosoftAuthorizationApiFp(configuration).removeCredential(tokenId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [organizationId] 
         * @param {string} [applicationId] 
         * @param {string} [salt] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestAuthenticationUrl(organizationId?: string, applicationId?: string, salt?: string, options?: any) {
            return MicrosoftAuthorizationApiFp(configuration).requestAuthenticationUrl(organizationId, applicationId, salt, options)(fetch, basePath);
        },
    };
};

/**
 * MicrosoftAuthorizationApi - interface
 * @export
 * @interface MicrosoftAuthorizationApi
 */
export interface MicrosoftAuthorizationApiInterface {
    /**
     * 
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MicrosoftAuthorizationApiInterface
     */
    getAvailableCredentials(organizationId: string, options?: any): Promise<Array<TokenResponse>>;

    /**
     * 
     * @param {string} [code] 
     * @param {string} [state] 
     * @param {string} [error] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MicrosoftAuthorizationApiInterface
     */
    microsoftAuthCallbackAsync(code?: string, state?: string, error?: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} tokenId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MicrosoftAuthorizationApiInterface
     */
    removeCredential(tokenId: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} [organizationId] 
     * @param {string} [applicationId] 
     * @param {string} [salt] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MicrosoftAuthorizationApiInterface
     */
    requestAuthenticationUrl(organizationId?: string, applicationId?: string, salt?: string, options?: any): Promise<string>;

}

/**
 * MicrosoftAuthorizationApi - object-oriented interface
 * @export
 * @class MicrosoftAuthorizationApi
 * @extends {BaseAPI}
 */
export class MicrosoftAuthorizationApi extends BaseAPI implements MicrosoftAuthorizationApiInterface {
    /**
     * 
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MicrosoftAuthorizationApi
     */
    public getAvailableCredentials(organizationId: string, options?: any) {
        return MicrosoftAuthorizationApiFp(this.configuration).getAvailableCredentials(organizationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [code] 
     * @param {string} [state] 
     * @param {string} [error] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MicrosoftAuthorizationApi
     */
    public microsoftAuthCallbackAsync(code?: string, state?: string, error?: string, options?: any) {
        return MicrosoftAuthorizationApiFp(this.configuration).microsoftAuthCallbackAsync(code, state, error, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} tokenId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MicrosoftAuthorizationApi
     */
    public removeCredential(tokenId: string, options?: any) {
        return MicrosoftAuthorizationApiFp(this.configuration).removeCredential(tokenId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [organizationId] 
     * @param {string} [applicationId] 
     * @param {string} [salt] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MicrosoftAuthorizationApi
     */
    public requestAuthenticationUrl(organizationId?: string, applicationId?: string, salt?: string, options?: any) {
        return MicrosoftAuthorizationApiFp(this.configuration).requestAuthenticationUrl(organizationId, applicationId, salt, options)(this.fetch, this.basePath);
    }

}

/**
 * ModuleApi - fetch parameter creator
 * @export
 */
export const ModuleApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a collection of new modules to the given application
         * @param {string} applicationId 
         * @param {Array<NewModuleRequest>} [models] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCustomModulesToApplication(applicationId: string, models?: Array<NewModuleRequest>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling addCustomModulesToApplication.');
            }
            const localVarPath = `/api/Module/addCustomModules/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;NewModuleRequest&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(models || {}) : (models || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {AddFeatureToModuleRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeatureToGeneralModule(applicationId: string, model?: AddFeatureToModuleRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling addFeatureToGeneralModule.');
            }
            const localVarPath = `/api/Module/addUncategorizedFeature/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddFeatureToModuleRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a feature to the given application module
         * @param {string} applicationModuleId 
         * @param {AddFeatureToModuleRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeatureToModule(applicationModuleId: string, model?: AddFeatureToModuleRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationModuleId' is not null or undefined
            if (applicationModuleId === null || applicationModuleId === undefined) {
                throw new RequiredError('applicationModuleId','Required parameter applicationModuleId was null or undefined when calling addFeatureToModule.');
            }
            const localVarPath = `/api/Module/addFeature/{applicationModuleId}`
                .replace(`{${"applicationModuleId"}}`, encodeURIComponent(String(applicationModuleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddFeatureToModuleRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a module to the given application
         * @param {string} applicationId 
         * @param {AddModuleToApplicationRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addModuleToApplication(applicationId: string, model?: AddModuleToApplicationRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling addModuleToApplication.');
            }
            const localVarPath = `/api/Module/addModule/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"AddModuleToApplicationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {Array<string>} [applicationModuleIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeApplicationModuleOrder(applicationId: string, applicationModuleIds?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling changeApplicationModuleOrder.');
            }
            const localVarPath = `/api/Module/reorderModules/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;string&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(applicationModuleIds || {}) : (applicationModuleIds || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a custom module for the given application
         * @param {string} applicationId 
         * @param {NewModuleRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomModule(applicationId: string, model?: NewModuleRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling createCustomModule.');
            }
            const localVarPath = `/api/Module/custom/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewModuleRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Disables the given application module
         * @param {string} applicationModuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableApplicationModule(applicationModuleId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationModuleId' is not null or undefined
            if (applicationModuleId === null || applicationModuleId === undefined) {
                throw new RequiredError('applicationModuleId','Required parameter applicationModuleId was null or undefined when calling disableApplicationModule.');
            }
            const localVarPath = `/api/Module/{applicationModuleId}/disable`
                .replace(`{${"applicationModuleId"}}`, encodeURIComponent(String(applicationModuleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the modules for the given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModulesForApplication(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getModulesForApplication.');
            }
            const localVarPath = `/api/Module/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all the system modules supported by voicify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemModules(options: any = {}): FetchArgs {
            const localVarPath = `/api/Module/SystemModules`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationModuleId 
         * @param {UpdateApplicationModuleRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationModule(applicationModuleId: string, model?: UpdateApplicationModuleRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationModuleId' is not null or undefined
            if (applicationModuleId === null || applicationModuleId === undefined) {
                throw new RequiredError('applicationModuleId','Required parameter applicationModuleId was null or undefined when calling updateApplicationModule.');
            }
            const localVarPath = `/api/Module/{applicationModuleId}/update`
                .replace(`{${"applicationModuleId"}}`, encodeURIComponent(String(applicationModuleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateApplicationModuleRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModuleApi - functional programming interface
 * @export
 */
export const ModuleApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a collection of new modules to the given application
         * @param {string} applicationId 
         * @param {Array<NewModuleRequest>} [models] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCustomModulesToApplication(applicationId: string, models?: Array<NewModuleRequest>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).addCustomModulesToApplication(applicationId, models, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {AddFeatureToModuleRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeatureToGeneralModule(applicationId: string, model?: AddFeatureToModuleRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).addFeatureToGeneralModule(applicationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a feature to the given application module
         * @param {string} applicationModuleId 
         * @param {AddFeatureToModuleRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeatureToModule(applicationModuleId: string, model?: AddFeatureToModuleRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).addFeatureToModule(applicationModuleId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a module to the given application
         * @param {string} applicationId 
         * @param {AddModuleToApplicationRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addModuleToApplication(applicationId: string, model?: AddModuleToApplicationRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).addModuleToApplication(applicationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {Array<string>} [applicationModuleIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeApplicationModuleOrder(applicationId: string, applicationModuleIds?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).changeApplicationModuleOrder(applicationId, applicationModuleIds, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a custom module for the given application
         * @param {string} applicationId 
         * @param {NewModuleRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomModule(applicationId: string, model?: NewModuleRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).createCustomModule(applicationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Disables the given application module
         * @param {string} applicationModuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableApplicationModule(applicationModuleId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).disableApplicationModule(applicationModuleId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the modules for the given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModulesForApplication(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).getModulesForApplication(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets all the system modules supported by voicify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemModules(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).getSystemModules(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationModuleId 
         * @param {UpdateApplicationModuleRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationModule(applicationModuleId: string, model?: UpdateApplicationModuleRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ModuleApiFetchParamCreator(configuration).updateApplicationModule(applicationModuleId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ModuleApi - factory interface
 * @export
 */
export const ModuleApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Adds a collection of new modules to the given application
         * @param {string} applicationId 
         * @param {Array<NewModuleRequest>} [models] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCustomModulesToApplication(applicationId: string, models?: Array<NewModuleRequest>, options?: any) {
            return ModuleApiFp(configuration).addCustomModulesToApplication(applicationId, models, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {AddFeatureToModuleRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeatureToGeneralModule(applicationId: string, model?: AddFeatureToModuleRequest, options?: any) {
            return ModuleApiFp(configuration).addFeatureToGeneralModule(applicationId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a feature to the given application module
         * @param {string} applicationModuleId 
         * @param {AddFeatureToModuleRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeatureToModule(applicationModuleId: string, model?: AddFeatureToModuleRequest, options?: any) {
            return ModuleApiFp(configuration).addFeatureToModule(applicationModuleId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a module to the given application
         * @param {string} applicationId 
         * @param {AddModuleToApplicationRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addModuleToApplication(applicationId: string, model?: AddModuleToApplicationRequest, options?: any) {
            return ModuleApiFp(configuration).addModuleToApplication(applicationId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {Array<string>} [applicationModuleIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeApplicationModuleOrder(applicationId: string, applicationModuleIds?: Array<string>, options?: any) {
            return ModuleApiFp(configuration).changeApplicationModuleOrder(applicationId, applicationModuleIds, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a custom module for the given application
         * @param {string} applicationId 
         * @param {NewModuleRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomModule(applicationId: string, model?: NewModuleRequest, options?: any) {
            return ModuleApiFp(configuration).createCustomModule(applicationId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Disables the given application module
         * @param {string} applicationModuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableApplicationModule(applicationModuleId: string, options?: any) {
            return ModuleApiFp(configuration).disableApplicationModule(applicationModuleId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the modules for the given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModulesForApplication(applicationId: string, options?: any) {
            return ModuleApiFp(configuration).getModulesForApplication(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets all the system modules supported by voicify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemModules(options?: any) {
            return ModuleApiFp(configuration).getSystemModules(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationModuleId 
         * @param {UpdateApplicationModuleRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApplicationModule(applicationModuleId: string, model?: UpdateApplicationModuleRequest, options?: any) {
            return ModuleApiFp(configuration).updateApplicationModule(applicationModuleId, model, options)(fetch, basePath);
        },
    };
};

/**
 * ModuleApi - interface
 * @export
 * @interface ModuleApi
 */
export interface ModuleApiInterface {
    /**
     * 
     * @summary Adds a collection of new modules to the given application
     * @param {string} applicationId 
     * @param {Array<NewModuleRequest>} [models] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApiInterface
     */
    addCustomModulesToApplication(applicationId: string, models?: Array<NewModuleRequest>, options?: any): Promise<{}>;

    /**
     * 
     * @param {string} applicationId 
     * @param {AddFeatureToModuleRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApiInterface
     */
    addFeatureToGeneralModule(applicationId: string, model?: AddFeatureToModuleRequest, options?: any): Promise<{}>;

    /**
     * 
     * @summary Adds a feature to the given application module
     * @param {string} applicationModuleId 
     * @param {AddFeatureToModuleRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApiInterface
     */
    addFeatureToModule(applicationModuleId: string, model?: AddFeatureToModuleRequest, options?: any): Promise<{}>;

    /**
     * 
     * @summary Adds a module to the given application
     * @param {string} applicationId 
     * @param {AddModuleToApplicationRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApiInterface
     */
    addModuleToApplication(applicationId: string, model?: AddModuleToApplicationRequest, options?: any): Promise<{}>;

    /**
     * 
     * @param {string} applicationId 
     * @param {Array<string>} [applicationModuleIds] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApiInterface
     */
    changeApplicationModuleOrder(applicationId: string, applicationModuleIds?: Array<string>, options?: any): Promise<{}>;

    /**
     * 
     * @summary Creates a custom module for the given application
     * @param {string} applicationId 
     * @param {NewModuleRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApiInterface
     */
    createCustomModule(applicationId: string, model?: NewModuleRequest, options?: any): Promise<{}>;

    /**
     * 
     * @summary Disables the given application module
     * @param {string} applicationModuleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApiInterface
     */
    disableApplicationModule(applicationModuleId: string, options?: any): Promise<{}>;

    /**
     * 
     * @summary Gets the modules for the given application
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApiInterface
     */
    getModulesForApplication(applicationId: string, options?: any): Promise<{}>;

    /**
     * 
     * @summary Gets all the system modules supported by voicify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApiInterface
     */
    getSystemModules(options?: any): Promise<{}>;

    /**
     * 
     * @param {string} applicationModuleId 
     * @param {UpdateApplicationModuleRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApiInterface
     */
    updateApplicationModule(applicationModuleId: string, model?: UpdateApplicationModuleRequest, options?: any): Promise<{}>;

}

/**
 * ModuleApi - object-oriented interface
 * @export
 * @class ModuleApi
 * @extends {BaseAPI}
 */
export class ModuleApi extends BaseAPI implements ModuleApiInterface {
    /**
     * 
     * @summary Adds a collection of new modules to the given application
     * @param {string} applicationId 
     * @param {Array<NewModuleRequest>} [models] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public addCustomModulesToApplication(applicationId: string, models?: Array<NewModuleRequest>, options?: any) {
        return ModuleApiFp(this.configuration).addCustomModulesToApplication(applicationId, models, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {AddFeatureToModuleRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public addFeatureToGeneralModule(applicationId: string, model?: AddFeatureToModuleRequest, options?: any) {
        return ModuleApiFp(this.configuration).addFeatureToGeneralModule(applicationId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a feature to the given application module
     * @param {string} applicationModuleId 
     * @param {AddFeatureToModuleRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public addFeatureToModule(applicationModuleId: string, model?: AddFeatureToModuleRequest, options?: any) {
        return ModuleApiFp(this.configuration).addFeatureToModule(applicationModuleId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a module to the given application
     * @param {string} applicationId 
     * @param {AddModuleToApplicationRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public addModuleToApplication(applicationId: string, model?: AddModuleToApplicationRequest, options?: any) {
        return ModuleApiFp(this.configuration).addModuleToApplication(applicationId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {Array<string>} [applicationModuleIds] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public changeApplicationModuleOrder(applicationId: string, applicationModuleIds?: Array<string>, options?: any) {
        return ModuleApiFp(this.configuration).changeApplicationModuleOrder(applicationId, applicationModuleIds, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a custom module for the given application
     * @param {string} applicationId 
     * @param {NewModuleRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public createCustomModule(applicationId: string, model?: NewModuleRequest, options?: any) {
        return ModuleApiFp(this.configuration).createCustomModule(applicationId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Disables the given application module
     * @param {string} applicationModuleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public disableApplicationModule(applicationModuleId: string, options?: any) {
        return ModuleApiFp(this.configuration).disableApplicationModule(applicationModuleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the modules for the given application
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public getModulesForApplication(applicationId: string, options?: any) {
        return ModuleApiFp(this.configuration).getModulesForApplication(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets all the system modules supported by voicify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public getSystemModules(options?: any) {
        return ModuleApiFp(this.configuration).getSystemModules(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationModuleId 
     * @param {UpdateApplicationModuleRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleApi
     */
    public updateApplicationModule(applicationModuleId: string, model?: UpdateApplicationModuleRequest, options?: any) {
        return ModuleApiFp(this.configuration).updateApplicationModule(applicationModuleId, model, options)(this.fetch, this.basePath);
    }

}

/**
 * NumberRangeApi - fetch parameter creator
 * @export
 */
export const NumberRangeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds an audio file to the given response
         * @param {string} numberRangeResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFile(numberRangeResponseId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'numberRangeResponseId' is not null or undefined
            if (numberRangeResponseId === null || numberRangeResponseId === undefined) {
                throw new RequiredError('numberRangeResponseId','Required parameter numberRangeResponseId was null or undefined when calling addAudioFile.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addAudioFile.');
            }
            const localVarPath = `/api/NumberRange/{numberRangeResponseId}/addAudioFile/{mediaItemId}`
                .replace(`{${"numberRangeResponseId"}}`, encodeURIComponent(String(numberRangeResponseId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a large image to the given response
         * @param {string} numberRangeResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(numberRangeResponseId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'numberRangeResponseId' is not null or undefined
            if (numberRangeResponseId === null || numberRangeResponseId === undefined) {
                throw new RequiredError('numberRangeResponseId','Required parameter numberRangeResponseId was null or undefined when calling addLargeImage.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addLargeImage.');
            }
            const localVarPath = `/api/NumberRange/{numberRangeResponseId}/addLargeImage/{mediaItemId}`
                .replace(`{${"numberRangeResponseId"}}`, encodeURIComponent(String(numberRangeResponseId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a small image item to the given response
         * @param {string} numberRangeResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(numberRangeResponseId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'numberRangeResponseId' is not null or undefined
            if (numberRangeResponseId === null || numberRangeResponseId === undefined) {
                throw new RequiredError('numberRangeResponseId','Required parameter numberRangeResponseId was null or undefined when calling addSmallImage.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addSmallImage.');
            }
            const localVarPath = `/api/NumberRange/{numberRangeResponseId}/addSmallImage/{mediaItemId}`
                .replace(`{${"numberRangeResponseId"}}`, encodeURIComponent(String(numberRangeResponseId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a video file to the given response
         * @param {string} numberRangeResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(numberRangeResponseId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'numberRangeResponseId' is not null or undefined
            if (numberRangeResponseId === null || numberRangeResponseId === undefined) {
                throw new RequiredError('numberRangeResponseId','Required parameter numberRangeResponseId was null or undefined when calling addVideoFile.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addVideoFile.');
            }
            const localVarPath = `/api/NumberRange/{numberRangeResponseId}/addVideoFile/{mediaItemId}`
                .replace(`{${"numberRangeResponseId"}}`, encodeURIComponent(String(numberRangeResponseId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} numberRangeId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(numberRangeId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'numberRangeId' is not null or undefined
            if (numberRangeId === null || numberRangeId === undefined) {
                throw new RequiredError('numberRangeId','Required parameter numberRangeId was null or undefined when calling addWebhook.');
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId','Required parameter webhookId was null or undefined when calling addWebhook.');
            }
            const localVarPath = `/api/NumberRange/{numberRangeId}/webhooks/{webhookId}`
                .replace(`{${"numberRangeId"}}`, encodeURIComponent(String(numberRangeId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} numberRangeId 
         * @param {BulkUpdateNumberRangeRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateNumberRange(numberRangeId: string, model?: BulkUpdateNumberRangeRequest, options: any = {}): FetchArgs {
            // verify required parameter 'numberRangeId' is not null or undefined
            if (numberRangeId === null || numberRangeId === undefined) {
                throw new RequiredError('numberRangeId','Required parameter numberRangeId was null or undefined when calling bulkUpdateNumberRange.');
            }
            const localVarPath = `/api/NumberRange/{numberRangeId}/bulkUpdate`
                .replace(`{${"numberRangeId"}}`, encodeURIComponent(String(numberRangeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkUpdateNumberRangeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} numberRangeId 
         * @param {BulkUpdateNumberRangeStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateNumberRangeStub(numberRangeId: string, model?: BulkUpdateNumberRangeStubRequest, options: any = {}): FetchArgs {
            // verify required parameter 'numberRangeId' is not null or undefined
            if (numberRangeId === null || numberRangeId === undefined) {
                throw new RequiredError('numberRangeId','Required parameter numberRangeId was null or undefined when calling bulkUpdateNumberRangeStub.');
            }
            const localVarPath = `/api/NumberRange/{numberRangeId}/bulkUpdate/stub`
                .replace(`{${"numberRangeId"}}`, encodeURIComponent(String(numberRangeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkUpdateNumberRangeStubRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} numberRangeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(numberRangeId: string, options: any = {}): FetchArgs {
            // verify required parameter 'numberRangeId' is not null or undefined
            if (numberRangeId === null || numberRangeId === undefined) {
                throw new RequiredError('numberRangeId','Required parameter numberRangeId was null or undefined when calling copyContentItem.');
            }
            const localVarPath = `/api/NumberRange/{numberRangeId}/copy`
                .replace(`{${"numberRangeId"}}`, encodeURIComponent(String(numberRangeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {NumberRangeModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: NumberRangeModel, options: any = {}): FetchArgs {
            const localVarPath = `/api/NumberRange/full`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NumberRangeModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new number range entity
         * @param {NewNumberRangeRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNumberRange(model?: NewNumberRangeRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/NumberRange`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewNumberRangeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new number range entity
         * @param {NewNumberRangeStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNumberRangeStub(model?: NewNumberRangeStubRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/NumberRange/stub`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewNumberRangeStubRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new response varation for the given message
         * @param {string} numberRangeId 
         * @param {NewNumberRangeResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResponse(numberRangeId: string, model?: NewNumberRangeResponseRequest, options: any = {}): FetchArgs {
            // verify required parameter 'numberRangeId' is not null or undefined
            if (numberRangeId === null || numberRangeId === undefined) {
                throw new RequiredError('numberRangeId','Required parameter numberRangeId was null or undefined when calling createResponse.');
            }
            const localVarPath = `/api/NumberRange/{numberRangeId}/response`
                .replace(`{${"numberRangeId"}}`, encodeURIComponent(String(numberRangeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewNumberRangeResponseRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling createUserDefinedParameter.');
            }
            const localVarPath = `/api/NumberRange/webhook/{instanceWebhookId}/userParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDefinedWebhookParameterCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the given number range
         * @param {string} numberRangeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNumberRange(numberRangeId: string, options: any = {}): FetchArgs {
            // verify required parameter 'numberRangeId' is not null or undefined
            if (numberRangeId === null || numberRangeId === undefined) {
                throw new RequiredError('numberRangeId','Required parameter numberRangeId was null or undefined when calling deleteNumberRange.');
            }
            const localVarPath = `/api/NumberRange/{numberRangeId}`
                .replace(`{${"numberRangeId"}}`, encodeURIComponent(String(numberRangeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes the given response
         * @param {string} numberRangeResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResponse(numberRangeResponseId: string, options: any = {}): FetchArgs {
            // verify required parameter 'numberRangeResponseId' is not null or undefined
            if (numberRangeResponseId === null || numberRangeResponseId === undefined) {
                throw new RequiredError('numberRangeResponseId','Required parameter numberRangeResponseId was null or undefined when calling deleteResponse.');
            }
            const localVarPath = `/api/NumberRange/response/{numberRangeResponseId}`
                .replace(`{${"numberRangeResponseId"}}`, encodeURIComponent(String(numberRangeResponseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling findFullById.');
            }
            const localVarPath = `/api/NumberRange/full/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling getByApplicationFeature.');
            }
            const localVarPath = `/api/NumberRange/byFeature/{applicationFeatureId}`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the number ranges content for the given application  regardless of module
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesForApplication(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getMessagesForApplication.');
            }
            const localVarPath = `/api/NumberRange/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the number ranges for the given application module
         * @param {string} applicationModuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesForModule(applicationModuleId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationModuleId' is not null or undefined
            if (applicationModuleId === null || applicationModuleId === undefined) {
                throw new RequiredError('applicationModuleId','Required parameter applicationModuleId was null or undefined when calling getMessagesForModule.');
            }
            const localVarPath = `/api/NumberRange/module/{applicationModuleId}`
                .replace(`{${"applicationModuleId"}}`, encodeURIComponent(String(applicationModuleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} numberRangeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(numberRangeId: string, options: any = {}): FetchArgs {
            // verify required parameter 'numberRangeId' is not null or undefined
            if (numberRangeId === null || numberRangeId === undefined) {
                throw new RequiredError('numberRangeId','Required parameter numberRangeId was null or undefined when calling getWebhooks.');
            }
            const localVarPath = `/api/NumberRange/{numberRangeId}/webhooks`
                .replace(`{${"numberRangeId"}}`, encodeURIComponent(String(numberRangeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'contentItemId' is not null or undefined
            if (contentItemId === null || contentItemId === undefined) {
                throw new RequiredError('contentItemId','Required parameter contentItemId was null or undefined when calling moveContentItemToApplicationFeature.');
            }
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling moveContentItemToApplicationFeature.');
            }
            const localVarPath = `/api/NumberRange/{contentItemId}/MoveToFeature/{applicationFeatureId}`
                .replace(`{${"contentItemId"}}`, encodeURIComponent(String(contentItemId)))
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling removeUserDefinedParameter.');
            }
            // verify required parameter 'parameterName' is not null or undefined
            if (parameterName === null || parameterName === undefined) {
                throw new RequiredError('parameterName','Required parameter parameterName was null or undefined when calling removeUserDefinedParameter.');
            }
            const localVarPath = `/api/NumberRange/webhook/{instanceWebhookId}/userParameters/{parameterName}`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)))
                .replace(`{${"parameterName"}}`, encodeURIComponent(String(parameterName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} numberRangeWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(numberRangeWebhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'numberRangeWebhookId' is not null or undefined
            if (numberRangeWebhookId === null || numberRangeWebhookId === undefined) {
                throw new RequiredError('numberRangeWebhookId','Required parameter numberRangeWebhookId was null or undefined when calling removeWebhook.');
            }
            const localVarPath = `/api/NumberRange/webhook/{numberRangeWebhookId}`
                .replace(`{${"numberRangeWebhookId"}}`, encodeURIComponent(String(numberRangeWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggles the given message as live or not
         * @param {string} numberRangeId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleLive(numberRangeId: string, model?: ToggleLiveRequest, options: any = {}): FetchArgs {
            // verify required parameter 'numberRangeId' is not null or undefined
            if (numberRangeId === null || numberRangeId === undefined) {
                throw new RequiredError('numberRangeId','Required parameter numberRangeId was null or undefined when calling toggleLive.');
            }
            const localVarPath = `/api/NumberRange/{numberRangeId}/isLive`
                .replace(`{${"numberRangeId"}}`, encodeURIComponent(String(numberRangeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ToggleLiveRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} numberRangeId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(numberRangeId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'numberRangeId' is not null or undefined
            if (numberRangeId === null || numberRangeId === undefined) {
                throw new RequiredError('numberRangeId','Required parameter numberRangeId was null or undefined when calling updateAttachedWebhook.');
            }
            // verify required parameter 'webhookInstanceId' is not null or undefined
            if (webhookInstanceId === null || webhookInstanceId === undefined) {
                throw new RequiredError('webhookInstanceId','Required parameter webhookInstanceId was null or undefined when calling updateAttachedWebhook.');
            }
            const localVarPath = `/api/NumberRange/{numberRangeId}/webhooks/{webhookInstanceId}`
                .replace(`{${"numberRangeId"}}`, encodeURIComponent(String(numberRangeId)))
                .replace(`{${"webhookInstanceId"}}`, encodeURIComponent(String(webhookInstanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {NumberRangeModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: NumberRangeModel, options: any = {}): FetchArgs {
            // verify required parameter 'contentItemId' is not null or undefined
            if (contentItemId === null || contentItemId === undefined) {
                throw new RequiredError('contentItemId','Required parameter contentItemId was null or undefined when calling updateFullContentItem.');
            }
            const localVarPath = `/api/NumberRange/{contentItemId}/full`
                .replace(`{${"contentItemId"}}`, encodeURIComponent(String(contentItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NumberRangeModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the number range with the given fields  If you send null or no value for fields, they won't be updated
         * @param {string} numberRangeId 
         * @param {UpdateNumberRangeRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessage(numberRangeId: string, model?: UpdateNumberRangeRequest, options: any = {}): FetchArgs {
            // verify required parameter 'numberRangeId' is not null or undefined
            if (numberRangeId === null || numberRangeId === undefined) {
                throw new RequiredError('numberRangeId','Required parameter numberRangeId was null or undefined when calling updateMessage.');
            }
            const localVarPath = `/api/NumberRange/{numberRangeId}`
                .replace(`{${"numberRangeId"}}`, encodeURIComponent(String(numberRangeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateNumberRangeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the given response
         * @param {string} numberRangeResponseId 
         * @param {UpdateNumberRangeResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResponse(numberRangeResponseId: string, model?: UpdateNumberRangeResponseRequest, options: any = {}): FetchArgs {
            // verify required parameter 'numberRangeResponseId' is not null or undefined
            if (numberRangeResponseId === null || numberRangeResponseId === undefined) {
                throw new RequiredError('numberRangeResponseId','Required parameter numberRangeResponseId was null or undefined when calling updateResponse.');
            }
            const localVarPath = `/api/NumberRange/response/{numberRangeResponseId}`
                .replace(`{${"numberRangeResponseId"}}`, encodeURIComponent(String(numberRangeResponseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateNumberRangeResponseRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateUserDefinedParameter.');
            }
            const localVarPath = `/api/NumberRange/webhook/{instanceWebhookId}/userParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDefinedWebhookParameterUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateWebhookParameter.');
            }
            const localVarPath = `/api/NumberRange/webhook/{instanceWebhookId}/webhookParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParameterUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NumberRangeApi - functional programming interface
 * @export
 */
export const NumberRangeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds an audio file to the given response
         * @param {string} numberRangeResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFile(numberRangeResponseId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NumberRangeResponseModel> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).addAudioFile(numberRangeResponseId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a large image to the given response
         * @param {string} numberRangeResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(numberRangeResponseId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NumberRangeResponseModel> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).addLargeImage(numberRangeResponseId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a small image item to the given response
         * @param {string} numberRangeResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(numberRangeResponseId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NumberRangeResponseModel> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).addSmallImage(numberRangeResponseId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a video file to the given response
         * @param {string} numberRangeResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(numberRangeResponseId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NumberRangeResponseModel> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).addVideoFile(numberRangeResponseId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} numberRangeId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(numberRangeId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NumberRangeWebhookModel> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).addWebhook(numberRangeId, webhookId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} numberRangeId 
         * @param {BulkUpdateNumberRangeRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateNumberRange(numberRangeId: string, model?: BulkUpdateNumberRangeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NumberRangeModel> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).bulkUpdateNumberRange(numberRangeId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} numberRangeId 
         * @param {BulkUpdateNumberRangeStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateNumberRangeStub(numberRangeId: string, model?: BulkUpdateNumberRangeStubRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NumberRangeModel> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).bulkUpdateNumberRangeStub(numberRangeId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} numberRangeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(numberRangeId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NumberRangeModel> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).copyContentItem(numberRangeId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {NumberRangeModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: NumberRangeModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NumberRangeModel> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).createFullContentItem(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new number range entity
         * @param {NewNumberRangeRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNumberRange(model?: NewNumberRangeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NumberRangeModel> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).createNumberRange(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new number range entity
         * @param {NewNumberRangeStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNumberRangeStub(model?: NewNumberRangeStubRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NumberRangeModel> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).createNumberRangeStub(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new response varation for the given message
         * @param {string} numberRangeId 
         * @param {NewNumberRangeResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResponse(numberRangeId: string, model?: NewNumberRangeResponseRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NumberRangeResponseModel> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).createResponse(numberRangeId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).createUserDefinedParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete the given number range
         * @param {string} numberRangeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNumberRange(numberRangeId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NumberRangeModel> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).deleteNumberRange(numberRangeId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes the given response
         * @param {string} numberRangeResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResponse(numberRangeResponseId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NumberRangeResponseModel> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).deleteResponse(numberRangeResponseId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NumberRangeModel> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).findFullById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NumberRangeModel>> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).getByApplicationFeature(applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the number ranges content for the given application  regardless of module
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesForApplication(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NumberRangeModel>> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).getMessagesForApplication(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the number ranges for the given application module
         * @param {string} applicationModuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesForModule(applicationModuleId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NumberRangeModel>> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).getMessagesForModule(applicationModuleId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} numberRangeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(numberRangeId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<NumberRangeWebhookModel>> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).getWebhooks(numberRangeId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NumberRangeModel> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} numberRangeWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(numberRangeWebhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NumberRangeWebhookModel> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).removeWebhook(numberRangeWebhookId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Toggles the given message as live or not
         * @param {string} numberRangeId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleLive(numberRangeId: string, model?: ToggleLiveRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NumberRangeModel> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).toggleLive(numberRangeId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} numberRangeId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(numberRangeId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NumberRangeWebhookModel> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).updateAttachedWebhook(numberRangeId, webhookInstanceId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {NumberRangeModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: NumberRangeModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NumberRangeModel> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).updateFullContentItem(contentItemId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the number range with the given fields  If you send null or no value for fields, they won't be updated
         * @param {string} numberRangeId 
         * @param {UpdateNumberRangeRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessage(numberRangeId: string, model?: UpdateNumberRangeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NumberRangeModel> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).updateMessage(numberRangeId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the given response
         * @param {string} numberRangeResponseId 
         * @param {UpdateNumberRangeResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResponse(numberRangeResponseId: string, model?: UpdateNumberRangeResponseRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NumberRangeResponseModel> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).updateResponse(numberRangeResponseId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).updateUserDefinedParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = NumberRangeApiFetchParamCreator(configuration).updateWebhookParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NumberRangeApi - factory interface
 * @export
 */
export const NumberRangeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Adds an audio file to the given response
         * @param {string} numberRangeResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFile(numberRangeResponseId: string, mediaItemId: string, options?: any) {
            return NumberRangeApiFp(configuration).addAudioFile(numberRangeResponseId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a large image to the given response
         * @param {string} numberRangeResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(numberRangeResponseId: string, mediaItemId: string, options?: any) {
            return NumberRangeApiFp(configuration).addLargeImage(numberRangeResponseId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a small image item to the given response
         * @param {string} numberRangeResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(numberRangeResponseId: string, mediaItemId: string, options?: any) {
            return NumberRangeApiFp(configuration).addSmallImage(numberRangeResponseId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a video file to the given response
         * @param {string} numberRangeResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(numberRangeResponseId: string, mediaItemId: string, options?: any) {
            return NumberRangeApiFp(configuration).addVideoFile(numberRangeResponseId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} numberRangeId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(numberRangeId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
            return NumberRangeApiFp(configuration).addWebhook(numberRangeId, webhookId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} numberRangeId 
         * @param {BulkUpdateNumberRangeRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateNumberRange(numberRangeId: string, model?: BulkUpdateNumberRangeRequest, options?: any) {
            return NumberRangeApiFp(configuration).bulkUpdateNumberRange(numberRangeId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} numberRangeId 
         * @param {BulkUpdateNumberRangeStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateNumberRangeStub(numberRangeId: string, model?: BulkUpdateNumberRangeStubRequest, options?: any) {
            return NumberRangeApiFp(configuration).bulkUpdateNumberRangeStub(numberRangeId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} numberRangeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(numberRangeId: string, options?: any) {
            return NumberRangeApiFp(configuration).copyContentItem(numberRangeId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {NumberRangeModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: NumberRangeModel, options?: any) {
            return NumberRangeApiFp(configuration).createFullContentItem(model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new number range entity
         * @param {NewNumberRangeRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNumberRange(model?: NewNumberRangeRequest, options?: any) {
            return NumberRangeApiFp(configuration).createNumberRange(model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new number range entity
         * @param {NewNumberRangeStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNumberRangeStub(model?: NewNumberRangeStubRequest, options?: any) {
            return NumberRangeApiFp(configuration).createNumberRangeStub(model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new response varation for the given message
         * @param {string} numberRangeId 
         * @param {NewNumberRangeResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResponse(numberRangeId: string, model?: NewNumberRangeResponseRequest, options?: any) {
            return NumberRangeApiFp(configuration).createResponse(numberRangeId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any) {
            return NumberRangeApiFp(configuration).createUserDefinedParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the given number range
         * @param {string} numberRangeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNumberRange(numberRangeId: string, options?: any) {
            return NumberRangeApiFp(configuration).deleteNumberRange(numberRangeId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes the given response
         * @param {string} numberRangeResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResponse(numberRangeResponseId: string, options?: any) {
            return NumberRangeApiFp(configuration).deleteResponse(numberRangeResponseId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options?: any) {
            return NumberRangeApiFp(configuration).findFullById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options?: any) {
            return NumberRangeApiFp(configuration).getByApplicationFeature(applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the number ranges content for the given application  regardless of module
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesForApplication(applicationId: string, options?: any) {
            return NumberRangeApiFp(configuration).getMessagesForApplication(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the number ranges for the given application module
         * @param {string} applicationModuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesForModule(applicationModuleId: string, options?: any) {
            return NumberRangeApiFp(configuration).getMessagesForModule(applicationModuleId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} numberRangeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(numberRangeId: string, options?: any) {
            return NumberRangeApiFp(configuration).getWebhooks(numberRangeId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any) {
            return NumberRangeApiFp(configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any) {
            return NumberRangeApiFp(configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} numberRangeWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(numberRangeWebhookId: string, options?: any) {
            return NumberRangeApiFp(configuration).removeWebhook(numberRangeWebhookId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Toggles the given message as live or not
         * @param {string} numberRangeId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleLive(numberRangeId: string, model?: ToggleLiveRequest, options?: any) {
            return NumberRangeApiFp(configuration).toggleLive(numberRangeId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} numberRangeId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(numberRangeId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any) {
            return NumberRangeApiFp(configuration).updateAttachedWebhook(numberRangeId, webhookInstanceId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {NumberRangeModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: NumberRangeModel, options?: any) {
            return NumberRangeApiFp(configuration).updateFullContentItem(contentItemId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the number range with the given fields  If you send null or no value for fields, they won't be updated
         * @param {string} numberRangeId 
         * @param {UpdateNumberRangeRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessage(numberRangeId: string, model?: UpdateNumberRangeRequest, options?: any) {
            return NumberRangeApiFp(configuration).updateMessage(numberRangeId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the given response
         * @param {string} numberRangeResponseId 
         * @param {UpdateNumberRangeResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResponse(numberRangeResponseId: string, model?: UpdateNumberRangeResponseRequest, options?: any) {
            return NumberRangeApiFp(configuration).updateResponse(numberRangeResponseId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any) {
            return NumberRangeApiFp(configuration).updateUserDefinedParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any) {
            return NumberRangeApiFp(configuration).updateWebhookParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
    };
};

/**
 * NumberRangeApi - interface
 * @export
 * @interface NumberRangeApi
 */
export interface NumberRangeApiInterface {
    /**
     * 
     * @summary Adds an audio file to the given response
     * @param {string} numberRangeResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    addAudioFile(numberRangeResponseId: string, mediaItemId: string, options?: any): Promise<NumberRangeResponseModel>;

    /**
     * 
     * @summary Adds a large image to the given response
     * @param {string} numberRangeResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    addLargeImage(numberRangeResponseId: string, mediaItemId: string, options?: any): Promise<NumberRangeResponseModel>;

    /**
     * 
     * @summary Adds a small image item to the given response
     * @param {string} numberRangeResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    addSmallImage(numberRangeResponseId: string, mediaItemId: string, options?: any): Promise<NumberRangeResponseModel>;

    /**
     * 
     * @summary Adds a video file to the given response
     * @param {string} numberRangeResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    addVideoFile(numberRangeResponseId: string, mediaItemId: string, options?: any): Promise<NumberRangeResponseModel>;

    /**
     * 
     * @param {string} numberRangeId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    addWebhook(numberRangeId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): Promise<NumberRangeWebhookModel>;

    /**
     * 
     * @param {string} numberRangeId 
     * @param {BulkUpdateNumberRangeRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    bulkUpdateNumberRange(numberRangeId: string, model?: BulkUpdateNumberRangeRequest, options?: any): Promise<NumberRangeModel>;

    /**
     * 
     * @param {string} numberRangeId 
     * @param {BulkUpdateNumberRangeStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    bulkUpdateNumberRangeStub(numberRangeId: string, model?: BulkUpdateNumberRangeStubRequest, options?: any): Promise<NumberRangeModel>;

    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param {string} numberRangeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    copyContentItem(numberRangeId: string, options?: any): Promise<NumberRangeModel>;

    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param {NumberRangeModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    createFullContentItem(model?: NumberRangeModel, options?: any): Promise<NumberRangeModel>;

    /**
     * 
     * @summary Creates a new number range entity
     * @param {NewNumberRangeRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    createNumberRange(model?: NewNumberRangeRequest, options?: any): Promise<NumberRangeModel>;

    /**
     * 
     * @summary Creates a new number range entity
     * @param {NewNumberRangeStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    createNumberRangeStub(model?: NewNumberRangeStubRequest, options?: any): Promise<NumberRangeModel>;

    /**
     * 
     * @summary Creates a new response varation for the given message
     * @param {string} numberRangeId 
     * @param {NewNumberRangeResponseRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    createResponse(numberRangeId: string, model?: NewNumberRangeResponseRequest, options?: any): Promise<NumberRangeResponseModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterCreateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @summary Delete the given number range
     * @param {string} numberRangeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    deleteNumberRange(numberRangeId: string, options?: any): Promise<NumberRangeModel>;

    /**
     * 
     * @summary Deletes the given response
     * @param {string} numberRangeResponseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    deleteResponse(numberRangeResponseId: string, options?: any): Promise<NumberRangeResponseModel>;

    /**
     * 
     * @summary Finds the full content item by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    findFullById(id: string, options?: any): Promise<NumberRangeModel>;

    /**
     * 
     * @summary Gets the content for the given application feature
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    getByApplicationFeature(applicationFeatureId: string, options?: any): Promise<Array<NumberRangeModel>>;

    /**
     * 
     * @summary Gets the number ranges content for the given application  regardless of module
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    getMessagesForApplication(applicationId: string, options?: any): Promise<Array<NumberRangeModel>>;

    /**
     * 
     * @summary Gets the number ranges for the given application module
     * @param {string} applicationModuleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    getMessagesForModule(applicationModuleId: string, options?: any): Promise<Array<NumberRangeModel>>;

    /**
     * 
     * @param {string} numberRangeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    getWebhooks(numberRangeId: string, options?: any): Promise<Array<NumberRangeWebhookModel>>;

    /**
     * 
     * @param {string} contentItemId 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any): Promise<NumberRangeModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {string} parameterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} numberRangeWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    removeWebhook(numberRangeWebhookId: string, options?: any): Promise<NumberRangeWebhookModel>;

    /**
     * 
     * @summary Toggles the given message as live or not
     * @param {string} numberRangeId 
     * @param {ToggleLiveRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    toggleLive(numberRangeId: string, model?: ToggleLiveRequest, options?: any): Promise<NumberRangeModel>;

    /**
     * 
     * @param {string} numberRangeId 
     * @param {string} webhookInstanceId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    updateAttachedWebhook(numberRangeId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any): Promise<NumberRangeWebhookModel>;

    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param {string} contentItemId 
     * @param {NumberRangeModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    updateFullContentItem(contentItemId: string, model?: NumberRangeModel, options?: any): Promise<NumberRangeModel>;

    /**
     * 
     * @summary Updates the number range with the given fields  If you send null or no value for fields, they won't be updated
     * @param {string} numberRangeId 
     * @param {UpdateNumberRangeRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    updateMessage(numberRangeId: string, model?: UpdateNumberRangeRequest, options?: any): Promise<NumberRangeModel>;

    /**
     * 
     * @summary Updates the given response
     * @param {string} numberRangeResponseId 
     * @param {UpdateNumberRangeResponseRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    updateResponse(numberRangeResponseId: string, model?: UpdateNumberRangeResponseRequest, options?: any): Promise<NumberRangeResponseModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {WebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApiInterface
     */
    updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any): Promise<boolean>;

}

/**
 * NumberRangeApi - object-oriented interface
 * @export
 * @class NumberRangeApi
 * @extends {BaseAPI}
 */
export class NumberRangeApi extends BaseAPI implements NumberRangeApiInterface {
    /**
     * 
     * @summary Adds an audio file to the given response
     * @param {string} numberRangeResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public addAudioFile(numberRangeResponseId: string, mediaItemId: string, options?: any) {
        return NumberRangeApiFp(this.configuration).addAudioFile(numberRangeResponseId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a large image to the given response
     * @param {string} numberRangeResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public addLargeImage(numberRangeResponseId: string, mediaItemId: string, options?: any) {
        return NumberRangeApiFp(this.configuration).addLargeImage(numberRangeResponseId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a small image item to the given response
     * @param {string} numberRangeResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public addSmallImage(numberRangeResponseId: string, mediaItemId: string, options?: any) {
        return NumberRangeApiFp(this.configuration).addSmallImage(numberRangeResponseId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a video file to the given response
     * @param {string} numberRangeResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public addVideoFile(numberRangeResponseId: string, mediaItemId: string, options?: any) {
        return NumberRangeApiFp(this.configuration).addVideoFile(numberRangeResponseId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} numberRangeId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public addWebhook(numberRangeId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
        return NumberRangeApiFp(this.configuration).addWebhook(numberRangeId, webhookId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} numberRangeId 
     * @param {BulkUpdateNumberRangeRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public bulkUpdateNumberRange(numberRangeId: string, model?: BulkUpdateNumberRangeRequest, options?: any) {
        return NumberRangeApiFp(this.configuration).bulkUpdateNumberRange(numberRangeId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} numberRangeId 
     * @param {BulkUpdateNumberRangeStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public bulkUpdateNumberRangeStub(numberRangeId: string, model?: BulkUpdateNumberRangeStubRequest, options?: any) {
        return NumberRangeApiFp(this.configuration).bulkUpdateNumberRangeStub(numberRangeId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param {string} numberRangeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public copyContentItem(numberRangeId: string, options?: any) {
        return NumberRangeApiFp(this.configuration).copyContentItem(numberRangeId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param {NumberRangeModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public createFullContentItem(model?: NumberRangeModel, options?: any) {
        return NumberRangeApiFp(this.configuration).createFullContentItem(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new number range entity
     * @param {NewNumberRangeRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public createNumberRange(model?: NewNumberRangeRequest, options?: any) {
        return NumberRangeApiFp(this.configuration).createNumberRange(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new number range entity
     * @param {NewNumberRangeStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public createNumberRangeStub(model?: NewNumberRangeStubRequest, options?: any) {
        return NumberRangeApiFp(this.configuration).createNumberRangeStub(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new response varation for the given message
     * @param {string} numberRangeId 
     * @param {NewNumberRangeResponseRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public createResponse(numberRangeId: string, model?: NewNumberRangeResponseRequest, options?: any) {
        return NumberRangeApiFp(this.configuration).createResponse(numberRangeId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterCreateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any) {
        return NumberRangeApiFp(this.configuration).createUserDefinedParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete the given number range
     * @param {string} numberRangeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public deleteNumberRange(numberRangeId: string, options?: any) {
        return NumberRangeApiFp(this.configuration).deleteNumberRange(numberRangeId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes the given response
     * @param {string} numberRangeResponseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public deleteResponse(numberRangeResponseId: string, options?: any) {
        return NumberRangeApiFp(this.configuration).deleteResponse(numberRangeResponseId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Finds the full content item by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public findFullById(id: string, options?: any) {
        return NumberRangeApiFp(this.configuration).findFullById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the content for the given application feature
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public getByApplicationFeature(applicationFeatureId: string, options?: any) {
        return NumberRangeApiFp(this.configuration).getByApplicationFeature(applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the number ranges content for the given application  regardless of module
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public getMessagesForApplication(applicationId: string, options?: any) {
        return NumberRangeApiFp(this.configuration).getMessagesForApplication(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the number ranges for the given application module
     * @param {string} applicationModuleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public getMessagesForModule(applicationModuleId: string, options?: any) {
        return NumberRangeApiFp(this.configuration).getMessagesForModule(applicationModuleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} numberRangeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public getWebhooks(numberRangeId: string, options?: any) {
        return NumberRangeApiFp(this.configuration).getWebhooks(numberRangeId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} contentItemId 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any) {
        return NumberRangeApiFp(this.configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {string} parameterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any) {
        return NumberRangeApiFp(this.configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} numberRangeWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public removeWebhook(numberRangeWebhookId: string, options?: any) {
        return NumberRangeApiFp(this.configuration).removeWebhook(numberRangeWebhookId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Toggles the given message as live or not
     * @param {string} numberRangeId 
     * @param {ToggleLiveRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public toggleLive(numberRangeId: string, model?: ToggleLiveRequest, options?: any) {
        return NumberRangeApiFp(this.configuration).toggleLive(numberRangeId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} numberRangeId 
     * @param {string} webhookInstanceId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public updateAttachedWebhook(numberRangeId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any) {
        return NumberRangeApiFp(this.configuration).updateAttachedWebhook(numberRangeId, webhookInstanceId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param {string} contentItemId 
     * @param {NumberRangeModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public updateFullContentItem(contentItemId: string, model?: NumberRangeModel, options?: any) {
        return NumberRangeApiFp(this.configuration).updateFullContentItem(contentItemId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the number range with the given fields  If you send null or no value for fields, they won't be updated
     * @param {string} numberRangeId 
     * @param {UpdateNumberRangeRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public updateMessage(numberRangeId: string, model?: UpdateNumberRangeRequest, options?: any) {
        return NumberRangeApiFp(this.configuration).updateMessage(numberRangeId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the given response
     * @param {string} numberRangeResponseId 
     * @param {UpdateNumberRangeResponseRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public updateResponse(numberRangeResponseId: string, model?: UpdateNumberRangeResponseRequest, options?: any) {
        return NumberRangeApiFp(this.configuration).updateResponse(numberRangeResponseId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any) {
        return NumberRangeApiFp(this.configuration).updateUserDefinedParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {WebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NumberRangeApi
     */
    public updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any) {
        return NumberRangeApiFp(this.configuration).updateWebhookParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

}

/**
 * OrganizationApi - fetch parameter creator
 * @export
 */
export const OrganizationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new Organization
         * @param {NewOrganizationRequest} [model] The details of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(model?: NewOrganizationRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Organization`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewOrganizationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the members of an organization
         * @param {string} organizationId The id of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailedMemberships(organizationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling getDetailedMemberships.');
            }
            const localVarPath = `/api/Organization/{organizationId}/members/detailed`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the organization that the current user is a member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForUser(options: any = {}): FetchArgs {
            const localVarPath = `/api/Organization`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the members of an organization
         * @param {string} organizationId The id of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembers(organizationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling getMembers.');
            }
            const localVarPath = `/api/Organization/{organizationId}/members`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Leaves the organization and deletes the current user member record
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveOrganization(organizationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling leaveOrganization.');
            }
            const localVarPath = `/api/Organization/{organizationId}/leave`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Regenerates the given org's secret used for authentication
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateOrganizationSecret(organizationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling regenerateOrganizationSecret.');
            }
            const localVarPath = `/api/Organization/{organizationId}/regenerateSecrets`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Removes a member of the organization
         * @param {string} organizationMemberId The member id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMember(organizationMemberId: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationMemberId' is not null or undefined
            if (organizationMemberId === null || organizationMemberId === undefined) {
                throw new RequiredError('organizationMemberId','Required parameter organizationMemberId was null or undefined when calling removeMember.');
            }
            const localVarPath = `/api/Organization/members/{organizationMemberId}/remove`
                .replace(`{${"organizationMemberId"}}`, encodeURIComponent(String(organizationMemberId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the organization's details
         * @param {string} organizationId the id of the organization
         * @param {UpdateOrganizationRequest} [model] The information to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDetails(organizationId: string, model?: UpdateOrganizationRequest, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling updateDetails.');
            }
            const localVarPath = `/api/Organization/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateOrganizationRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the role of a member of an organization
         * @param {string} organizationMemberId The member id
         * @param {MemberRoleUpdateRequest} [model] The role information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMemberRole(organizationMemberId: string, model?: MemberRoleUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'organizationMemberId' is not null or undefined
            if (organizationMemberId === null || organizationMemberId === undefined) {
                throw new RequiredError('organizationMemberId','Required parameter organizationMemberId was null or undefined when calling updateMemberRole.');
            }
            const localVarPath = `/api/Organization/members/{organizationMemberId}/role`
                .replace(`{${"organizationMemberId"}}`, encodeURIComponent(String(organizationMemberId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MemberRoleUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrganizationApi - functional programming interface
 * @export
 */
export const OrganizationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Creates a new Organization
         * @param {NewOrganizationRequest} [model] The details of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(model?: NewOrganizationRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrganizationModel> {
            const localVarFetchArgs = OrganizationApiFetchParamCreator(configuration).createOrganization(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the members of an organization
         * @param {string} organizationId The id of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailedMemberships(organizationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MembershipModel>> {
            const localVarFetchArgs = OrganizationApiFetchParamCreator(configuration).getDetailedMemberships(organizationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the organization that the current user is a member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OrganizationModel>> {
            const localVarFetchArgs = OrganizationApiFetchParamCreator(configuration).getForUser(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the members of an organization
         * @param {string} organizationId The id of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembers(organizationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<OrganizationMemberModel>> {
            const localVarFetchArgs = OrganizationApiFetchParamCreator(configuration).getMembers(organizationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Leaves the organization and deletes the current user member record
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveOrganization(organizationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrganizationMemberModel> {
            const localVarFetchArgs = OrganizationApiFetchParamCreator(configuration).leaveOrganization(organizationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Regenerates the given org's secret used for authentication
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateOrganizationSecret(organizationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrganizationModel> {
            const localVarFetchArgs = OrganizationApiFetchParamCreator(configuration).regenerateOrganizationSecret(organizationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Removes a member of the organization
         * @param {string} organizationMemberId The member id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMember(organizationMemberId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrganizationMemberModel> {
            const localVarFetchArgs = OrganizationApiFetchParamCreator(configuration).removeMember(organizationMemberId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the organization's details
         * @param {string} organizationId the id of the organization
         * @param {UpdateOrganizationRequest} [model] The information to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDetails(organizationId: string, model?: UpdateOrganizationRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrganizationModel> {
            const localVarFetchArgs = OrganizationApiFetchParamCreator(configuration).updateDetails(organizationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the role of a member of an organization
         * @param {string} organizationMemberId The member id
         * @param {MemberRoleUpdateRequest} [model] The role information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMemberRole(organizationMemberId: string, model?: MemberRoleUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<OrganizationMemberModel> {
            const localVarFetchArgs = OrganizationApiFetchParamCreator(configuration).updateMemberRole(organizationMemberId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrganizationApi - factory interface
 * @export
 */
export const OrganizationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Creates a new Organization
         * @param {NewOrganizationRequest} [model] The details of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrganization(model?: NewOrganizationRequest, options?: any) {
            return OrganizationApiFp(configuration).createOrganization(model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the members of an organization
         * @param {string} organizationId The id of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDetailedMemberships(organizationId: string, options?: any) {
            return OrganizationApiFp(configuration).getDetailedMemberships(organizationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the organization that the current user is a member of
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForUser(options?: any) {
            return OrganizationApiFp(configuration).getForUser(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the members of an organization
         * @param {string} organizationId The id of the organization
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMembers(organizationId: string, options?: any) {
            return OrganizationApiFp(configuration).getMembers(organizationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Leaves the organization and deletes the current user member record
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leaveOrganization(organizationId: string, options?: any) {
            return OrganizationApiFp(configuration).leaveOrganization(organizationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Regenerates the given org's secret used for authentication
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regenerateOrganizationSecret(organizationId: string, options?: any) {
            return OrganizationApiFp(configuration).regenerateOrganizationSecret(organizationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Removes a member of the organization
         * @param {string} organizationMemberId The member id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeMember(organizationMemberId: string, options?: any) {
            return OrganizationApiFp(configuration).removeMember(organizationMemberId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the organization's details
         * @param {string} organizationId the id of the organization
         * @param {UpdateOrganizationRequest} [model] The information to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDetails(organizationId: string, model?: UpdateOrganizationRequest, options?: any) {
            return OrganizationApiFp(configuration).updateDetails(organizationId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the role of a member of an organization
         * @param {string} organizationMemberId The member id
         * @param {MemberRoleUpdateRequest} [model] The role information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMemberRole(organizationMemberId: string, model?: MemberRoleUpdateRequest, options?: any) {
            return OrganizationApiFp(configuration).updateMemberRole(organizationMemberId, model, options)(fetch, basePath);
        },
    };
};

/**
 * OrganizationApi - interface
 * @export
 * @interface OrganizationApi
 */
export interface OrganizationApiInterface {
    /**
     * 
     * @summary Creates a new Organization
     * @param {NewOrganizationRequest} [model] The details of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    createOrganization(model?: NewOrganizationRequest, options?: any): Promise<OrganizationModel>;

    /**
     * 
     * @summary Gets the members of an organization
     * @param {string} organizationId The id of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    getDetailedMemberships(organizationId: string, options?: any): Promise<Array<MembershipModel>>;

    /**
     * 
     * @summary Gets the organization that the current user is a member of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    getForUser(options?: any): Promise<Array<OrganizationModel>>;

    /**
     * 
     * @summary Gets the members of an organization
     * @param {string} organizationId The id of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    getMembers(organizationId: string, options?: any): Promise<Array<OrganizationMemberModel>>;

    /**
     * 
     * @summary Leaves the organization and deletes the current user member record
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    leaveOrganization(organizationId: string, options?: any): Promise<OrganizationMemberModel>;

    /**
     * 
     * @summary Regenerates the given org's secret used for authentication
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    regenerateOrganizationSecret(organizationId: string, options?: any): Promise<OrganizationModel>;

    /**
     * 
     * @summary Removes a member of the organization
     * @param {string} organizationMemberId The member id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    removeMember(organizationMemberId: string, options?: any): Promise<OrganizationMemberModel>;

    /**
     * 
     * @summary Updates the organization's details
     * @param {string} organizationId the id of the organization
     * @param {UpdateOrganizationRequest} [model] The information to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    updateDetails(organizationId: string, model?: UpdateOrganizationRequest, options?: any): Promise<OrganizationModel>;

    /**
     * 
     * @summary Updates the role of a member of an organization
     * @param {string} organizationMemberId The member id
     * @param {MemberRoleUpdateRequest} [model] The role information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApiInterface
     */
    updateMemberRole(organizationMemberId: string, model?: MemberRoleUpdateRequest, options?: any): Promise<OrganizationMemberModel>;

}

/**
 * OrganizationApi - object-oriented interface
 * @export
 * @class OrganizationApi
 * @extends {BaseAPI}
 */
export class OrganizationApi extends BaseAPI implements OrganizationApiInterface {
    /**
     * 
     * @summary Creates a new Organization
     * @param {NewOrganizationRequest} [model] The details of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public createOrganization(model?: NewOrganizationRequest, options?: any) {
        return OrganizationApiFp(this.configuration).createOrganization(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the members of an organization
     * @param {string} organizationId The id of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getDetailedMemberships(organizationId: string, options?: any) {
        return OrganizationApiFp(this.configuration).getDetailedMemberships(organizationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the organization that the current user is a member of
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getForUser(options?: any) {
        return OrganizationApiFp(this.configuration).getForUser(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the members of an organization
     * @param {string} organizationId The id of the organization
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public getMembers(organizationId: string, options?: any) {
        return OrganizationApiFp(this.configuration).getMembers(organizationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Leaves the organization and deletes the current user member record
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public leaveOrganization(organizationId: string, options?: any) {
        return OrganizationApiFp(this.configuration).leaveOrganization(organizationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Regenerates the given org's secret used for authentication
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public regenerateOrganizationSecret(organizationId: string, options?: any) {
        return OrganizationApiFp(this.configuration).regenerateOrganizationSecret(organizationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Removes a member of the organization
     * @param {string} organizationMemberId The member id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public removeMember(organizationMemberId: string, options?: any) {
        return OrganizationApiFp(this.configuration).removeMember(organizationMemberId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the organization's details
     * @param {string} organizationId the id of the organization
     * @param {UpdateOrganizationRequest} [model] The information to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateDetails(organizationId: string, model?: UpdateOrganizationRequest, options?: any) {
        return OrganizationApiFp(this.configuration).updateDetails(organizationId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the role of a member of an organization
     * @param {string} organizationMemberId The member id
     * @param {MemberRoleUpdateRequest} [model] The role information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrganizationApi
     */
    public updateMemberRole(organizationMemberId: string, model?: MemberRoleUpdateRequest, options?: any) {
        return OrganizationApiFp(this.configuration).updateMemberRole(organizationMemberId, model, options)(this.fetch, this.basePath);
    }

}

/**
 * QuestionAnswerApi - fetch parameter creator
 * @export
 */
export const QuestionAnswerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an FAQ
         * @param {string} questionAnswerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(questionAnswerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'questionAnswerId' is not null or undefined
            if (questionAnswerId === null || questionAnswerId === undefined) {
                throw new RequiredError('questionAnswerId','Required parameter questionAnswerId was null or undefined when calling _delete.');
            }
            const localVarPath = `/api/QuestionAnswer/{questionAnswerId}`
                .replace(`{${"questionAnswerId"}}`, encodeURIComponent(String(questionAnswerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds an audio file to the answer message
         * @param {string} answerMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFileImage(answerMessageId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'answerMessageId' is not null or undefined
            if (answerMessageId === null || answerMessageId === undefined) {
                throw new RequiredError('answerMessageId','Required parameter answerMessageId was null or undefined when calling addAudioFileImage.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addAudioFileImage.');
            }
            const localVarPath = `/api/QuestionAnswer/{answerMessageId}/addAudioFile/{mediaItemId}`
                .replace(`{${"answerMessageId"}}`, encodeURIComponent(String(answerMessageId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a large image to the answer message
         * @param {string} answerMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(answerMessageId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'answerMessageId' is not null or undefined
            if (answerMessageId === null || answerMessageId === undefined) {
                throw new RequiredError('answerMessageId','Required parameter answerMessageId was null or undefined when calling addLargeImage.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addLargeImage.');
            }
            const localVarPath = `/api/QuestionAnswer/{answerMessageId}/addLargeImage/{mediaItemId}`
                .replace(`{${"answerMessageId"}}`, encodeURIComponent(String(answerMessageId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds required user phrases to a quesiton answer item.
         * @param {string} contentItemId 
         * @param {RequiredPhrasesRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrUpdateRequiredPhrases(contentItemId: string, request?: RequiredPhrasesRequest, options: any = {}): FetchArgs {
            // verify required parameter 'contentItemId' is not null or undefined
            if (contentItemId === null || contentItemId === undefined) {
                throw new RequiredError('contentItemId','Required parameter contentItemId was null or undefined when calling addOrUpdateRequiredPhrases.');
            }
            const localVarPath = `/api/QuestionAnswer/{contentItemId}/RequiredPhrases`
                .replace(`{${"contentItemId"}}`, encodeURIComponent(String(contentItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RequiredPhrasesRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a small image to the answer message
         * @param {string} answerMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(answerMessageId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'answerMessageId' is not null or undefined
            if (answerMessageId === null || answerMessageId === undefined) {
                throw new RequiredError('answerMessageId','Required parameter answerMessageId was null or undefined when calling addSmallImage.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addSmallImage.');
            }
            const localVarPath = `/api/QuestionAnswer/{answerMessageId}/addSmallImage/{mediaItemId}`
                .replace(`{${"answerMessageId"}}`, encodeURIComponent(String(answerMessageId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a video file to the answer message
         * @param {string} answerMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(answerMessageId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'answerMessageId' is not null or undefined
            if (answerMessageId === null || answerMessageId === undefined) {
                throw new RequiredError('answerMessageId','Required parameter answerMessageId was null or undefined when calling addVideoFile.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addVideoFile.');
            }
            const localVarPath = `/api/QuestionAnswer/{answerMessageId}/addVideoFile/{mediaItemId}`
                .replace(`{${"answerMessageId"}}`, encodeURIComponent(String(answerMessageId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a webhook to a question answer item
         * @param {string} questionAnswerId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(questionAnswerId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'questionAnswerId' is not null or undefined
            if (questionAnswerId === null || questionAnswerId === undefined) {
                throw new RequiredError('questionAnswerId','Required parameter questionAnswerId was null or undefined when calling addWebhook.');
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId','Required parameter webhookId was null or undefined when calling addWebhook.');
            }
            const localVarPath = `/api/QuestionAnswer/{questionAnswerId}/webhooks/{webhookId}`
                .replace(`{${"questionAnswerId"}}`, encodeURIComponent(String(questionAnswerId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bulk updates the question answer and the internal variations
         * @param {string} questionAnswerId 
         * @param {BulkQuestionAnswerUpdateRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdate(questionAnswerId: string, model?: BulkQuestionAnswerUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'questionAnswerId' is not null or undefined
            if (questionAnswerId === null || questionAnswerId === undefined) {
                throw new RequiredError('questionAnswerId','Required parameter questionAnswerId was null or undefined when calling bulkUpdate.');
            }
            const localVarPath = `/api/QuestionAnswer/{questionAnswerId}/bulkUpdate`
                .replace(`{${"questionAnswerId"}}`, encodeURIComponent(String(questionAnswerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkQuestionAnswerUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Bulk updates the question answer and the internal variations
         * @param {string} questionAnswerId 
         * @param {BulkQuestionAnswerUpdateStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateStub(questionAnswerId: string, model?: BulkQuestionAnswerUpdateStubRequest, options: any = {}): FetchArgs {
            // verify required parameter 'questionAnswerId' is not null or undefined
            if (questionAnswerId === null || questionAnswerId === undefined) {
                throw new RequiredError('questionAnswerId','Required parameter questionAnswerId was null or undefined when calling bulkUpdateStub.');
            }
            const localVarPath = `/api/QuestionAnswer/{questionAnswerId}/bulkUpdate/stub`
                .replace(`{${"questionAnswerId"}}`, encodeURIComponent(String(questionAnswerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkQuestionAnswerUpdateStubRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} questionAnswerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(questionAnswerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'questionAnswerId' is not null or undefined
            if (questionAnswerId === null || questionAnswerId === undefined) {
                throw new RequiredError('questionAnswerId','Required parameter questionAnswerId was null or undefined when calling copyContentItem.');
            }
            const localVarPath = `/api/QuestionAnswer/{questionAnswerId}/copy`
                .replace(`{${"questionAnswerId"}}`, encodeURIComponent(String(questionAnswerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the content for the given application feature with skip/take
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countByApplicationFeature(applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling countByApplicationFeature.');
            }
            const localVarPath = `/api/QuestionAnswer/byFeature/{applicationFeatureId}/count`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new FAQ
         * @param {NewQuestionAnswerRequest} [model] Initial question and answer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(model?: NewQuestionAnswerRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/QuestionAnswer`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewQuestionAnswerRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add an answer to the FAQ set
         * @param {string} questionAnswerId 
         * @param {CreateAnswerRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnswer(questionAnswerId: string, model?: CreateAnswerRequest, options: any = {}): FetchArgs {
            // verify required parameter 'questionAnswerId' is not null or undefined
            if (questionAnswerId === null || questionAnswerId === undefined) {
                throw new RequiredError('questionAnswerId','Required parameter questionAnswerId was null or undefined when calling createAnswer.');
            }
            const localVarPath = `/api/QuestionAnswer/{questionAnswerId}/Answer`
                .replace(`{${"questionAnswerId"}}`, encodeURIComponent(String(questionAnswerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateAnswerRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {QuestionAnswerModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: QuestionAnswerModel, options: any = {}): FetchArgs {
            const localVarPath = `/api/QuestionAnswer/full`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuestionAnswerModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a question to the FAQ set
         * @param {string} questionAnswerId 
         * @param {CreateQuestionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestion(questionAnswerId: string, model?: CreateQuestionRequest, options: any = {}): FetchArgs {
            // verify required parameter 'questionAnswerId' is not null or undefined
            if (questionAnswerId === null || questionAnswerId === undefined) {
                throw new RequiredError('questionAnswerId','Required parameter questionAnswerId was null or undefined when calling createQuestion.');
            }
            const localVarPath = `/api/QuestionAnswer/{questionAnswerId}/Question`
                .replace(`{${"questionAnswerId"}}`, encodeURIComponent(String(questionAnswerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateQuestionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new FAQ
         * @param {NewQuestionAnswerStubRequest} [model] Initial question and answer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStub(model?: NewQuestionAnswerStubRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/QuestionAnswer/stub`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewQuestionAnswerStubRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling createUserDefinedParameter.');
            }
            const localVarPath = `/api/QuestionAnswer/webhook/{instanceWebhookId}/userParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDefinedWebhookParameterCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an answer
         * @param {string} answerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnswer(answerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'answerId' is not null or undefined
            if (answerId === null || answerId === undefined) {
                throw new RequiredError('answerId','Required parameter answerId was null or undefined when calling deleteAnswer.');
            }
            const localVarPath = `/api/QuestionAnswer/answer/{answerId}`
                .replace(`{${"answerId"}}`, encodeURIComponent(String(answerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a question
         * @param {string} questionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestion(questionId: string, options: any = {}): FetchArgs {
            // verify required parameter 'questionId' is not null or undefined
            if (questionId === null || questionId === undefined) {
                throw new RequiredError('questionId','Required parameter questionId was null or undefined when calling deleteQuestion.');
            }
            const localVarPath = `/api/QuestionAnswer/question/{questionId}`
                .replace(`{${"questionId"}}`, encodeURIComponent(String(questionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a given Answer
         * @param {string} answerId 
         * @param {UpdateAnswerRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAnswer(answerId: string, model?: UpdateAnswerRequest, options: any = {}): FetchArgs {
            // verify required parameter 'answerId' is not null or undefined
            if (answerId === null || answerId === undefined) {
                throw new RequiredError('answerId','Required parameter answerId was null or undefined when calling editAnswer.');
            }
            const localVarPath = `/api/QuestionAnswer/Answer/{answerId}`
                .replace(`{${"answerId"}}`, encodeURIComponent(String(answerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateAnswerRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a given question
         * @param {string} questionId 
         * @param {UpdateQuestionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editQuestion(questionId: string, model?: UpdateQuestionRequest, options: any = {}): FetchArgs {
            // verify required parameter 'questionId' is not null or undefined
            if (questionId === null || questionId === undefined) {
                throw new RequiredError('questionId','Required parameter questionId was null or undefined when calling editQuestion.');
            }
            const localVarPath = `/api/QuestionAnswer/Question/{questionId}`
                .replace(`{${"questionId"}}`, encodeURIComponent(String(questionId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateQuestionRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling findFullById.');
            }
            const localVarPath = `/api/QuestionAnswer/full/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an FAQ by its ID
         * @param {string} questionAnswerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(questionAnswerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'questionAnswerId' is not null or undefined
            if (questionAnswerId === null || questionAnswerId === undefined) {
                throw new RequiredError('questionAnswerId','Required parameter questionAnswerId was null or undefined when calling get.');
            }
            const localVarPath = `/api/QuestionAnswer/{questionAnswerId}`
                .replace(`{${"questionAnswerId"}}`, encodeURIComponent(String(questionAnswerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllByApplicationFeature(applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling getAllByApplicationFeature.');
            }
            const localVarPath = `/api/QuestionAnswer/byFeature/{applicationFeatureId}`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the content for the given application feature with skip/take
         * @param {string} applicationFeatureId 
         * @param {string} [sortBy] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, sortBy?: string, skip?: number, take?: number, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling getByApplicationFeature.');
            }
            const localVarPath = `/api/QuestionAnswer/byFeature/{applicationFeatureId}/paginated`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (skip !== undefined) {
                localVarQueryParameter['skip'] = skip;
            }

            if (take !== undefined) {
                localVarQueryParameter['take'] = take;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the FAQs for a given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionAnswersForApplication(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getQuestionAnswersForApplication.');
            }
            const localVarPath = `/api/QuestionAnswer/{applicationId}/faqs`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the webhooks associated with a question answer item
         * @param {string} questionAnswerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(questionAnswerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'questionAnswerId' is not null or undefined
            if (questionAnswerId === null || questionAnswerId === undefined) {
                throw new RequiredError('questionAnswerId','Required parameter questionAnswerId was null or undefined when calling getWebhooks.');
            }
            const localVarPath = `/api/QuestionAnswer/{questionAnswerId}/webhooks`
                .replace(`{${"questionAnswerId"}}`, encodeURIComponent(String(questionAnswerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'contentItemId' is not null or undefined
            if (contentItemId === null || contentItemId === undefined) {
                throw new RequiredError('contentItemId','Required parameter contentItemId was null or undefined when calling moveContentItemToApplicationFeature.');
            }
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling moveContentItemToApplicationFeature.');
            }
            const localVarPath = `/api/QuestionAnswer/{contentItemId}/MoveToFeature/{applicationFeatureId}`
                .replace(`{${"contentItemId"}}`, encodeURIComponent(String(contentItemId)))
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling removeUserDefinedParameter.');
            }
            // verify required parameter 'parameterName' is not null or undefined
            if (parameterName === null || parameterName === undefined) {
                throw new RequiredError('parameterName','Required parameter parameterName was null or undefined when calling removeUserDefinedParameter.');
            }
            const localVarPath = `/api/QuestionAnswer/webhook/{instanceWebhookId}/userParameters/{parameterName}`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)))
                .replace(`{${"parameterName"}}`, encodeURIComponent(String(parameterName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a webhook from a question answer item
         * @param {string} questionAnswerWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(questionAnswerWebhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'questionAnswerWebhookId' is not null or undefined
            if (questionAnswerWebhookId === null || questionAnswerWebhookId === undefined) {
                throw new RequiredError('questionAnswerWebhookId','Required parameter questionAnswerWebhookId was null or undefined when calling removeWebhook.');
            }
            const localVarPath = `/api/QuestionAnswer/webhook/{questionAnswerWebhookId}`
                .replace(`{${"questionAnswerWebhookId"}}`, encodeURIComponent(String(questionAnswerWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggles whether the given FAQ is live or not
         * @param {string} questionAnswerId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleIsLive(questionAnswerId: string, model?: ToggleLiveRequest, options: any = {}): FetchArgs {
            // verify required parameter 'questionAnswerId' is not null or undefined
            if (questionAnswerId === null || questionAnswerId === undefined) {
                throw new RequiredError('questionAnswerId','Required parameter questionAnswerId was null or undefined when calling toggleIsLive.');
            }
            const localVarPath = `/api/QuestionAnswer/{questionAnswerId}/isLive`
                .replace(`{${"questionAnswerId"}}`, encodeURIComponent(String(questionAnswerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ToggleLiveRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a webhook on a question answer item
         * @param {string} questionAnswerId 
         * @param {string} instanceWebhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(questionAnswerId: string, instanceWebhookId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'questionAnswerId' is not null or undefined
            if (questionAnswerId === null || questionAnswerId === undefined) {
                throw new RequiredError('questionAnswerId','Required parameter questionAnswerId was null or undefined when calling updateAttachedWebhook.');
            }
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateAttachedWebhook.');
            }
            const localVarPath = `/api/QuestionAnswer/{questionAnswerId}/webhooks/{instanceWebhookId}`
                .replace(`{${"questionAnswerId"}}`, encodeURIComponent(String(questionAnswerId)))
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {QuestionAnswerModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: QuestionAnswerModel, options: any = {}): FetchArgs {
            // verify required parameter 'contentItemId' is not null or undefined
            if (contentItemId === null || contentItemId === undefined) {
                throw new RequiredError('contentItemId','Required parameter contentItemId was null or undefined when calling updateFullContentItem.');
            }
            const localVarPath = `/api/QuestionAnswer/{contentItemId}/full`
                .replace(`{${"contentItemId"}}`, encodeURIComponent(String(contentItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"QuestionAnswerModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateUserDefinedParameter.');
            }
            const localVarPath = `/api/QuestionAnswer/webhook/{instanceWebhookId}/userParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDefinedWebhookParameterUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateWebhookParameter.');
            }
            const localVarPath = `/api/QuestionAnswer/webhook/{instanceWebhookId}/webhookParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParameterUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuestionAnswerApi - functional programming interface
 * @export
 */
export const QuestionAnswerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete an FAQ
         * @param {string} questionAnswerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(questionAnswerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuestionAnswerModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration)._delete(questionAnswerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds an audio file to the answer message
         * @param {string} answerMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFileImage(answerMessageId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AnswerModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).addAudioFileImage(answerMessageId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a large image to the answer message
         * @param {string} answerMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(answerMessageId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AnswerModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).addLargeImage(answerMessageId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds required user phrases to a quesiton answer item.
         * @param {string} contentItemId 
         * @param {RequiredPhrasesRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrUpdateRequiredPhrases(contentItemId: string, request?: RequiredPhrasesRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuestionAnswerModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).addOrUpdateRequiredPhrases(contentItemId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a small image to the answer message
         * @param {string} answerMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(answerMessageId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AnswerModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).addSmallImage(answerMessageId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a video file to the answer message
         * @param {string} answerMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(answerMessageId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AnswerModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).addVideoFile(answerMessageId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Add a webhook to a question answer item
         * @param {string} questionAnswerId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(questionAnswerId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuestionAnswerWebhookModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).addWebhook(questionAnswerId, webhookId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Bulk updates the question answer and the internal variations
         * @param {string} questionAnswerId 
         * @param {BulkQuestionAnswerUpdateRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdate(questionAnswerId: string, model?: BulkQuestionAnswerUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuestionAnswerModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).bulkUpdate(questionAnswerId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Bulk updates the question answer and the internal variations
         * @param {string} questionAnswerId 
         * @param {BulkQuestionAnswerUpdateStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateStub(questionAnswerId: string, model?: BulkQuestionAnswerUpdateStubRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuestionAnswerModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).bulkUpdateStub(questionAnswerId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} questionAnswerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(questionAnswerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuestionAnswerModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).copyContentItem(questionAnswerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the content for the given application feature with skip/take
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countByApplicationFeature(applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<number> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).countByApplicationFeature(applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a new FAQ
         * @param {NewQuestionAnswerRequest} [model] Initial question and answer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(model?: NewQuestionAnswerRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuestionAnswerModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).create(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Add an answer to the FAQ set
         * @param {string} questionAnswerId 
         * @param {CreateAnswerRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnswer(questionAnswerId: string, model?: CreateAnswerRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AnswerModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).createAnswer(questionAnswerId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {QuestionAnswerModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: QuestionAnswerModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuestionAnswerModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).createFullContentItem(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Add a question to the FAQ set
         * @param {string} questionAnswerId 
         * @param {CreateQuestionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestion(questionAnswerId: string, model?: CreateQuestionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuestionModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).createQuestion(questionAnswerId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create a new FAQ
         * @param {NewQuestionAnswerStubRequest} [model] Initial question and answer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStub(model?: NewQuestionAnswerStubRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuestionAnswerModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).createStub(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).createUserDefinedParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete an answer
         * @param {string} answerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnswer(answerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AnswerModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).deleteAnswer(answerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a question
         * @param {string} questionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestion(questionId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuestionModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).deleteQuestion(questionId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Edit a given Answer
         * @param {string} answerId 
         * @param {UpdateAnswerRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAnswer(answerId: string, model?: UpdateAnswerRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AnswerModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).editAnswer(answerId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Edit a given question
         * @param {string} questionId 
         * @param {UpdateQuestionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editQuestion(questionId: string, model?: UpdateQuestionRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuestionModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).editQuestion(questionId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuestionAnswerModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).findFullById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get an FAQ by its ID
         * @param {string} questionAnswerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(questionAnswerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuestionAnswerModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).get(questionAnswerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllByApplicationFeature(applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<QuestionAnswerModel>> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).getAllByApplicationFeature(applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the content for the given application feature with skip/take
         * @param {string} applicationFeatureId 
         * @param {string} [sortBy] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, sortBy?: string, skip?: number, take?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<QuestionAnswerModel>> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).getByApplicationFeature(applicationFeatureId, sortBy, skip, take, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the FAQs for a given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionAnswersForApplication(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<QuestionAnswerModel>> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).getQuestionAnswersForApplication(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the webhooks associated with a question answer item
         * @param {string} questionAnswerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(questionAnswerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<QuestionAnswerWebhookModel>> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).getWebhooks(questionAnswerId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuestionAnswerModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete a webhook from a question answer item
         * @param {string} questionAnswerWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(questionAnswerWebhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuestionAnswerWebhookModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).removeWebhook(questionAnswerWebhookId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Toggles whether the given FAQ is live or not
         * @param {string} questionAnswerId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleIsLive(questionAnswerId: string, model?: ToggleLiveRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuestionAnswerModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).toggleIsLive(questionAnswerId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update a webhook on a question answer item
         * @param {string} questionAnswerId 
         * @param {string} instanceWebhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(questionAnswerId: string, instanceWebhookId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuestionAnswerWebhookModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).updateAttachedWebhook(questionAnswerId, instanceWebhookId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {QuestionAnswerModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: QuestionAnswerModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<QuestionAnswerModel> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).updateFullContentItem(contentItemId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).updateUserDefinedParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = QuestionAnswerApiFetchParamCreator(configuration).updateWebhookParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * QuestionAnswerApi - factory interface
 * @export
 */
export const QuestionAnswerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Delete an FAQ
         * @param {string} questionAnswerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(questionAnswerId: string, options?: any) {
            return QuestionAnswerApiFp(configuration)._delete(questionAnswerId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds an audio file to the answer message
         * @param {string} answerMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFileImage(answerMessageId: string, mediaItemId: string, options?: any) {
            return QuestionAnswerApiFp(configuration).addAudioFileImage(answerMessageId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a large image to the answer message
         * @param {string} answerMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(answerMessageId: string, mediaItemId: string, options?: any) {
            return QuestionAnswerApiFp(configuration).addLargeImage(answerMessageId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds required user phrases to a quesiton answer item.
         * @param {string} contentItemId 
         * @param {RequiredPhrasesRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrUpdateRequiredPhrases(contentItemId: string, request?: RequiredPhrasesRequest, options?: any) {
            return QuestionAnswerApiFp(configuration).addOrUpdateRequiredPhrases(contentItemId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a small image to the answer message
         * @param {string} answerMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(answerMessageId: string, mediaItemId: string, options?: any) {
            return QuestionAnswerApiFp(configuration).addSmallImage(answerMessageId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a video file to the answer message
         * @param {string} answerMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(answerMessageId: string, mediaItemId: string, options?: any) {
            return QuestionAnswerApiFp(configuration).addVideoFile(answerMessageId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add a webhook to a question answer item
         * @param {string} questionAnswerId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(questionAnswerId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
            return QuestionAnswerApiFp(configuration).addWebhook(questionAnswerId, webhookId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Bulk updates the question answer and the internal variations
         * @param {string} questionAnswerId 
         * @param {BulkQuestionAnswerUpdateRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdate(questionAnswerId: string, model?: BulkQuestionAnswerUpdateRequest, options?: any) {
            return QuestionAnswerApiFp(configuration).bulkUpdate(questionAnswerId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Bulk updates the question answer and the internal variations
         * @param {string} questionAnswerId 
         * @param {BulkQuestionAnswerUpdateStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateStub(questionAnswerId: string, model?: BulkQuestionAnswerUpdateStubRequest, options?: any) {
            return QuestionAnswerApiFp(configuration).bulkUpdateStub(questionAnswerId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} questionAnswerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(questionAnswerId: string, options?: any) {
            return QuestionAnswerApiFp(configuration).copyContentItem(questionAnswerId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the content for the given application feature with skip/take
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countByApplicationFeature(applicationFeatureId: string, options?: any) {
            return QuestionAnswerApiFp(configuration).countByApplicationFeature(applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new FAQ
         * @param {NewQuestionAnswerRequest} [model] Initial question and answer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(model?: NewQuestionAnswerRequest, options?: any) {
            return QuestionAnswerApiFp(configuration).create(model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add an answer to the FAQ set
         * @param {string} questionAnswerId 
         * @param {CreateAnswerRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnswer(questionAnswerId: string, model?: CreateAnswerRequest, options?: any) {
            return QuestionAnswerApiFp(configuration).createAnswer(questionAnswerId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {QuestionAnswerModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: QuestionAnswerModel, options?: any) {
            return QuestionAnswerApiFp(configuration).createFullContentItem(model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Add a question to the FAQ set
         * @param {string} questionAnswerId 
         * @param {CreateQuestionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createQuestion(questionAnswerId: string, model?: CreateQuestionRequest, options?: any) {
            return QuestionAnswerApiFp(configuration).createQuestion(questionAnswerId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create a new FAQ
         * @param {NewQuestionAnswerStubRequest} [model] Initial question and answer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStub(model?: NewQuestionAnswerStubRequest, options?: any) {
            return QuestionAnswerApiFp(configuration).createStub(model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any) {
            return QuestionAnswerApiFp(configuration).createUserDefinedParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete an answer
         * @param {string} answerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnswer(answerId: string, options?: any) {
            return QuestionAnswerApiFp(configuration).deleteAnswer(answerId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a question
         * @param {string} questionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteQuestion(questionId: string, options?: any) {
            return QuestionAnswerApiFp(configuration).deleteQuestion(questionId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Edit a given Answer
         * @param {string} answerId 
         * @param {UpdateAnswerRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editAnswer(answerId: string, model?: UpdateAnswerRequest, options?: any) {
            return QuestionAnswerApiFp(configuration).editAnswer(answerId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Edit a given question
         * @param {string} questionId 
         * @param {UpdateQuestionRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editQuestion(questionId: string, model?: UpdateQuestionRequest, options?: any) {
            return QuestionAnswerApiFp(configuration).editQuestion(questionId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options?: any) {
            return QuestionAnswerApiFp(configuration).findFullById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get an FAQ by its ID
         * @param {string} questionAnswerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(questionAnswerId: string, options?: any) {
            return QuestionAnswerApiFp(configuration).get(questionAnswerId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllByApplicationFeature(applicationFeatureId: string, options?: any) {
            return QuestionAnswerApiFp(configuration).getAllByApplicationFeature(applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the content for the given application feature with skip/take
         * @param {string} applicationFeatureId 
         * @param {string} [sortBy] 
         * @param {number} [skip] 
         * @param {number} [take] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, sortBy?: string, skip?: number, take?: number, options?: any) {
            return QuestionAnswerApiFp(configuration).getByApplicationFeature(applicationFeatureId, sortBy, skip, take, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the FAQs for a given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQuestionAnswersForApplication(applicationId: string, options?: any) {
            return QuestionAnswerApiFp(configuration).getQuestionAnswersForApplication(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the webhooks associated with a question answer item
         * @param {string} questionAnswerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(questionAnswerId: string, options?: any) {
            return QuestionAnswerApiFp(configuration).getWebhooks(questionAnswerId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any) {
            return QuestionAnswerApiFp(configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any) {
            return QuestionAnswerApiFp(configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete a webhook from a question answer item
         * @param {string} questionAnswerWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(questionAnswerWebhookId: string, options?: any) {
            return QuestionAnswerApiFp(configuration).removeWebhook(questionAnswerWebhookId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Toggles whether the given FAQ is live or not
         * @param {string} questionAnswerId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleIsLive(questionAnswerId: string, model?: ToggleLiveRequest, options?: any) {
            return QuestionAnswerApiFp(configuration).toggleIsLive(questionAnswerId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update a webhook on a question answer item
         * @param {string} questionAnswerId 
         * @param {string} instanceWebhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(questionAnswerId: string, instanceWebhookId: string, parameters?: WebhookParametersRequest, options?: any) {
            return QuestionAnswerApiFp(configuration).updateAttachedWebhook(questionAnswerId, instanceWebhookId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {QuestionAnswerModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: QuestionAnswerModel, options?: any) {
            return QuestionAnswerApiFp(configuration).updateFullContentItem(contentItemId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any) {
            return QuestionAnswerApiFp(configuration).updateUserDefinedParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any) {
            return QuestionAnswerApiFp(configuration).updateWebhookParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
    };
};

/**
 * QuestionAnswerApi - interface
 * @export
 * @interface QuestionAnswerApi
 */
export interface QuestionAnswerApiInterface {
    /**
     * 
     * @summary Delete an FAQ
     * @param {string} questionAnswerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    _delete(questionAnswerId: string, options?: any): Promise<QuestionAnswerModel>;

    /**
     * 
     * @summary Adds an audio file to the answer message
     * @param {string} answerMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    addAudioFileImage(answerMessageId: string, mediaItemId: string, options?: any): Promise<AnswerModel>;

    /**
     * 
     * @summary Adds a large image to the answer message
     * @param {string} answerMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    addLargeImage(answerMessageId: string, mediaItemId: string, options?: any): Promise<AnswerModel>;

    /**
     * 
     * @summary Adds required user phrases to a quesiton answer item.
     * @param {string} contentItemId 
     * @param {RequiredPhrasesRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    addOrUpdateRequiredPhrases(contentItemId: string, request?: RequiredPhrasesRequest, options?: any): Promise<QuestionAnswerModel>;

    /**
     * 
     * @summary Adds a small image to the answer message
     * @param {string} answerMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    addSmallImage(answerMessageId: string, mediaItemId: string, options?: any): Promise<AnswerModel>;

    /**
     * 
     * @summary Adds a video file to the answer message
     * @param {string} answerMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    addVideoFile(answerMessageId: string, mediaItemId: string, options?: any): Promise<AnswerModel>;

    /**
     * 
     * @summary Add a webhook to a question answer item
     * @param {string} questionAnswerId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    addWebhook(questionAnswerId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): Promise<QuestionAnswerWebhookModel>;

    /**
     * 
     * @summary Bulk updates the question answer and the internal variations
     * @param {string} questionAnswerId 
     * @param {BulkQuestionAnswerUpdateRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    bulkUpdate(questionAnswerId: string, model?: BulkQuestionAnswerUpdateRequest, options?: any): Promise<QuestionAnswerModel>;

    /**
     * 
     * @summary Bulk updates the question answer and the internal variations
     * @param {string} questionAnswerId 
     * @param {BulkQuestionAnswerUpdateStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    bulkUpdateStub(questionAnswerId: string, model?: BulkQuestionAnswerUpdateStubRequest, options?: any): Promise<QuestionAnswerModel>;

    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param {string} questionAnswerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    copyContentItem(questionAnswerId: string, options?: any): Promise<QuestionAnswerModel>;

    /**
     * 
     * @summary Gets the content for the given application feature with skip/take
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    countByApplicationFeature(applicationFeatureId: string, options?: any): Promise<number>;

    /**
     * 
     * @summary Create a new FAQ
     * @param {NewQuestionAnswerRequest} [model] Initial question and answer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    create(model?: NewQuestionAnswerRequest, options?: any): Promise<QuestionAnswerModel>;

    /**
     * 
     * @summary Add an answer to the FAQ set
     * @param {string} questionAnswerId 
     * @param {CreateAnswerRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    createAnswer(questionAnswerId: string, model?: CreateAnswerRequest, options?: any): Promise<AnswerModel>;

    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param {QuestionAnswerModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    createFullContentItem(model?: QuestionAnswerModel, options?: any): Promise<QuestionAnswerModel>;

    /**
     * 
     * @summary Add a question to the FAQ set
     * @param {string} questionAnswerId 
     * @param {CreateQuestionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    createQuestion(questionAnswerId: string, model?: CreateQuestionRequest, options?: any): Promise<QuestionModel>;

    /**
     * 
     * @summary Create a new FAQ
     * @param {NewQuestionAnswerStubRequest} [model] Initial question and answer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    createStub(model?: NewQuestionAnswerStubRequest, options?: any): Promise<QuestionAnswerModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterCreateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @summary Delete an answer
     * @param {string} answerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    deleteAnswer(answerId: string, options?: any): Promise<AnswerModel>;

    /**
     * 
     * @summary Delete a question
     * @param {string} questionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    deleteQuestion(questionId: string, options?: any): Promise<QuestionModel>;

    /**
     * 
     * @summary Edit a given Answer
     * @param {string} answerId 
     * @param {UpdateAnswerRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    editAnswer(answerId: string, model?: UpdateAnswerRequest, options?: any): Promise<AnswerModel>;

    /**
     * 
     * @summary Edit a given question
     * @param {string} questionId 
     * @param {UpdateQuestionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    editQuestion(questionId: string, model?: UpdateQuestionRequest, options?: any): Promise<QuestionModel>;

    /**
     * 
     * @summary Finds the full content item by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    findFullById(id: string, options?: any): Promise<QuestionAnswerModel>;

    /**
     * 
     * @summary Get an FAQ by its ID
     * @param {string} questionAnswerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    get(questionAnswerId: string, options?: any): Promise<QuestionAnswerModel>;

    /**
     * 
     * @summary Gets the content for the given application feature
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    getAllByApplicationFeature(applicationFeatureId: string, options?: any): Promise<Array<QuestionAnswerModel>>;

    /**
     * 
     * @summary Gets the content for the given application feature with skip/take
     * @param {string} applicationFeatureId 
     * @param {string} [sortBy] 
     * @param {number} [skip] 
     * @param {number} [take] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    getByApplicationFeature(applicationFeatureId: string, sortBy?: string, skip?: number, take?: number, options?: any): Promise<Array<QuestionAnswerModel>>;

    /**
     * 
     * @summary Get the FAQs for a given application
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    getQuestionAnswersForApplication(applicationId: string, options?: any): Promise<Array<QuestionAnswerModel>>;

    /**
     * 
     * @summary Get the webhooks associated with a question answer item
     * @param {string} questionAnswerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    getWebhooks(questionAnswerId: string, options?: any): Promise<Array<QuestionAnswerWebhookModel>>;

    /**
     * 
     * @param {string} contentItemId 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any): Promise<QuestionAnswerModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {string} parameterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any): Promise<boolean>;

    /**
     * 
     * @summary Delete a webhook from a question answer item
     * @param {string} questionAnswerWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    removeWebhook(questionAnswerWebhookId: string, options?: any): Promise<QuestionAnswerWebhookModel>;

    /**
     * 
     * @summary Toggles whether the given FAQ is live or not
     * @param {string} questionAnswerId 
     * @param {ToggleLiveRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    toggleIsLive(questionAnswerId: string, model?: ToggleLiveRequest, options?: any): Promise<QuestionAnswerModel>;

    /**
     * 
     * @summary Update a webhook on a question answer item
     * @param {string} questionAnswerId 
     * @param {string} instanceWebhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    updateAttachedWebhook(questionAnswerId: string, instanceWebhookId: string, parameters?: WebhookParametersRequest, options?: any): Promise<QuestionAnswerWebhookModel>;

    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param {string} contentItemId 
     * @param {QuestionAnswerModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    updateFullContentItem(contentItemId: string, model?: QuestionAnswerModel, options?: any): Promise<QuestionAnswerModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {WebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApiInterface
     */
    updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any): Promise<boolean>;

}

/**
 * QuestionAnswerApi - object-oriented interface
 * @export
 * @class QuestionAnswerApi
 * @extends {BaseAPI}
 */
export class QuestionAnswerApi extends BaseAPI implements QuestionAnswerApiInterface {
    /**
     * 
     * @summary Delete an FAQ
     * @param {string} questionAnswerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public _delete(questionAnswerId: string, options?: any) {
        return QuestionAnswerApiFp(this.configuration)._delete(questionAnswerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds an audio file to the answer message
     * @param {string} answerMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public addAudioFileImage(answerMessageId: string, mediaItemId: string, options?: any) {
        return QuestionAnswerApiFp(this.configuration).addAudioFileImage(answerMessageId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a large image to the answer message
     * @param {string} answerMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public addLargeImage(answerMessageId: string, mediaItemId: string, options?: any) {
        return QuestionAnswerApiFp(this.configuration).addLargeImage(answerMessageId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds required user phrases to a quesiton answer item.
     * @param {string} contentItemId 
     * @param {RequiredPhrasesRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public addOrUpdateRequiredPhrases(contentItemId: string, request?: RequiredPhrasesRequest, options?: any) {
        return QuestionAnswerApiFp(this.configuration).addOrUpdateRequiredPhrases(contentItemId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a small image to the answer message
     * @param {string} answerMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public addSmallImage(answerMessageId: string, mediaItemId: string, options?: any) {
        return QuestionAnswerApiFp(this.configuration).addSmallImage(answerMessageId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a video file to the answer message
     * @param {string} answerMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public addVideoFile(answerMessageId: string, mediaItemId: string, options?: any) {
        return QuestionAnswerApiFp(this.configuration).addVideoFile(answerMessageId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Add a webhook to a question answer item
     * @param {string} questionAnswerId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public addWebhook(questionAnswerId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
        return QuestionAnswerApiFp(this.configuration).addWebhook(questionAnswerId, webhookId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Bulk updates the question answer and the internal variations
     * @param {string} questionAnswerId 
     * @param {BulkQuestionAnswerUpdateRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public bulkUpdate(questionAnswerId: string, model?: BulkQuestionAnswerUpdateRequest, options?: any) {
        return QuestionAnswerApiFp(this.configuration).bulkUpdate(questionAnswerId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Bulk updates the question answer and the internal variations
     * @param {string} questionAnswerId 
     * @param {BulkQuestionAnswerUpdateStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public bulkUpdateStub(questionAnswerId: string, model?: BulkQuestionAnswerUpdateStubRequest, options?: any) {
        return QuestionAnswerApiFp(this.configuration).bulkUpdateStub(questionAnswerId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param {string} questionAnswerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public copyContentItem(questionAnswerId: string, options?: any) {
        return QuestionAnswerApiFp(this.configuration).copyContentItem(questionAnswerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the content for the given application feature with skip/take
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public countByApplicationFeature(applicationFeatureId: string, options?: any) {
        return QuestionAnswerApiFp(this.configuration).countByApplicationFeature(applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a new FAQ
     * @param {NewQuestionAnswerRequest} [model] Initial question and answer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public create(model?: NewQuestionAnswerRequest, options?: any) {
        return QuestionAnswerApiFp(this.configuration).create(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Add an answer to the FAQ set
     * @param {string} questionAnswerId 
     * @param {CreateAnswerRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public createAnswer(questionAnswerId: string, model?: CreateAnswerRequest, options?: any) {
        return QuestionAnswerApiFp(this.configuration).createAnswer(questionAnswerId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param {QuestionAnswerModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public createFullContentItem(model?: QuestionAnswerModel, options?: any) {
        return QuestionAnswerApiFp(this.configuration).createFullContentItem(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Add a question to the FAQ set
     * @param {string} questionAnswerId 
     * @param {CreateQuestionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public createQuestion(questionAnswerId: string, model?: CreateQuestionRequest, options?: any) {
        return QuestionAnswerApiFp(this.configuration).createQuestion(questionAnswerId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create a new FAQ
     * @param {NewQuestionAnswerStubRequest} [model] Initial question and answer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public createStub(model?: NewQuestionAnswerStubRequest, options?: any) {
        return QuestionAnswerApiFp(this.configuration).createStub(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterCreateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any) {
        return QuestionAnswerApiFp(this.configuration).createUserDefinedParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete an answer
     * @param {string} answerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public deleteAnswer(answerId: string, options?: any) {
        return QuestionAnswerApiFp(this.configuration).deleteAnswer(answerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a question
     * @param {string} questionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public deleteQuestion(questionId: string, options?: any) {
        return QuestionAnswerApiFp(this.configuration).deleteQuestion(questionId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Edit a given Answer
     * @param {string} answerId 
     * @param {UpdateAnswerRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public editAnswer(answerId: string, model?: UpdateAnswerRequest, options?: any) {
        return QuestionAnswerApiFp(this.configuration).editAnswer(answerId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Edit a given question
     * @param {string} questionId 
     * @param {UpdateQuestionRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public editQuestion(questionId: string, model?: UpdateQuestionRequest, options?: any) {
        return QuestionAnswerApiFp(this.configuration).editQuestion(questionId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Finds the full content item by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public findFullById(id: string, options?: any) {
        return QuestionAnswerApiFp(this.configuration).findFullById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get an FAQ by its ID
     * @param {string} questionAnswerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public get(questionAnswerId: string, options?: any) {
        return QuestionAnswerApiFp(this.configuration).get(questionAnswerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the content for the given application feature
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public getAllByApplicationFeature(applicationFeatureId: string, options?: any) {
        return QuestionAnswerApiFp(this.configuration).getAllByApplicationFeature(applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the content for the given application feature with skip/take
     * @param {string} applicationFeatureId 
     * @param {string} [sortBy] 
     * @param {number} [skip] 
     * @param {number} [take] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public getByApplicationFeature(applicationFeatureId: string, sortBy?: string, skip?: number, take?: number, options?: any) {
        return QuestionAnswerApiFp(this.configuration).getByApplicationFeature(applicationFeatureId, sortBy, skip, take, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the FAQs for a given application
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public getQuestionAnswersForApplication(applicationId: string, options?: any) {
        return QuestionAnswerApiFp(this.configuration).getQuestionAnswersForApplication(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the webhooks associated with a question answer item
     * @param {string} questionAnswerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public getWebhooks(questionAnswerId: string, options?: any) {
        return QuestionAnswerApiFp(this.configuration).getWebhooks(questionAnswerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} contentItemId 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any) {
        return QuestionAnswerApiFp(this.configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {string} parameterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any) {
        return QuestionAnswerApiFp(this.configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete a webhook from a question answer item
     * @param {string} questionAnswerWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public removeWebhook(questionAnswerWebhookId: string, options?: any) {
        return QuestionAnswerApiFp(this.configuration).removeWebhook(questionAnswerWebhookId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Toggles whether the given FAQ is live or not
     * @param {string} questionAnswerId 
     * @param {ToggleLiveRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public toggleIsLive(questionAnswerId: string, model?: ToggleLiveRequest, options?: any) {
        return QuestionAnswerApiFp(this.configuration).toggleIsLive(questionAnswerId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update a webhook on a question answer item
     * @param {string} questionAnswerId 
     * @param {string} instanceWebhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public updateAttachedWebhook(questionAnswerId: string, instanceWebhookId: string, parameters?: WebhookParametersRequest, options?: any) {
        return QuestionAnswerApiFp(this.configuration).updateAttachedWebhook(questionAnswerId, instanceWebhookId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param {string} contentItemId 
     * @param {QuestionAnswerModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public updateFullContentItem(contentItemId: string, model?: QuestionAnswerModel, options?: any) {
        return QuestionAnswerApiFp(this.configuration).updateFullContentItem(contentItemId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any) {
        return QuestionAnswerApiFp(this.configuration).updateUserDefinedParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {WebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuestionAnswerApi
     */
    public updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any) {
        return QuestionAnswerApiFp(this.configuration).updateWebhookParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

}

/**
 * RecipeApi - fetch parameter creator
 * @export
 */
export const RecipeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} recipeId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(recipeId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'recipeId' is not null or undefined
            if (recipeId === null || recipeId === undefined) {
                throw new RequiredError('recipeId','Required parameter recipeId was null or undefined when calling addWebhook.');
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId','Required parameter webhookId was null or undefined when calling addWebhook.');
            }
            const localVarPath = `/api/Recipe/{recipeId}/webhooks/{webhookId}`
                .replace(`{${"recipeId"}}`, encodeURIComponent(String(recipeId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} recipeId 
         * @param {BulkUpdateRecipeRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdate(recipeId: string, model?: BulkUpdateRecipeRequest, options: any = {}): FetchArgs {
            // verify required parameter 'recipeId' is not null or undefined
            if (recipeId === null || recipeId === undefined) {
                throw new RequiredError('recipeId','Required parameter recipeId was null or undefined when calling bulkUpdate.');
            }
            const localVarPath = `/api/Recipe/{recipeId}/bulkUpdate`
                .replace(`{${"recipeId"}}`, encodeURIComponent(String(recipeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkUpdateRecipeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} recipeId 
         * @param {BulkUpdateRecipeStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateStub(recipeId: string, model?: BulkUpdateRecipeStubRequest, options: any = {}): FetchArgs {
            // verify required parameter 'recipeId' is not null or undefined
            if (recipeId === null || recipeId === undefined) {
                throw new RequiredError('recipeId','Required parameter recipeId was null or undefined when calling bulkUpdateStub.');
            }
            const localVarPath = `/api/Recipe/{recipeId}/bulkUpdate/stub`
                .replace(`{${"recipeId"}}`, encodeURIComponent(String(recipeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkUpdateRecipeStubRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(recipeId: string, options: any = {}): FetchArgs {
            // verify required parameter 'recipeId' is not null or undefined
            if (recipeId === null || recipeId === undefined) {
                throw new RequiredError('recipeId','Required parameter recipeId was null or undefined when calling copyContentItem.');
            }
            const localVarPath = `/api/Recipe/{recipeId}/copy`
                .replace(`{${"recipeId"}}`, encodeURIComponent(String(recipeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {RecipeModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: RecipeModel, options: any = {}): FetchArgs {
            const localVarPath = `/api/Recipe/full`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RecipeModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateRecipeRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipe(model?: CreateRecipeRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Recipe`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateRecipeRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateRecipeStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipeStub(model?: CreateRecipeStubRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Recipe/stub`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateRecipeStubRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling createUserDefinedParameter.');
            }
            const localVarPath = `/api/Recipe/webhook/{instanceWebhookId}/userParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDefinedWebhookParameterCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecipe(recipeId: string, options: any = {}): FetchArgs {
            // verify required parameter 'recipeId' is not null or undefined
            if (recipeId === null || recipeId === undefined) {
                throw new RequiredError('recipeId','Required parameter recipeId was null or undefined when calling deleteRecipe.');
            }
            const localVarPath = `/api/Recipe/{recipeId}`
                .replace(`{${"recipeId"}}`, encodeURIComponent(String(recipeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling findFullById.');
            }
            const localVarPath = `/api/Recipe/full/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling getByApplicationFeature.');
            }
            const localVarPath = `/api/Recipe/byFeature/{applicationFeatureId}`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(recipeId: string, options: any = {}): FetchArgs {
            // verify required parameter 'recipeId' is not null or undefined
            if (recipeId === null || recipeId === undefined) {
                throw new RequiredError('recipeId','Required parameter recipeId was null or undefined when calling getWebhooks.');
            }
            const localVarPath = `/api/Recipe/{recipeId}/webhooks`
                .replace(`{${"recipeId"}}`, encodeURIComponent(String(recipeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'contentItemId' is not null or undefined
            if (contentItemId === null || contentItemId === undefined) {
                throw new RequiredError('contentItemId','Required parameter contentItemId was null or undefined when calling moveContentItemToApplicationFeature.');
            }
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling moveContentItemToApplicationFeature.');
            }
            const localVarPath = `/api/Recipe/{contentItemId}/MoveToFeature/{applicationFeatureId}`
                .replace(`{${"contentItemId"}}`, encodeURIComponent(String(contentItemId)))
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling removeUserDefinedParameter.');
            }
            // verify required parameter 'parameterName' is not null or undefined
            if (parameterName === null || parameterName === undefined) {
                throw new RequiredError('parameterName','Required parameter parameterName was null or undefined when calling removeUserDefinedParameter.');
            }
            const localVarPath = `/api/Recipe/webhook/{instanceWebhookId}/userParameters/{parameterName}`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)))
                .replace(`{${"parameterName"}}`, encodeURIComponent(String(parameterName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} recipeWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(recipeWebhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'recipeWebhookId' is not null or undefined
            if (recipeWebhookId === null || recipeWebhookId === undefined) {
                throw new RequiredError('recipeWebhookId','Required parameter recipeWebhookId was null or undefined when calling removeWebhook.');
            }
            const localVarPath = `/api/Recipe/webhook/{recipeWebhookId}`
                .replace(`{${"recipeWebhookId"}}`, encodeURIComponent(String(recipeWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} recipeId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleIsLive(recipeId: string, model?: ToggleLiveRequest, options: any = {}): FetchArgs {
            // verify required parameter 'recipeId' is not null or undefined
            if (recipeId === null || recipeId === undefined) {
                throw new RequiredError('recipeId','Required parameter recipeId was null or undefined when calling toggleIsLive.');
            }
            const localVarPath = `/api/Recipe/{recipeId}/isLive`
                .replace(`{${"recipeId"}}`, encodeURIComponent(String(recipeId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ToggleLiveRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} recipeId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(recipeId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'recipeId' is not null or undefined
            if (recipeId === null || recipeId === undefined) {
                throw new RequiredError('recipeId','Required parameter recipeId was null or undefined when calling updateAttachedWebhook.');
            }
            // verify required parameter 'webhookInstanceId' is not null or undefined
            if (webhookInstanceId === null || webhookInstanceId === undefined) {
                throw new RequiredError('webhookInstanceId','Required parameter webhookInstanceId was null or undefined when calling updateAttachedWebhook.');
            }
            const localVarPath = `/api/Recipe/{recipeId}/webhooks/{webhookInstanceId}`
                .replace(`{${"recipeId"}}`, encodeURIComponent(String(recipeId)))
                .replace(`{${"webhookInstanceId"}}`, encodeURIComponent(String(webhookInstanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {RecipeModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: RecipeModel, options: any = {}): FetchArgs {
            // verify required parameter 'contentItemId' is not null or undefined
            if (contentItemId === null || contentItemId === undefined) {
                throw new RequiredError('contentItemId','Required parameter contentItemId was null or undefined when calling updateFullContentItem.');
            }
            const localVarPath = `/api/Recipe/{contentItemId}/full`
                .replace(`{${"contentItemId"}}`, encodeURIComponent(String(contentItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RecipeModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateUserDefinedParameter.');
            }
            const localVarPath = `/api/Recipe/webhook/{instanceWebhookId}/userParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDefinedWebhookParameterUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateWebhookParameter.');
            }
            const localVarPath = `/api/Recipe/webhook/{instanceWebhookId}/webhookParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParameterUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecipeApi - functional programming interface
 * @export
 */
export const RecipeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} recipeId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(recipeId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RecipeWebhookModel> {
            const localVarFetchArgs = RecipeApiFetchParamCreator(configuration).addWebhook(recipeId, webhookId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} recipeId 
         * @param {BulkUpdateRecipeRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdate(recipeId: string, model?: BulkUpdateRecipeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RecipeModel> {
            const localVarFetchArgs = RecipeApiFetchParamCreator(configuration).bulkUpdate(recipeId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} recipeId 
         * @param {BulkUpdateRecipeStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateStub(recipeId: string, model?: BulkUpdateRecipeStubRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RecipeModel> {
            const localVarFetchArgs = RecipeApiFetchParamCreator(configuration).bulkUpdateStub(recipeId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(recipeId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RecipeModel> {
            const localVarFetchArgs = RecipeApiFetchParamCreator(configuration).copyContentItem(recipeId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {RecipeModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: RecipeModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RecipeModel> {
            const localVarFetchArgs = RecipeApiFetchParamCreator(configuration).createFullContentItem(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CreateRecipeRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipe(model?: CreateRecipeRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RecipeModel> {
            const localVarFetchArgs = RecipeApiFetchParamCreator(configuration).createRecipe(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {CreateRecipeStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipeStub(model?: CreateRecipeStubRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RecipeModel> {
            const localVarFetchArgs = RecipeApiFetchParamCreator(configuration).createRecipeStub(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = RecipeApiFetchParamCreator(configuration).createUserDefinedParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecipe(recipeId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RecipeModel> {
            const localVarFetchArgs = RecipeApiFetchParamCreator(configuration).deleteRecipe(recipeId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RecipeModel> {
            const localVarFetchArgs = RecipeApiFetchParamCreator(configuration).findFullById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RecipeModel>> {
            const localVarFetchArgs = RecipeApiFetchParamCreator(configuration).getByApplicationFeature(applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(recipeId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RecipeWebhookModel> {
            const localVarFetchArgs = RecipeApiFetchParamCreator(configuration).getWebhooks(recipeId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RecipeModel> {
            const localVarFetchArgs = RecipeApiFetchParamCreator(configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = RecipeApiFetchParamCreator(configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} recipeWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(recipeWebhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RecipeWebhookModel> {
            const localVarFetchArgs = RecipeApiFetchParamCreator(configuration).removeWebhook(recipeWebhookId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} recipeId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleIsLive(recipeId: string, model?: ToggleLiveRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RecipeModel> {
            const localVarFetchArgs = RecipeApiFetchParamCreator(configuration).toggleIsLive(recipeId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} recipeId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(recipeId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RecipeWebhookModel> {
            const localVarFetchArgs = RecipeApiFetchParamCreator(configuration).updateAttachedWebhook(recipeId, webhookInstanceId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {RecipeModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: RecipeModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RecipeModel> {
            const localVarFetchArgs = RecipeApiFetchParamCreator(configuration).updateFullContentItem(contentItemId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = RecipeApiFetchParamCreator(configuration).updateUserDefinedParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = RecipeApiFetchParamCreator(configuration).updateWebhookParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RecipeApi - factory interface
 * @export
 */
export const RecipeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} recipeId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(recipeId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
            return RecipeApiFp(configuration).addWebhook(recipeId, webhookId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} recipeId 
         * @param {BulkUpdateRecipeRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdate(recipeId: string, model?: BulkUpdateRecipeRequest, options?: any) {
            return RecipeApiFp(configuration).bulkUpdate(recipeId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} recipeId 
         * @param {BulkUpdateRecipeStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateStub(recipeId: string, model?: BulkUpdateRecipeStubRequest, options?: any) {
            return RecipeApiFp(configuration).bulkUpdateStub(recipeId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(recipeId: string, options?: any) {
            return RecipeApiFp(configuration).copyContentItem(recipeId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {RecipeModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: RecipeModel, options?: any) {
            return RecipeApiFp(configuration).createFullContentItem(model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CreateRecipeRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipe(model?: CreateRecipeRequest, options?: any) {
            return RecipeApiFp(configuration).createRecipe(model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {CreateRecipeStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipeStub(model?: CreateRecipeStubRequest, options?: any) {
            return RecipeApiFp(configuration).createRecipeStub(model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any) {
            return RecipeApiFp(configuration).createUserDefinedParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRecipe(recipeId: string, options?: any) {
            return RecipeApiFp(configuration).deleteRecipe(recipeId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options?: any) {
            return RecipeApiFp(configuration).findFullById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options?: any) {
            return RecipeApiFp(configuration).getByApplicationFeature(applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(recipeId: string, options?: any) {
            return RecipeApiFp(configuration).getWebhooks(recipeId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any) {
            return RecipeApiFp(configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any) {
            return RecipeApiFp(configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} recipeWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(recipeWebhookId: string, options?: any) {
            return RecipeApiFp(configuration).removeWebhook(recipeWebhookId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} recipeId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleIsLive(recipeId: string, model?: ToggleLiveRequest, options?: any) {
            return RecipeApiFp(configuration).toggleIsLive(recipeId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} recipeId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(recipeId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any) {
            return RecipeApiFp(configuration).updateAttachedWebhook(recipeId, webhookInstanceId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {RecipeModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: RecipeModel, options?: any) {
            return RecipeApiFp(configuration).updateFullContentItem(contentItemId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any) {
            return RecipeApiFp(configuration).updateUserDefinedParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any) {
            return RecipeApiFp(configuration).updateWebhookParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
    };
};

/**
 * RecipeApi - interface
 * @export
 * @interface RecipeApi
 */
export interface RecipeApiInterface {
    /**
     * 
     * @param {string} recipeId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApiInterface
     */
    addWebhook(recipeId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): Promise<RecipeWebhookModel>;

    /**
     * 
     * @param {string} recipeId 
     * @param {BulkUpdateRecipeRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApiInterface
     */
    bulkUpdate(recipeId: string, model?: BulkUpdateRecipeRequest, options?: any): Promise<RecipeModel>;

    /**
     * 
     * @param {string} recipeId 
     * @param {BulkUpdateRecipeStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApiInterface
     */
    bulkUpdateStub(recipeId: string, model?: BulkUpdateRecipeStubRequest, options?: any): Promise<RecipeModel>;

    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param {string} recipeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApiInterface
     */
    copyContentItem(recipeId: string, options?: any): Promise<RecipeModel>;

    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param {RecipeModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApiInterface
     */
    createFullContentItem(model?: RecipeModel, options?: any): Promise<RecipeModel>;

    /**
     * 
     * @param {CreateRecipeRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApiInterface
     */
    createRecipe(model?: CreateRecipeRequest, options?: any): Promise<RecipeModel>;

    /**
     * 
     * @param {CreateRecipeStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApiInterface
     */
    createRecipeStub(model?: CreateRecipeStubRequest, options?: any): Promise<RecipeModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterCreateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApiInterface
     */
    createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} recipeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApiInterface
     */
    deleteRecipe(recipeId: string, options?: any): Promise<RecipeModel>;

    /**
     * 
     * @summary Finds the full content item by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApiInterface
     */
    findFullById(id: string, options?: any): Promise<RecipeModel>;

    /**
     * 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApiInterface
     */
    getByApplicationFeature(applicationFeatureId: string, options?: any): Promise<Array<RecipeModel>>;

    /**
     * 
     * @param {string} recipeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApiInterface
     */
    getWebhooks(recipeId: string, options?: any): Promise<RecipeWebhookModel>;

    /**
     * 
     * @param {string} contentItemId 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApiInterface
     */
    moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any): Promise<RecipeModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {string} parameterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApiInterface
     */
    removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} recipeWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApiInterface
     */
    removeWebhook(recipeWebhookId: string, options?: any): Promise<RecipeWebhookModel>;

    /**
     * 
     * @param {string} recipeId 
     * @param {ToggleLiveRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApiInterface
     */
    toggleIsLive(recipeId: string, model?: ToggleLiveRequest, options?: any): Promise<RecipeModel>;

    /**
     * 
     * @param {string} recipeId 
     * @param {string} webhookInstanceId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApiInterface
     */
    updateAttachedWebhook(recipeId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any): Promise<RecipeWebhookModel>;

    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param {string} contentItemId 
     * @param {RecipeModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApiInterface
     */
    updateFullContentItem(contentItemId: string, model?: RecipeModel, options?: any): Promise<RecipeModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApiInterface
     */
    updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {WebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApiInterface
     */
    updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any): Promise<boolean>;

}

/**
 * RecipeApi - object-oriented interface
 * @export
 * @class RecipeApi
 * @extends {BaseAPI}
 */
export class RecipeApi extends BaseAPI implements RecipeApiInterface {
    /**
     * 
     * @param {string} recipeId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public addWebhook(recipeId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
        return RecipeApiFp(this.configuration).addWebhook(recipeId, webhookId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} recipeId 
     * @param {BulkUpdateRecipeRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public bulkUpdate(recipeId: string, model?: BulkUpdateRecipeRequest, options?: any) {
        return RecipeApiFp(this.configuration).bulkUpdate(recipeId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} recipeId 
     * @param {BulkUpdateRecipeStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public bulkUpdateStub(recipeId: string, model?: BulkUpdateRecipeStubRequest, options?: any) {
        return RecipeApiFp(this.configuration).bulkUpdateStub(recipeId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param {string} recipeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public copyContentItem(recipeId: string, options?: any) {
        return RecipeApiFp(this.configuration).copyContentItem(recipeId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param {RecipeModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public createFullContentItem(model?: RecipeModel, options?: any) {
        return RecipeApiFp(this.configuration).createFullContentItem(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CreateRecipeRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public createRecipe(model?: CreateRecipeRequest, options?: any) {
        return RecipeApiFp(this.configuration).createRecipe(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {CreateRecipeStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public createRecipeStub(model?: CreateRecipeStubRequest, options?: any) {
        return RecipeApiFp(this.configuration).createRecipeStub(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterCreateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any) {
        return RecipeApiFp(this.configuration).createUserDefinedParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} recipeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public deleteRecipe(recipeId: string, options?: any) {
        return RecipeApiFp(this.configuration).deleteRecipe(recipeId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Finds the full content item by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public findFullById(id: string, options?: any) {
        return RecipeApiFp(this.configuration).findFullById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public getByApplicationFeature(applicationFeatureId: string, options?: any) {
        return RecipeApiFp(this.configuration).getByApplicationFeature(applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} recipeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public getWebhooks(recipeId: string, options?: any) {
        return RecipeApiFp(this.configuration).getWebhooks(recipeId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} contentItemId 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any) {
        return RecipeApiFp(this.configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {string} parameterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any) {
        return RecipeApiFp(this.configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} recipeWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public removeWebhook(recipeWebhookId: string, options?: any) {
        return RecipeApiFp(this.configuration).removeWebhook(recipeWebhookId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} recipeId 
     * @param {ToggleLiveRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public toggleIsLive(recipeId: string, model?: ToggleLiveRequest, options?: any) {
        return RecipeApiFp(this.configuration).toggleIsLive(recipeId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} recipeId 
     * @param {string} webhookInstanceId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public updateAttachedWebhook(recipeId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any) {
        return RecipeApiFp(this.configuration).updateAttachedWebhook(recipeId, webhookInstanceId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param {string} contentItemId 
     * @param {RecipeModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public updateFullContentItem(contentItemId: string, model?: RecipeModel, options?: any) {
        return RecipeApiFp(this.configuration).updateFullContentItem(contentItemId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any) {
        return RecipeApiFp(this.configuration).updateUserDefinedParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {WebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecipeApi
     */
    public updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any) {
        return RecipeApiFp(this.configuration).updateWebhookParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

}

/**
 * RepromptApi - fetch parameter creator
 * @export
 */
export const RepromptApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {CreateRepromptRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReprompt(applicationId: string, model?: CreateRepromptRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling createReprompt.');
            }
            const localVarPath = `/api/Reprompt/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateRepromptRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} repromptId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReprompt(repromptId: string, options: any = {}): FetchArgs {
            // verify required parameter 'repromptId' is not null or undefined
            if (repromptId === null || repromptId === undefined) {
                throw new RequiredError('repromptId','Required parameter repromptId was null or undefined when calling deleteReprompt.');
            }
            const localVarPath = `/api/Reprompt/{repromptId}`
                .replace(`{${"repromptId"}}`, encodeURIComponent(String(repromptId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForApplication(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getForApplication.');
            }
            const localVarPath = `/api/Reprompt/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateRepromptRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReprompt(model?: UpdateRepromptRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Reprompt`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateRepromptRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RepromptApi - functional programming interface
 * @export
 */
export const RepromptApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {CreateRepromptRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReprompt(applicationId: string, model?: CreateRepromptRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RepromptModel> {
            const localVarFetchArgs = RepromptApiFetchParamCreator(configuration).createReprompt(applicationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} repromptId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReprompt(repromptId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RepromptModel> {
            const localVarFetchArgs = RepromptApiFetchParamCreator(configuration).deleteReprompt(repromptId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForApplication(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<RepromptModel>> {
            const localVarFetchArgs = RepromptApiFetchParamCreator(configuration).getForApplication(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UpdateRepromptRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReprompt(model?: UpdateRepromptRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<RepromptModel> {
            const localVarFetchArgs = RepromptApiFetchParamCreator(configuration).updateReprompt(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * RepromptApi - factory interface
 * @export
 */
export const RepromptApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} applicationId 
         * @param {CreateRepromptRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReprompt(applicationId: string, model?: CreateRepromptRequest, options?: any) {
            return RepromptApiFp(configuration).createReprompt(applicationId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} repromptId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReprompt(repromptId: string, options?: any) {
            return RepromptApiFp(configuration).deleteReprompt(repromptId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForApplication(applicationId: string, options?: any) {
            return RepromptApiFp(configuration).getForApplication(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {UpdateRepromptRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateReprompt(model?: UpdateRepromptRequest, options?: any) {
            return RepromptApiFp(configuration).updateReprompt(model, options)(fetch, basePath);
        },
    };
};

/**
 * RepromptApi - interface
 * @export
 * @interface RepromptApi
 */
export interface RepromptApiInterface {
    /**
     * 
     * @param {string} applicationId 
     * @param {CreateRepromptRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepromptApiInterface
     */
    createReprompt(applicationId: string, model?: CreateRepromptRequest, options?: any): Promise<RepromptModel>;

    /**
     * 
     * @param {string} repromptId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepromptApiInterface
     */
    deleteReprompt(repromptId: string, options?: any): Promise<RepromptModel>;

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepromptApiInterface
     */
    getForApplication(applicationId: string, options?: any): Promise<Array<RepromptModel>>;

    /**
     * 
     * @param {UpdateRepromptRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepromptApiInterface
     */
    updateReprompt(model?: UpdateRepromptRequest, options?: any): Promise<RepromptModel>;

}

/**
 * RepromptApi - object-oriented interface
 * @export
 * @class RepromptApi
 * @extends {BaseAPI}
 */
export class RepromptApi extends BaseAPI implements RepromptApiInterface {
    /**
     * 
     * @param {string} applicationId 
     * @param {CreateRepromptRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepromptApi
     */
    public createReprompt(applicationId: string, model?: CreateRepromptRequest, options?: any) {
        return RepromptApiFp(this.configuration).createReprompt(applicationId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} repromptId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepromptApi
     */
    public deleteReprompt(repromptId: string, options?: any) {
        return RepromptApiFp(this.configuration).deleteReprompt(repromptId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepromptApi
     */
    public getForApplication(applicationId: string, options?: any) {
        return RepromptApiFp(this.configuration).getForApplication(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {UpdateRepromptRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RepromptApi
     */
    public updateReprompt(model?: UpdateRepromptRequest, options?: any) {
        return RepromptApiFp(this.configuration).updateReprompt(model, options)(this.fetch, this.basePath);
    }

}

/**
 * SimpleChoiceApi - fetch parameter creator
 * @export
 */
export const SimpleChoiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds an audio file to the given response
         * @param {string} simpleChoiceResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFile(simpleChoiceResponseId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'simpleChoiceResponseId' is not null or undefined
            if (simpleChoiceResponseId === null || simpleChoiceResponseId === undefined) {
                throw new RequiredError('simpleChoiceResponseId','Required parameter simpleChoiceResponseId was null or undefined when calling addAudioFile.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addAudioFile.');
            }
            const localVarPath = `/api/SimpleChoice/{simpleChoiceResponseId}/addAudioFile/{mediaItemId}`
                .replace(`{${"simpleChoiceResponseId"}}`, encodeURIComponent(String(simpleChoiceResponseId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a large image to the given response
         * @param {string} simpleChoiceResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(simpleChoiceResponseId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'simpleChoiceResponseId' is not null or undefined
            if (simpleChoiceResponseId === null || simpleChoiceResponseId === undefined) {
                throw new RequiredError('simpleChoiceResponseId','Required parameter simpleChoiceResponseId was null or undefined when calling addLargeImage.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addLargeImage.');
            }
            const localVarPath = `/api/SimpleChoice/{simpleChoiceResponseId}/addLargeImage/{mediaItemId}`
                .replace(`{${"simpleChoiceResponseId"}}`, encodeURIComponent(String(simpleChoiceResponseId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a small image item to the given response
         * @param {string} simpleChoiceResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(simpleChoiceResponseId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'simpleChoiceResponseId' is not null or undefined
            if (simpleChoiceResponseId === null || simpleChoiceResponseId === undefined) {
                throw new RequiredError('simpleChoiceResponseId','Required parameter simpleChoiceResponseId was null or undefined when calling addSmallImage.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addSmallImage.');
            }
            const localVarPath = `/api/SimpleChoice/{simpleChoiceResponseId}/addSmallImage/{mediaItemId}`
                .replace(`{${"simpleChoiceResponseId"}}`, encodeURIComponent(String(simpleChoiceResponseId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a video file to the given response
         * @param {string} simpleChoiceResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(simpleChoiceResponseId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'simpleChoiceResponseId' is not null or undefined
            if (simpleChoiceResponseId === null || simpleChoiceResponseId === undefined) {
                throw new RequiredError('simpleChoiceResponseId','Required parameter simpleChoiceResponseId was null or undefined when calling addVideoFile.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addVideoFile.');
            }
            const localVarPath = `/api/SimpleChoice/{simpleChoiceResponseId}/addVideoFile/{mediaItemId}`
                .replace(`{${"simpleChoiceResponseId"}}`, encodeURIComponent(String(simpleChoiceResponseId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} simpleChoiceId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(simpleChoiceId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'simpleChoiceId' is not null or undefined
            if (simpleChoiceId === null || simpleChoiceId === undefined) {
                throw new RequiredError('simpleChoiceId','Required parameter simpleChoiceId was null or undefined when calling addWebhook.');
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId','Required parameter webhookId was null or undefined when calling addWebhook.');
            }
            const localVarPath = `/api/SimpleChoice/{simpleChoiceId}/webhooks/{webhookId}`
                .replace(`{${"simpleChoiceId"}}`, encodeURIComponent(String(simpleChoiceId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} simpleChoiceId 
         * @param {BulkUpdateSimpleChoiceRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateSimpleChoice(simpleChoiceId: string, model?: BulkUpdateSimpleChoiceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'simpleChoiceId' is not null or undefined
            if (simpleChoiceId === null || simpleChoiceId === undefined) {
                throw new RequiredError('simpleChoiceId','Required parameter simpleChoiceId was null or undefined when calling bulkUpdateSimpleChoice.');
            }
            const localVarPath = `/api/SimpleChoice/{simpleChoiceId}/bulkUpdate`
                .replace(`{${"simpleChoiceId"}}`, encodeURIComponent(String(simpleChoiceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkUpdateSimpleChoiceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} simpleChoiceId 
         * @param {BulkUpdateSimpleChoiceStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateSimpleChoiceStub(simpleChoiceId: string, model?: BulkUpdateSimpleChoiceStubRequest, options: any = {}): FetchArgs {
            // verify required parameter 'simpleChoiceId' is not null or undefined
            if (simpleChoiceId === null || simpleChoiceId === undefined) {
                throw new RequiredError('simpleChoiceId','Required parameter simpleChoiceId was null or undefined when calling bulkUpdateSimpleChoiceStub.');
            }
            const localVarPath = `/api/SimpleChoice/{simpleChoiceId}/bulkUpdate/stub`
                .replace(`{${"simpleChoiceId"}}`, encodeURIComponent(String(simpleChoiceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"BulkUpdateSimpleChoiceStubRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} simpleChoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(simpleChoiceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'simpleChoiceId' is not null or undefined
            if (simpleChoiceId === null || simpleChoiceId === undefined) {
                throw new RequiredError('simpleChoiceId','Required parameter simpleChoiceId was null or undefined when calling copyContentItem.');
            }
            const localVarPath = `/api/SimpleChoice/{simpleChoiceId}/copy`
                .replace(`{${"simpleChoiceId"}}`, encodeURIComponent(String(simpleChoiceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {SimpleChoiceModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: SimpleChoiceModel, options: any = {}): FetchArgs {
            const localVarPath = `/api/SimpleChoice/full`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SimpleChoiceModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new response varation for the given message
         * @param {string} simpleChoiceId 
         * @param {NewSimpleChoiceResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResponse(simpleChoiceId: string, model?: NewSimpleChoiceResponseRequest, options: any = {}): FetchArgs {
            // verify required parameter 'simpleChoiceId' is not null or undefined
            if (simpleChoiceId === null || simpleChoiceId === undefined) {
                throw new RequiredError('simpleChoiceId','Required parameter simpleChoiceId was null or undefined when calling createResponse.');
            }
            const localVarPath = `/api/SimpleChoice/{simpleChoiceId}/response`
                .replace(`{${"simpleChoiceId"}}`, encodeURIComponent(String(simpleChoiceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewSimpleChoiceResponseRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new simple choice entity
         * @param {NewSimpleChoiceRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSimpleChoice(model?: NewSimpleChoiceRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/SimpleChoice`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewSimpleChoiceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new simple choice entity
         * @param {NewSimpleChoiceStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSimpleChoiceStub(model?: NewSimpleChoiceStubRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/SimpleChoice/stub`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewSimpleChoiceStubRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling createUserDefinedParameter.');
            }
            const localVarPath = `/api/SimpleChoice/webhook/{instanceWebhookId}/userParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDefinedWebhookParameterCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes the given response
         * @param {string} simpleChoiceResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResponse(simpleChoiceResponseId: string, options: any = {}): FetchArgs {
            // verify required parameter 'simpleChoiceResponseId' is not null or undefined
            if (simpleChoiceResponseId === null || simpleChoiceResponseId === undefined) {
                throw new RequiredError('simpleChoiceResponseId','Required parameter simpleChoiceResponseId was null or undefined when calling deleteResponse.');
            }
            const localVarPath = `/api/SimpleChoice/response/{simpleChoiceResponseId}`
                .replace(`{${"simpleChoiceResponseId"}}`, encodeURIComponent(String(simpleChoiceResponseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the given simple choice
         * @param {string} simpleChoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSimpleChoice(simpleChoiceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'simpleChoiceId' is not null or undefined
            if (simpleChoiceId === null || simpleChoiceId === undefined) {
                throw new RequiredError('simpleChoiceId','Required parameter simpleChoiceId was null or undefined when calling deleteSimpleChoice.');
            }
            const localVarPath = `/api/SimpleChoice/{simpleChoiceId}`
                .replace(`{${"simpleChoiceId"}}`, encodeURIComponent(String(simpleChoiceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling findFullById.');
            }
            const localVarPath = `/api/SimpleChoice/full/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling getByApplicationFeature.');
            }
            const localVarPath = `/api/SimpleChoice/byFeature/{applicationFeatureId}`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the simple choices content for the given application  regardless of module
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesForApplication(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getMessagesForApplication.');
            }
            const localVarPath = `/api/SimpleChoice/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the simple choices for the given application module
         * @param {string} applicationModuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesForModule(applicationModuleId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationModuleId' is not null or undefined
            if (applicationModuleId === null || applicationModuleId === undefined) {
                throw new RequiredError('applicationModuleId','Required parameter applicationModuleId was null or undefined when calling getMessagesForModule.');
            }
            const localVarPath = `/api/SimpleChoice/module/{applicationModuleId}`
                .replace(`{${"applicationModuleId"}}`, encodeURIComponent(String(applicationModuleId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} simpleChoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(simpleChoiceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'simpleChoiceId' is not null or undefined
            if (simpleChoiceId === null || simpleChoiceId === undefined) {
                throw new RequiredError('simpleChoiceId','Required parameter simpleChoiceId was null or undefined when calling getWebhooks.');
            }
            const localVarPath = `/api/SimpleChoice/{simpleChoiceId}/webhooks`
                .replace(`{${"simpleChoiceId"}}`, encodeURIComponent(String(simpleChoiceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'contentItemId' is not null or undefined
            if (contentItemId === null || contentItemId === undefined) {
                throw new RequiredError('contentItemId','Required parameter contentItemId was null or undefined when calling moveContentItemToApplicationFeature.');
            }
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling moveContentItemToApplicationFeature.');
            }
            const localVarPath = `/api/SimpleChoice/{contentItemId}/MoveToFeature/{applicationFeatureId}`
                .replace(`{${"contentItemId"}}`, encodeURIComponent(String(contentItemId)))
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling removeUserDefinedParameter.');
            }
            // verify required parameter 'parameterName' is not null or undefined
            if (parameterName === null || parameterName === undefined) {
                throw new RequiredError('parameterName','Required parameter parameterName was null or undefined when calling removeUserDefinedParameter.');
            }
            const localVarPath = `/api/SimpleChoice/webhook/{instanceWebhookId}/userParameters/{parameterName}`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)))
                .replace(`{${"parameterName"}}`, encodeURIComponent(String(parameterName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} simpleChoiceWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(simpleChoiceWebhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'simpleChoiceWebhookId' is not null or undefined
            if (simpleChoiceWebhookId === null || simpleChoiceWebhookId === undefined) {
                throw new RequiredError('simpleChoiceWebhookId','Required parameter simpleChoiceWebhookId was null or undefined when calling removeWebhook.');
            }
            const localVarPath = `/api/SimpleChoice/webhook/{simpleChoiceWebhookId}`
                .replace(`{${"simpleChoiceWebhookId"}}`, encodeURIComponent(String(simpleChoiceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggles the given message as live or not
         * @param {string} simpleChoiceId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleLive(simpleChoiceId: string, model?: ToggleLiveRequest, options: any = {}): FetchArgs {
            // verify required parameter 'simpleChoiceId' is not null or undefined
            if (simpleChoiceId === null || simpleChoiceId === undefined) {
                throw new RequiredError('simpleChoiceId','Required parameter simpleChoiceId was null or undefined when calling toggleLive.');
            }
            const localVarPath = `/api/SimpleChoice/{simpleChoiceId}/isLive`
                .replace(`{${"simpleChoiceId"}}`, encodeURIComponent(String(simpleChoiceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ToggleLiveRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} simpleChoiceId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(simpleChoiceId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'simpleChoiceId' is not null or undefined
            if (simpleChoiceId === null || simpleChoiceId === undefined) {
                throw new RequiredError('simpleChoiceId','Required parameter simpleChoiceId was null or undefined when calling updateAttachedWebhook.');
            }
            // verify required parameter 'webhookInstanceId' is not null or undefined
            if (webhookInstanceId === null || webhookInstanceId === undefined) {
                throw new RequiredError('webhookInstanceId','Required parameter webhookInstanceId was null or undefined when calling updateAttachedWebhook.');
            }
            const localVarPath = `/api/SimpleChoice/{simpleChoiceId}/webhooks/{webhookInstanceId}`
                .replace(`{${"simpleChoiceId"}}`, encodeURIComponent(String(simpleChoiceId)))
                .replace(`{${"webhookInstanceId"}}`, encodeURIComponent(String(webhookInstanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {SimpleChoiceModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: SimpleChoiceModel, options: any = {}): FetchArgs {
            // verify required parameter 'contentItemId' is not null or undefined
            if (contentItemId === null || contentItemId === undefined) {
                throw new RequiredError('contentItemId','Required parameter contentItemId was null or undefined when calling updateFullContentItem.');
            }
            const localVarPath = `/api/SimpleChoice/{contentItemId}/full`
                .replace(`{${"contentItemId"}}`, encodeURIComponent(String(contentItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SimpleChoiceModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the simple choice with the given fields  If you send null or no value for fields, they won't be updated
         * @param {string} simpleChoiceId 
         * @param {UpdateSimpleChoiceRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessage(simpleChoiceId: string, model?: UpdateSimpleChoiceRequest, options: any = {}): FetchArgs {
            // verify required parameter 'simpleChoiceId' is not null or undefined
            if (simpleChoiceId === null || simpleChoiceId === undefined) {
                throw new RequiredError('simpleChoiceId','Required parameter simpleChoiceId was null or undefined when calling updateMessage.');
            }
            const localVarPath = `/api/SimpleChoice/{simpleChoiceId}`
                .replace(`{${"simpleChoiceId"}}`, encodeURIComponent(String(simpleChoiceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateSimpleChoiceRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the given response
         * @param {string} simpleChoiceResponseId 
         * @param {UpdateSimpleChoiceResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResponse(simpleChoiceResponseId: string, model?: UpdateSimpleChoiceResponseRequest, options: any = {}): FetchArgs {
            // verify required parameter 'simpleChoiceResponseId' is not null or undefined
            if (simpleChoiceResponseId === null || simpleChoiceResponseId === undefined) {
                throw new RequiredError('simpleChoiceResponseId','Required parameter simpleChoiceResponseId was null or undefined when calling updateResponse.');
            }
            const localVarPath = `/api/SimpleChoice/response/{simpleChoiceResponseId}`
                .replace(`{${"simpleChoiceResponseId"}}`, encodeURIComponent(String(simpleChoiceResponseId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateSimpleChoiceResponseRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateUserDefinedParameter.');
            }
            const localVarPath = `/api/SimpleChoice/webhook/{instanceWebhookId}/userParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDefinedWebhookParameterUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateWebhookParameter.');
            }
            const localVarPath = `/api/SimpleChoice/webhook/{instanceWebhookId}/webhookParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParameterUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SimpleChoiceApi - functional programming interface
 * @export
 */
export const SimpleChoiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds an audio file to the given response
         * @param {string} simpleChoiceResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFile(simpleChoiceResponseId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimpleChoiceResponseModel> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).addAudioFile(simpleChoiceResponseId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a large image to the given response
         * @param {string} simpleChoiceResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(simpleChoiceResponseId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimpleChoiceResponseModel> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).addLargeImage(simpleChoiceResponseId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a small image item to the given response
         * @param {string} simpleChoiceResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(simpleChoiceResponseId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimpleChoiceResponseModel> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).addSmallImage(simpleChoiceResponseId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a video file to the given response
         * @param {string} simpleChoiceResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(simpleChoiceResponseId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimpleChoiceResponseModel> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).addVideoFile(simpleChoiceResponseId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} simpleChoiceId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(simpleChoiceId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimpleChoiceWebhookModel> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).addWebhook(simpleChoiceId, webhookId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} simpleChoiceId 
         * @param {BulkUpdateSimpleChoiceRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateSimpleChoice(simpleChoiceId: string, model?: BulkUpdateSimpleChoiceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimpleChoiceModel> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).bulkUpdateSimpleChoice(simpleChoiceId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} simpleChoiceId 
         * @param {BulkUpdateSimpleChoiceStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateSimpleChoiceStub(simpleChoiceId: string, model?: BulkUpdateSimpleChoiceStubRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimpleChoiceModel> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).bulkUpdateSimpleChoiceStub(simpleChoiceId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} simpleChoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(simpleChoiceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimpleChoiceModel> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).copyContentItem(simpleChoiceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {SimpleChoiceModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: SimpleChoiceModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimpleChoiceModel> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).createFullContentItem(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new response varation for the given message
         * @param {string} simpleChoiceId 
         * @param {NewSimpleChoiceResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResponse(simpleChoiceId: string, model?: NewSimpleChoiceResponseRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimpleChoiceResponseModel> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).createResponse(simpleChoiceId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new simple choice entity
         * @param {NewSimpleChoiceRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSimpleChoice(model?: NewSimpleChoiceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimpleChoiceModel> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).createSimpleChoice(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new simple choice entity
         * @param {NewSimpleChoiceStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSimpleChoiceStub(model?: NewSimpleChoiceStubRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimpleChoiceModel> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).createSimpleChoiceStub(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).createUserDefinedParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes the given response
         * @param {string} simpleChoiceResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResponse(simpleChoiceResponseId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimpleChoiceResponseModel> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).deleteResponse(simpleChoiceResponseId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete the given simple choice
         * @param {string} simpleChoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSimpleChoice(simpleChoiceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimpleChoiceModel> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).deleteSimpleChoice(simpleChoiceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimpleChoiceModel> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).findFullById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SimpleChoiceModel>> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).getByApplicationFeature(applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the simple choices content for the given application  regardless of module
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesForApplication(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SimpleChoiceModel>> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).getMessagesForApplication(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the simple choices for the given application module
         * @param {string} applicationModuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesForModule(applicationModuleId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SimpleChoiceModel>> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).getMessagesForModule(applicationModuleId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} simpleChoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(simpleChoiceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SimpleChoiceWebhookModel>> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).getWebhooks(simpleChoiceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimpleChoiceModel> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} simpleChoiceWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(simpleChoiceWebhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimpleChoiceWebhookModel> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).removeWebhook(simpleChoiceWebhookId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Toggles the given message as live or not
         * @param {string} simpleChoiceId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleLive(simpleChoiceId: string, model?: ToggleLiveRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimpleChoiceModel> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).toggleLive(simpleChoiceId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} simpleChoiceId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(simpleChoiceId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimpleChoiceWebhookModel> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).updateAttachedWebhook(simpleChoiceId, webhookInstanceId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {SimpleChoiceModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: SimpleChoiceModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimpleChoiceModel> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).updateFullContentItem(contentItemId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the simple choice with the given fields  If you send null or no value for fields, they won't be updated
         * @param {string} simpleChoiceId 
         * @param {UpdateSimpleChoiceRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessage(simpleChoiceId: string, model?: UpdateSimpleChoiceRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimpleChoiceModel> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).updateMessage(simpleChoiceId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the given response
         * @param {string} simpleChoiceResponseId 
         * @param {UpdateSimpleChoiceResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResponse(simpleChoiceResponseId: string, model?: UpdateSimpleChoiceResponseRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SimpleChoiceResponseModel> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).updateResponse(simpleChoiceResponseId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).updateUserDefinedParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SimpleChoiceApiFetchParamCreator(configuration).updateWebhookParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SimpleChoiceApi - factory interface
 * @export
 */
export const SimpleChoiceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Adds an audio file to the given response
         * @param {string} simpleChoiceResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFile(simpleChoiceResponseId: string, mediaItemId: string, options?: any) {
            return SimpleChoiceApiFp(configuration).addAudioFile(simpleChoiceResponseId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a large image to the given response
         * @param {string} simpleChoiceResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(simpleChoiceResponseId: string, mediaItemId: string, options?: any) {
            return SimpleChoiceApiFp(configuration).addLargeImage(simpleChoiceResponseId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a small image item to the given response
         * @param {string} simpleChoiceResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(simpleChoiceResponseId: string, mediaItemId: string, options?: any) {
            return SimpleChoiceApiFp(configuration).addSmallImage(simpleChoiceResponseId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a video file to the given response
         * @param {string} simpleChoiceResponseId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(simpleChoiceResponseId: string, mediaItemId: string, options?: any) {
            return SimpleChoiceApiFp(configuration).addVideoFile(simpleChoiceResponseId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} simpleChoiceId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(simpleChoiceId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
            return SimpleChoiceApiFp(configuration).addWebhook(simpleChoiceId, webhookId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} simpleChoiceId 
         * @param {BulkUpdateSimpleChoiceRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateSimpleChoice(simpleChoiceId: string, model?: BulkUpdateSimpleChoiceRequest, options?: any) {
            return SimpleChoiceApiFp(configuration).bulkUpdateSimpleChoice(simpleChoiceId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} simpleChoiceId 
         * @param {BulkUpdateSimpleChoiceStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateSimpleChoiceStub(simpleChoiceId: string, model?: BulkUpdateSimpleChoiceStubRequest, options?: any) {
            return SimpleChoiceApiFp(configuration).bulkUpdateSimpleChoiceStub(simpleChoiceId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} simpleChoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(simpleChoiceId: string, options?: any) {
            return SimpleChoiceApiFp(configuration).copyContentItem(simpleChoiceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {SimpleChoiceModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: SimpleChoiceModel, options?: any) {
            return SimpleChoiceApiFp(configuration).createFullContentItem(model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new response varation for the given message
         * @param {string} simpleChoiceId 
         * @param {NewSimpleChoiceResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createResponse(simpleChoiceId: string, model?: NewSimpleChoiceResponseRequest, options?: any) {
            return SimpleChoiceApiFp(configuration).createResponse(simpleChoiceId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new simple choice entity
         * @param {NewSimpleChoiceRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSimpleChoice(model?: NewSimpleChoiceRequest, options?: any) {
            return SimpleChoiceApiFp(configuration).createSimpleChoice(model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new simple choice entity
         * @param {NewSimpleChoiceStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSimpleChoiceStub(model?: NewSimpleChoiceStubRequest, options?: any) {
            return SimpleChoiceApiFp(configuration).createSimpleChoiceStub(model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any) {
            return SimpleChoiceApiFp(configuration).createUserDefinedParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes the given response
         * @param {string} simpleChoiceResponseId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteResponse(simpleChoiceResponseId: string, options?: any) {
            return SimpleChoiceApiFp(configuration).deleteResponse(simpleChoiceResponseId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the given simple choice
         * @param {string} simpleChoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSimpleChoice(simpleChoiceId: string, options?: any) {
            return SimpleChoiceApiFp(configuration).deleteSimpleChoice(simpleChoiceId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options?: any) {
            return SimpleChoiceApiFp(configuration).findFullById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options?: any) {
            return SimpleChoiceApiFp(configuration).getByApplicationFeature(applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the simple choices content for the given application  regardless of module
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesForApplication(applicationId: string, options?: any) {
            return SimpleChoiceApiFp(configuration).getMessagesForApplication(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the simple choices for the given application module
         * @param {string} applicationModuleId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessagesForModule(applicationModuleId: string, options?: any) {
            return SimpleChoiceApiFp(configuration).getMessagesForModule(applicationModuleId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} simpleChoiceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(simpleChoiceId: string, options?: any) {
            return SimpleChoiceApiFp(configuration).getWebhooks(simpleChoiceId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any) {
            return SimpleChoiceApiFp(configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any) {
            return SimpleChoiceApiFp(configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} simpleChoiceWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(simpleChoiceWebhookId: string, options?: any) {
            return SimpleChoiceApiFp(configuration).removeWebhook(simpleChoiceWebhookId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Toggles the given message as live or not
         * @param {string} simpleChoiceId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleLive(simpleChoiceId: string, model?: ToggleLiveRequest, options?: any) {
            return SimpleChoiceApiFp(configuration).toggleLive(simpleChoiceId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} simpleChoiceId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(simpleChoiceId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any) {
            return SimpleChoiceApiFp(configuration).updateAttachedWebhook(simpleChoiceId, webhookInstanceId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {SimpleChoiceModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: SimpleChoiceModel, options?: any) {
            return SimpleChoiceApiFp(configuration).updateFullContentItem(contentItemId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the simple choice with the given fields  If you send null or no value for fields, they won't be updated
         * @param {string} simpleChoiceId 
         * @param {UpdateSimpleChoiceRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMessage(simpleChoiceId: string, model?: UpdateSimpleChoiceRequest, options?: any) {
            return SimpleChoiceApiFp(configuration).updateMessage(simpleChoiceId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the given response
         * @param {string} simpleChoiceResponseId 
         * @param {UpdateSimpleChoiceResponseRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateResponse(simpleChoiceResponseId: string, model?: UpdateSimpleChoiceResponseRequest, options?: any) {
            return SimpleChoiceApiFp(configuration).updateResponse(simpleChoiceResponseId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any) {
            return SimpleChoiceApiFp(configuration).updateUserDefinedParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any) {
            return SimpleChoiceApiFp(configuration).updateWebhookParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
    };
};

/**
 * SimpleChoiceApi - interface
 * @export
 * @interface SimpleChoiceApi
 */
export interface SimpleChoiceApiInterface {
    /**
     * 
     * @summary Adds an audio file to the given response
     * @param {string} simpleChoiceResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    addAudioFile(simpleChoiceResponseId: string, mediaItemId: string, options?: any): Promise<SimpleChoiceResponseModel>;

    /**
     * 
     * @summary Adds a large image to the given response
     * @param {string} simpleChoiceResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    addLargeImage(simpleChoiceResponseId: string, mediaItemId: string, options?: any): Promise<SimpleChoiceResponseModel>;

    /**
     * 
     * @summary Adds a small image item to the given response
     * @param {string} simpleChoiceResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    addSmallImage(simpleChoiceResponseId: string, mediaItemId: string, options?: any): Promise<SimpleChoiceResponseModel>;

    /**
     * 
     * @summary Adds a video file to the given response
     * @param {string} simpleChoiceResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    addVideoFile(simpleChoiceResponseId: string, mediaItemId: string, options?: any): Promise<SimpleChoiceResponseModel>;

    /**
     * 
     * @param {string} simpleChoiceId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    addWebhook(simpleChoiceId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): Promise<SimpleChoiceWebhookModel>;

    /**
     * 
     * @param {string} simpleChoiceId 
     * @param {BulkUpdateSimpleChoiceRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    bulkUpdateSimpleChoice(simpleChoiceId: string, model?: BulkUpdateSimpleChoiceRequest, options?: any): Promise<SimpleChoiceModel>;

    /**
     * 
     * @param {string} simpleChoiceId 
     * @param {BulkUpdateSimpleChoiceStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    bulkUpdateSimpleChoiceStub(simpleChoiceId: string, model?: BulkUpdateSimpleChoiceStubRequest, options?: any): Promise<SimpleChoiceModel>;

    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param {string} simpleChoiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    copyContentItem(simpleChoiceId: string, options?: any): Promise<SimpleChoiceModel>;

    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param {SimpleChoiceModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    createFullContentItem(model?: SimpleChoiceModel, options?: any): Promise<SimpleChoiceModel>;

    /**
     * 
     * @summary Creates a new response varation for the given message
     * @param {string} simpleChoiceId 
     * @param {NewSimpleChoiceResponseRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    createResponse(simpleChoiceId: string, model?: NewSimpleChoiceResponseRequest, options?: any): Promise<SimpleChoiceResponseModel>;

    /**
     * 
     * @summary Creates a new simple choice entity
     * @param {NewSimpleChoiceRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    createSimpleChoice(model?: NewSimpleChoiceRequest, options?: any): Promise<SimpleChoiceModel>;

    /**
     * 
     * @summary Creates a new simple choice entity
     * @param {NewSimpleChoiceStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    createSimpleChoiceStub(model?: NewSimpleChoiceStubRequest, options?: any): Promise<SimpleChoiceModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterCreateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @summary Deletes the given response
     * @param {string} simpleChoiceResponseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    deleteResponse(simpleChoiceResponseId: string, options?: any): Promise<SimpleChoiceResponseModel>;

    /**
     * 
     * @summary Delete the given simple choice
     * @param {string} simpleChoiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    deleteSimpleChoice(simpleChoiceId: string, options?: any): Promise<SimpleChoiceModel>;

    /**
     * 
     * @summary Finds the full content item by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    findFullById(id: string, options?: any): Promise<SimpleChoiceModel>;

    /**
     * 
     * @summary Gets the content for the given application feature
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    getByApplicationFeature(applicationFeatureId: string, options?: any): Promise<Array<SimpleChoiceModel>>;

    /**
     * 
     * @summary Gets the simple choices content for the given application  regardless of module
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    getMessagesForApplication(applicationId: string, options?: any): Promise<Array<SimpleChoiceModel>>;

    /**
     * 
     * @summary Gets the simple choices for the given application module
     * @param {string} applicationModuleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    getMessagesForModule(applicationModuleId: string, options?: any): Promise<Array<SimpleChoiceModel>>;

    /**
     * 
     * @param {string} simpleChoiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    getWebhooks(simpleChoiceId: string, options?: any): Promise<Array<SimpleChoiceWebhookModel>>;

    /**
     * 
     * @param {string} contentItemId 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any): Promise<SimpleChoiceModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {string} parameterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} simpleChoiceWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    removeWebhook(simpleChoiceWebhookId: string, options?: any): Promise<SimpleChoiceWebhookModel>;

    /**
     * 
     * @summary Toggles the given message as live or not
     * @param {string} simpleChoiceId 
     * @param {ToggleLiveRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    toggleLive(simpleChoiceId: string, model?: ToggleLiveRequest, options?: any): Promise<SimpleChoiceModel>;

    /**
     * 
     * @param {string} simpleChoiceId 
     * @param {string} webhookInstanceId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    updateAttachedWebhook(simpleChoiceId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any): Promise<SimpleChoiceWebhookModel>;

    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param {string} contentItemId 
     * @param {SimpleChoiceModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    updateFullContentItem(contentItemId: string, model?: SimpleChoiceModel, options?: any): Promise<SimpleChoiceModel>;

    /**
     * 
     * @summary Updates the simple choice with the given fields  If you send null or no value for fields, they won't be updated
     * @param {string} simpleChoiceId 
     * @param {UpdateSimpleChoiceRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    updateMessage(simpleChoiceId: string, model?: UpdateSimpleChoiceRequest, options?: any): Promise<SimpleChoiceModel>;

    /**
     * 
     * @summary Updates the given response
     * @param {string} simpleChoiceResponseId 
     * @param {UpdateSimpleChoiceResponseRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    updateResponse(simpleChoiceResponseId: string, model?: UpdateSimpleChoiceResponseRequest, options?: any): Promise<SimpleChoiceResponseModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {WebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApiInterface
     */
    updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any): Promise<boolean>;

}

/**
 * SimpleChoiceApi - object-oriented interface
 * @export
 * @class SimpleChoiceApi
 * @extends {BaseAPI}
 */
export class SimpleChoiceApi extends BaseAPI implements SimpleChoiceApiInterface {
    /**
     * 
     * @summary Adds an audio file to the given response
     * @param {string} simpleChoiceResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public addAudioFile(simpleChoiceResponseId: string, mediaItemId: string, options?: any) {
        return SimpleChoiceApiFp(this.configuration).addAudioFile(simpleChoiceResponseId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a large image to the given response
     * @param {string} simpleChoiceResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public addLargeImage(simpleChoiceResponseId: string, mediaItemId: string, options?: any) {
        return SimpleChoiceApiFp(this.configuration).addLargeImage(simpleChoiceResponseId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a small image item to the given response
     * @param {string} simpleChoiceResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public addSmallImage(simpleChoiceResponseId: string, mediaItemId: string, options?: any) {
        return SimpleChoiceApiFp(this.configuration).addSmallImage(simpleChoiceResponseId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a video file to the given response
     * @param {string} simpleChoiceResponseId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public addVideoFile(simpleChoiceResponseId: string, mediaItemId: string, options?: any) {
        return SimpleChoiceApiFp(this.configuration).addVideoFile(simpleChoiceResponseId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} simpleChoiceId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public addWebhook(simpleChoiceId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
        return SimpleChoiceApiFp(this.configuration).addWebhook(simpleChoiceId, webhookId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} simpleChoiceId 
     * @param {BulkUpdateSimpleChoiceRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public bulkUpdateSimpleChoice(simpleChoiceId: string, model?: BulkUpdateSimpleChoiceRequest, options?: any) {
        return SimpleChoiceApiFp(this.configuration).bulkUpdateSimpleChoice(simpleChoiceId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} simpleChoiceId 
     * @param {BulkUpdateSimpleChoiceStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public bulkUpdateSimpleChoiceStub(simpleChoiceId: string, model?: BulkUpdateSimpleChoiceStubRequest, options?: any) {
        return SimpleChoiceApiFp(this.configuration).bulkUpdateSimpleChoiceStub(simpleChoiceId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param {string} simpleChoiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public copyContentItem(simpleChoiceId: string, options?: any) {
        return SimpleChoiceApiFp(this.configuration).copyContentItem(simpleChoiceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param {SimpleChoiceModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public createFullContentItem(model?: SimpleChoiceModel, options?: any) {
        return SimpleChoiceApiFp(this.configuration).createFullContentItem(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new response varation for the given message
     * @param {string} simpleChoiceId 
     * @param {NewSimpleChoiceResponseRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public createResponse(simpleChoiceId: string, model?: NewSimpleChoiceResponseRequest, options?: any) {
        return SimpleChoiceApiFp(this.configuration).createResponse(simpleChoiceId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new simple choice entity
     * @param {NewSimpleChoiceRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public createSimpleChoice(model?: NewSimpleChoiceRequest, options?: any) {
        return SimpleChoiceApiFp(this.configuration).createSimpleChoice(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new simple choice entity
     * @param {NewSimpleChoiceStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public createSimpleChoiceStub(model?: NewSimpleChoiceStubRequest, options?: any) {
        return SimpleChoiceApiFp(this.configuration).createSimpleChoiceStub(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterCreateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any) {
        return SimpleChoiceApiFp(this.configuration).createUserDefinedParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes the given response
     * @param {string} simpleChoiceResponseId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public deleteResponse(simpleChoiceResponseId: string, options?: any) {
        return SimpleChoiceApiFp(this.configuration).deleteResponse(simpleChoiceResponseId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete the given simple choice
     * @param {string} simpleChoiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public deleteSimpleChoice(simpleChoiceId: string, options?: any) {
        return SimpleChoiceApiFp(this.configuration).deleteSimpleChoice(simpleChoiceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Finds the full content item by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public findFullById(id: string, options?: any) {
        return SimpleChoiceApiFp(this.configuration).findFullById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the content for the given application feature
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public getByApplicationFeature(applicationFeatureId: string, options?: any) {
        return SimpleChoiceApiFp(this.configuration).getByApplicationFeature(applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the simple choices content for the given application  regardless of module
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public getMessagesForApplication(applicationId: string, options?: any) {
        return SimpleChoiceApiFp(this.configuration).getMessagesForApplication(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the simple choices for the given application module
     * @param {string} applicationModuleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public getMessagesForModule(applicationModuleId: string, options?: any) {
        return SimpleChoiceApiFp(this.configuration).getMessagesForModule(applicationModuleId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} simpleChoiceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public getWebhooks(simpleChoiceId: string, options?: any) {
        return SimpleChoiceApiFp(this.configuration).getWebhooks(simpleChoiceId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} contentItemId 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any) {
        return SimpleChoiceApiFp(this.configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {string} parameterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any) {
        return SimpleChoiceApiFp(this.configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} simpleChoiceWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public removeWebhook(simpleChoiceWebhookId: string, options?: any) {
        return SimpleChoiceApiFp(this.configuration).removeWebhook(simpleChoiceWebhookId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Toggles the given message as live or not
     * @param {string} simpleChoiceId 
     * @param {ToggleLiveRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public toggleLive(simpleChoiceId: string, model?: ToggleLiveRequest, options?: any) {
        return SimpleChoiceApiFp(this.configuration).toggleLive(simpleChoiceId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} simpleChoiceId 
     * @param {string} webhookInstanceId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public updateAttachedWebhook(simpleChoiceId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any) {
        return SimpleChoiceApiFp(this.configuration).updateAttachedWebhook(simpleChoiceId, webhookInstanceId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param {string} contentItemId 
     * @param {SimpleChoiceModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public updateFullContentItem(contentItemId: string, model?: SimpleChoiceModel, options?: any) {
        return SimpleChoiceApiFp(this.configuration).updateFullContentItem(contentItemId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the simple choice with the given fields  If you send null or no value for fields, they won't be updated
     * @param {string} simpleChoiceId 
     * @param {UpdateSimpleChoiceRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public updateMessage(simpleChoiceId: string, model?: UpdateSimpleChoiceRequest, options?: any) {
        return SimpleChoiceApiFp(this.configuration).updateMessage(simpleChoiceId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the given response
     * @param {string} simpleChoiceResponseId 
     * @param {UpdateSimpleChoiceResponseRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public updateResponse(simpleChoiceResponseId: string, model?: UpdateSimpleChoiceResponseRequest, options?: any) {
        return SimpleChoiceApiFp(this.configuration).updateResponse(simpleChoiceResponseId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any) {
        return SimpleChoiceApiFp(this.configuration).updateUserDefinedParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {WebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SimpleChoiceApi
     */
    public updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any) {
        return SimpleChoiceApiFp(this.configuration).updateWebhookParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

}

/**
 * SingleSignOnApi - fetch parameter creator
 * @export
 */
export const SingleSignOnApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Begins single sign in process
         * @param {SingleSignOnRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signInWithSingleSignOn(request?: SingleSignOnRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/SingleSignOn/signIn`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SingleSignOnRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Begins sign up with SSO process
         * @param {SingleSignOnRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUpWithSingleSignOn(request?: SingleSignOnRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/SingleSignOn/signUp`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SingleSignOnRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SingleSignOnApi - functional programming interface
 * @export
 */
export const SingleSignOnApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Begins single sign in process
         * @param {SingleSignOnRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signInWithSingleSignOn(request?: SingleSignOnRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SingleSignOnResponse> {
            const localVarFetchArgs = SingleSignOnApiFetchParamCreator(configuration).signInWithSingleSignOn(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Begins sign up with SSO process
         * @param {SingleSignOnRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUpWithSingleSignOn(request?: SingleSignOnRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SingleSignOnResponse> {
            const localVarFetchArgs = SingleSignOnApiFetchParamCreator(configuration).signUpWithSingleSignOn(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SingleSignOnApi - factory interface
 * @export
 */
export const SingleSignOnApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Begins single sign in process
         * @param {SingleSignOnRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signInWithSingleSignOn(request?: SingleSignOnRequest, options?: any) {
            return SingleSignOnApiFp(configuration).signInWithSingleSignOn(request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Begins sign up with SSO process
         * @param {SingleSignOnRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUpWithSingleSignOn(request?: SingleSignOnRequest, options?: any) {
            return SingleSignOnApiFp(configuration).signUpWithSingleSignOn(request, options)(fetch, basePath);
        },
    };
};

/**
 * SingleSignOnApi - interface
 * @export
 * @interface SingleSignOnApi
 */
export interface SingleSignOnApiInterface {
    /**
     * 
     * @summary Begins single sign in process
     * @param {SingleSignOnRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleSignOnApiInterface
     */
    signInWithSingleSignOn(request?: SingleSignOnRequest, options?: any): Promise<SingleSignOnResponse>;

    /**
     * 
     * @summary Begins sign up with SSO process
     * @param {SingleSignOnRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleSignOnApiInterface
     */
    signUpWithSingleSignOn(request?: SingleSignOnRequest, options?: any): Promise<SingleSignOnResponse>;

}

/**
 * SingleSignOnApi - object-oriented interface
 * @export
 * @class SingleSignOnApi
 * @extends {BaseAPI}
 */
export class SingleSignOnApi extends BaseAPI implements SingleSignOnApiInterface {
    /**
     * 
     * @summary Begins single sign in process
     * @param {SingleSignOnRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleSignOnApi
     */
    public signInWithSingleSignOn(request?: SingleSignOnRequest, options?: any) {
        return SingleSignOnApiFp(this.configuration).signInWithSingleSignOn(request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Begins sign up with SSO process
     * @param {SingleSignOnRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleSignOnApi
     */
    public signUpWithSingleSignOn(request?: SingleSignOnRequest, options?: any) {
        return SingleSignOnApiFp(this.configuration).signUpWithSingleSignOn(request, options)(this.fetch, this.basePath);
    }

}

/**
 * SingleSignOnRedirectApi - fetch parameter creator
 * @export
 */
export const SingleSignOnRedirectApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {string} [error] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oAuth2CallbackGet(code?: string, state?: string, error?: string, options: any = {}): FetchArgs {
            const localVarPath = `/SingleSignOnRedirect/oauth2`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (error !== undefined) {
                localVarQueryParameter['error'] = error;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [samlResponse] 
         * @param {string} [redirectUrl] 
         * @param {string} [email] 
         * @param {string} [clientId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sAMLCallback(samlResponse?: string, redirectUrl?: string, email?: string, clientId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/SingleSignOnRedirect/saml`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (redirectUrl !== undefined) {
                localVarQueryParameter['redirectUrl'] = redirectUrl;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (clientId !== undefined) {
                localVarQueryParameter['clientId'] = clientId;
            }

            if (samlResponse !== undefined) {
                localVarFormParams.set('samlResponse', samlResponse as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SingleSignOnRedirectApi - functional programming interface
 * @export
 */
export const SingleSignOnRedirectApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {string} [error] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oAuth2CallbackGet(code?: string, state?: string, error?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SingleSignOnRedirectApiFetchParamCreator(configuration).oAuth2CallbackGet(code, state, error, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} [samlResponse] 
         * @param {string} [redirectUrl] 
         * @param {string} [email] 
         * @param {string} [clientId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sAMLCallback(samlResponse?: string, redirectUrl?: string, email?: string, clientId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SingleSignOnRedirectApiFetchParamCreator(configuration).sAMLCallback(samlResponse, redirectUrl, email, clientId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SingleSignOnRedirectApi - factory interface
 * @export
 */
export const SingleSignOnRedirectApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} [code] 
         * @param {string} [state] 
         * @param {string} [error] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oAuth2CallbackGet(code?: string, state?: string, error?: string, options?: any) {
            return SingleSignOnRedirectApiFp(configuration).oAuth2CallbackGet(code, state, error, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} [samlResponse] 
         * @param {string} [redirectUrl] 
         * @param {string} [email] 
         * @param {string} [clientId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sAMLCallback(samlResponse?: string, redirectUrl?: string, email?: string, clientId?: string, options?: any) {
            return SingleSignOnRedirectApiFp(configuration).sAMLCallback(samlResponse, redirectUrl, email, clientId, options)(fetch, basePath);
        },
    };
};

/**
 * SingleSignOnRedirectApi - interface
 * @export
 * @interface SingleSignOnRedirectApi
 */
export interface SingleSignOnRedirectApiInterface {
    /**
     * 
     * @param {string} [code] 
     * @param {string} [state] 
     * @param {string} [error] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleSignOnRedirectApiInterface
     */
    oAuth2CallbackGet(code?: string, state?: string, error?: string, options?: any): Promise<{}>;

    /**
     * 
     * @param {string} [samlResponse] 
     * @param {string} [redirectUrl] 
     * @param {string} [email] 
     * @param {string} [clientId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleSignOnRedirectApiInterface
     */
    sAMLCallback(samlResponse?: string, redirectUrl?: string, email?: string, clientId?: string, options?: any): Promise<{}>;

}

/**
 * SingleSignOnRedirectApi - object-oriented interface
 * @export
 * @class SingleSignOnRedirectApi
 * @extends {BaseAPI}
 */
export class SingleSignOnRedirectApi extends BaseAPI implements SingleSignOnRedirectApiInterface {
    /**
     * 
     * @param {string} [code] 
     * @param {string} [state] 
     * @param {string} [error] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleSignOnRedirectApi
     */
    public oAuth2CallbackGet(code?: string, state?: string, error?: string, options?: any) {
        return SingleSignOnRedirectApiFp(this.configuration).oAuth2CallbackGet(code, state, error, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} [samlResponse] 
     * @param {string} [redirectUrl] 
     * @param {string} [email] 
     * @param {string} [clientId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SingleSignOnRedirectApi
     */
    public sAMLCallback(samlResponse?: string, redirectUrl?: string, email?: string, clientId?: string, options?: any) {
        return SingleSignOnRedirectApiFp(this.configuration).sAMLCallback(samlResponse, redirectUrl, email, clientId, options)(this.fetch, this.basePath);
    }

}

/**
 * SsmlApi - fetch parameter creator
 * @export
 */
export const SsmlApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SsmlElement} [element] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        build(element?: SsmlElement, options: any = {}): FetchArgs {
            const localVarPath = `/api/Ssml/build`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SsmlElement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(element || {}) : (element || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SsmlRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parse(request?: SsmlRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Ssml/parse`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SsmlRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SsmlRequest} [request] 
         * @param {string} [tag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segment(request?: SsmlRequest, tag?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/Ssml/segment`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SsmlRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SsmlRequest} [request] 
         * @param {string} [tag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segmentAndBuild(request?: SsmlRequest, tag?: string, options: any = {}): FetchArgs {
            const localVarPath = `/api/Ssml/segmentAndBuild`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SsmlRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SsmlRequest} [request] 
         * @param {Array<string>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segmentAndBuild_1(request?: SsmlRequest, tags?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/api/Ssml/segmentAndBuildMulti`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SsmlRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} assistant 
         * @param {SsmlRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssmlToSpeech(assistant: string, request?: SsmlRequest, options: any = {}): FetchArgs {
            // verify required parameter 'assistant' is not null or undefined
            if (assistant === null || assistant === undefined) {
                throw new RequiredError('assistant','Required parameter assistant was null or undefined when calling ssmlToSpeech.');
            }
            const localVarPath = `/api/Ssml/toSpeech/{assistant}`
                .replace(`{${"assistant"}}`, encodeURIComponent(String(assistant)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SsmlRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SsmlRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAlexaSsml(request?: SsmlRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Ssml/validate/alexa`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SsmlRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SsmlRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateGoogleSsml(request?: SsmlRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Ssml/validate/google`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SsmlRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SsmlRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateSsml(request?: SsmlRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/Ssml/validate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SsmlRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SsmlApi - functional programming interface
 * @export
 */
export const SsmlApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SsmlElement} [element] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        build(element?: SsmlElement, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = SsmlApiFetchParamCreator(configuration).build(element, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SsmlRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parse(request?: SsmlRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SsmlElement> {
            const localVarFetchArgs = SsmlApiFetchParamCreator(configuration).parse(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SsmlRequest} [request] 
         * @param {string} [tag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segment(request?: SsmlRequest, tag?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SsmlElement>> {
            const localVarFetchArgs = SsmlApiFetchParamCreator(configuration).segment(request, tag, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SsmlRequest} [request] 
         * @param {string} [tag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segmentAndBuild(request?: SsmlRequest, tag?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = SsmlApiFetchParamCreator(configuration).segmentAndBuild(request, tag, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SsmlRequest} [request] 
         * @param {Array<string>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segmentAndBuild_1(request?: SsmlRequest, tags?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = SsmlApiFetchParamCreator(configuration).segmentAndBuild_1(request, tags, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} assistant 
         * @param {SsmlRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssmlToSpeech(assistant: string, request?: SsmlRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SpeechOutput>> {
            const localVarFetchArgs = SsmlApiFetchParamCreator(configuration).ssmlToSpeech(assistant, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SsmlRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAlexaSsml(request?: SsmlRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SsmlApiFetchParamCreator(configuration).validateAlexaSsml(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SsmlRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateGoogleSsml(request?: SsmlRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SsmlApiFetchParamCreator(configuration).validateGoogleSsml(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {SsmlRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateSsml(request?: SsmlRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = SsmlApiFetchParamCreator(configuration).validateSsml(request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SsmlApi - factory interface
 * @export
 */
export const SsmlApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {SsmlElement} [element] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        build(element?: SsmlElement, options?: any) {
            return SsmlApiFp(configuration).build(element, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SsmlRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parse(request?: SsmlRequest, options?: any) {
            return SsmlApiFp(configuration).parse(request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SsmlRequest} [request] 
         * @param {string} [tag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segment(request?: SsmlRequest, tag?: string, options?: any) {
            return SsmlApiFp(configuration).segment(request, tag, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SsmlRequest} [request] 
         * @param {string} [tag] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segmentAndBuild(request?: SsmlRequest, tag?: string, options?: any) {
            return SsmlApiFp(configuration).segmentAndBuild(request, tag, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SsmlRequest} [request] 
         * @param {Array<string>} [tags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segmentAndBuild_1(request?: SsmlRequest, tags?: Array<string>, options?: any) {
            return SsmlApiFp(configuration).segmentAndBuild_1(request, tags, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} assistant 
         * @param {SsmlRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssmlToSpeech(assistant: string, request?: SsmlRequest, options?: any) {
            return SsmlApiFp(configuration).ssmlToSpeech(assistant, request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SsmlRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateAlexaSsml(request?: SsmlRequest, options?: any) {
            return SsmlApiFp(configuration).validateAlexaSsml(request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SsmlRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateGoogleSsml(request?: SsmlRequest, options?: any) {
            return SsmlApiFp(configuration).validateGoogleSsml(request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {SsmlRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateSsml(request?: SsmlRequest, options?: any) {
            return SsmlApiFp(configuration).validateSsml(request, options)(fetch, basePath);
        },
    };
};

/**
 * SsmlApi - interface
 * @export
 * @interface SsmlApi
 */
export interface SsmlApiInterface {
    /**
     * 
     * @param {SsmlElement} [element] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsmlApiInterface
     */
    build(element?: SsmlElement, options?: any): Promise<string>;

    /**
     * 
     * @param {SsmlRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsmlApiInterface
     */
    parse(request?: SsmlRequest, options?: any): Promise<SsmlElement>;

    /**
     * 
     * @param {SsmlRequest} [request] 
     * @param {string} [tag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsmlApiInterface
     */
    segment(request?: SsmlRequest, tag?: string, options?: any): Promise<Array<SsmlElement>>;

    /**
     * 
     * @param {SsmlRequest} [request] 
     * @param {string} [tag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsmlApiInterface
     */
    segmentAndBuild(request?: SsmlRequest, tag?: string, options?: any): Promise<Array<string>>;

    /**
     * 
     * @param {SsmlRequest} [request] 
     * @param {Array<string>} [tags] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsmlApiInterface
     */
    segmentAndBuild_1(request?: SsmlRequest, tags?: Array<string>, options?: any): Promise<Array<string>>;

    /**
     * 
     * @param {string} assistant 
     * @param {SsmlRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsmlApiInterface
     */
    ssmlToSpeech(assistant: string, request?: SsmlRequest, options?: any): Promise<Array<SpeechOutput>>;

    /**
     * 
     * @param {SsmlRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsmlApiInterface
     */
    validateAlexaSsml(request?: SsmlRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @param {SsmlRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsmlApiInterface
     */
    validateGoogleSsml(request?: SsmlRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @param {SsmlRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsmlApiInterface
     */
    validateSsml(request?: SsmlRequest, options?: any): Promise<boolean>;

}

/**
 * SsmlApi - object-oriented interface
 * @export
 * @class SsmlApi
 * @extends {BaseAPI}
 */
export class SsmlApi extends BaseAPI implements SsmlApiInterface {
    /**
     * 
     * @param {SsmlElement} [element] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsmlApi
     */
    public build(element?: SsmlElement, options?: any) {
        return SsmlApiFp(this.configuration).build(element, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {SsmlRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsmlApi
     */
    public parse(request?: SsmlRequest, options?: any) {
        return SsmlApiFp(this.configuration).parse(request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {SsmlRequest} [request] 
     * @param {string} [tag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsmlApi
     */
    public segment(request?: SsmlRequest, tag?: string, options?: any) {
        return SsmlApiFp(this.configuration).segment(request, tag, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {SsmlRequest} [request] 
     * @param {string} [tag] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsmlApi
     */
    public segmentAndBuild(request?: SsmlRequest, tag?: string, options?: any) {
        return SsmlApiFp(this.configuration).segmentAndBuild(request, tag, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {SsmlRequest} [request] 
     * @param {Array<string>} [tags] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsmlApi
     */
    public segmentAndBuild_1(request?: SsmlRequest, tags?: Array<string>, options?: any) {
        return SsmlApiFp(this.configuration).segmentAndBuild_1(request, tags, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} assistant 
     * @param {SsmlRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsmlApi
     */
    public ssmlToSpeech(assistant: string, request?: SsmlRequest, options?: any) {
        return SsmlApiFp(this.configuration).ssmlToSpeech(assistant, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {SsmlRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsmlApi
     */
    public validateAlexaSsml(request?: SsmlRequest, options?: any) {
        return SsmlApiFp(this.configuration).validateAlexaSsml(request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {SsmlRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsmlApi
     */
    public validateGoogleSsml(request?: SsmlRequest, options?: any) {
        return SsmlApiFp(this.configuration).validateGoogleSsml(request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {SsmlRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SsmlApi
     */
    public validateSsml(request?: SsmlRequest, options?: any) {
        return SsmlApiFp(this.configuration).validateSsml(request, options)(this.fetch, this.basePath);
    }

}

/**
 * SubscriptionApi - fetch parameter creator
 * @export
 */
export const SubscriptionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuiltInTypes(options: any = {}): FetchArgs {
            const localVarPath = `/api/Subscription/types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionsForOrganization(organizationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling getSubscriptionsForOrganization.');
            }
            const localVarPath = `/api/Subscription/forOrganization/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionApi - functional programming interface
 * @export
 */
export const SubscriptionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuiltInTypes(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SubscriptionTypeModel>> {
            const localVarFetchArgs = SubscriptionApiFetchParamCreator(configuration).getBuiltInTypes(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionsForOrganization(organizationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SubscriptionModel>> {
            const localVarFetchArgs = SubscriptionApiFetchParamCreator(configuration).getSubscriptionsForOrganization(organizationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SubscriptionApi - factory interface
 * @export
 */
export const SubscriptionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBuiltInTypes(options?: any) {
            return SubscriptionApiFp(configuration).getBuiltInTypes(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionsForOrganization(organizationId: string, options?: any) {
            return SubscriptionApiFp(configuration).getSubscriptionsForOrganization(organizationId, options)(fetch, basePath);
        },
    };
};

/**
 * SubscriptionApi - interface
 * @export
 * @interface SubscriptionApi
 */
export interface SubscriptionApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApiInterface
     */
    getBuiltInTypes(options?: any): Promise<Array<SubscriptionTypeModel>>;

    /**
     * 
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApiInterface
     */
    getSubscriptionsForOrganization(organizationId: string, options?: any): Promise<Array<SubscriptionModel>>;

}

/**
 * SubscriptionApi - object-oriented interface
 * @export
 * @class SubscriptionApi
 * @extends {BaseAPI}
 */
export class SubscriptionApi extends BaseAPI implements SubscriptionApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public getBuiltInTypes(options?: any) {
        return SubscriptionApiFp(this.configuration).getBuiltInTypes(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    public getSubscriptionsForOrganization(organizationId: string, options?: any) {
        return SubscriptionApiFp(this.configuration).getSubscriptionsForOrganization(organizationId, options)(this.fetch, this.basePath);
    }

}

/**
 * TemplateConfigurationApi - fetch parameter creator
 * @export
 */
export const TemplateConfigurationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TemplateConfigurationModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplateConfigurationFromModel(model?: TemplateConfigurationModel, options: any = {}): FetchArgs {
            const localVarPath = `/api/TemplateConfiguration`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TemplateConfigurationModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} templateConfigurationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplateConfiguration(templateConfigurationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'templateConfigurationId' is not null or undefined
            if (templateConfigurationId === null || templateConfigurationId === undefined) {
                throw new RequiredError('templateConfigurationId','Required parameter templateConfigurationId was null or undefined when calling deleteTemplateConfiguration.');
            }
            const localVarPath = `/api/TemplateConfiguration/{templateConfigurationId}`
                .replace(`{${"templateConfigurationId"}}`, encodeURIComponent(String(templateConfigurationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} templateConfigurationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableTemplateConfiguration(templateConfigurationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'templateConfigurationId' is not null or undefined
            if (templateConfigurationId === null || templateConfigurationId === undefined) {
                throw new RequiredError('templateConfigurationId','Required parameter templateConfigurationId was null or undefined when calling disableTemplateConfiguration.');
            }
            const localVarPath = `/api/TemplateConfiguration/{templateConfigurationId}/disable`
                .replace(`{${"templateConfigurationId"}}`, encodeURIComponent(String(templateConfigurationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} templateConfigurationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableTemplateConfiguration(templateConfigurationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'templateConfigurationId' is not null or undefined
            if (templateConfigurationId === null || templateConfigurationId === undefined) {
                throw new RequiredError('templateConfigurationId','Required parameter templateConfigurationId was null or undefined when calling enableTemplateConfiguration.');
            }
            const localVarPath = `/api/TemplateConfiguration/{templateConfigurationId}/enable`
                .replace(`{${"templateConfigurationId"}}`, encodeURIComponent(String(templateConfigurationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the available template configs
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableTemplateConfigurations(organizationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling getAvailableTemplateConfigurations.');
            }
            const localVarPath = `/api/TemplateConfiguration/{organizationId}/available`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationTemplateConfigurations(organizationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling getOrganizationTemplateConfigurations.');
            }
            const localVarPath = `/api/TemplateConfiguration/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} templateConfigurationId 
         * @param {TemplateConfigurationModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplateConfiguration(templateConfigurationId: string, model?: TemplateConfigurationModel, options: any = {}): FetchArgs {
            // verify required parameter 'templateConfigurationId' is not null or undefined
            if (templateConfigurationId === null || templateConfigurationId === undefined) {
                throw new RequiredError('templateConfigurationId','Required parameter templateConfigurationId was null or undefined when calling updateTemplateConfiguration.');
            }
            const localVarPath = `/api/TemplateConfiguration/{templateConfigurationId}`
                .replace(`{${"templateConfigurationId"}}`, encodeURIComponent(String(templateConfigurationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TemplateConfigurationModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplateConfigurationApi - functional programming interface
 * @export
 */
export const TemplateConfigurationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {TemplateConfigurationModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplateConfigurationFromModel(model?: TemplateConfigurationModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateConfigurationModel> {
            const localVarFetchArgs = TemplateConfigurationApiFetchParamCreator(configuration).createTemplateConfigurationFromModel(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} templateConfigurationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplateConfiguration(templateConfigurationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateConfigurationModel> {
            const localVarFetchArgs = TemplateConfigurationApiFetchParamCreator(configuration).deleteTemplateConfiguration(templateConfigurationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} templateConfigurationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableTemplateConfiguration(templateConfigurationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateConfigurationModel> {
            const localVarFetchArgs = TemplateConfigurationApiFetchParamCreator(configuration).disableTemplateConfiguration(templateConfigurationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} templateConfigurationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableTemplateConfiguration(templateConfigurationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateConfigurationModel> {
            const localVarFetchArgs = TemplateConfigurationApiFetchParamCreator(configuration).enableTemplateConfiguration(templateConfigurationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the available template configs
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableTemplateConfigurations(organizationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TemplateConfigurationModel>> {
            const localVarFetchArgs = TemplateConfigurationApiFetchParamCreator(configuration).getAvailableTemplateConfigurations(organizationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationTemplateConfigurations(organizationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TemplateConfigurationModel>> {
            const localVarFetchArgs = TemplateConfigurationApiFetchParamCreator(configuration).getOrganizationTemplateConfigurations(organizationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} templateConfigurationId 
         * @param {TemplateConfigurationModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplateConfiguration(templateConfigurationId: string, model?: TemplateConfigurationModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TemplateConfigurationModel> {
            const localVarFetchArgs = TemplateConfigurationApiFetchParamCreator(configuration).updateTemplateConfiguration(templateConfigurationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TemplateConfigurationApi - factory interface
 * @export
 */
export const TemplateConfigurationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {TemplateConfigurationModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTemplateConfigurationFromModel(model?: TemplateConfigurationModel, options?: any) {
            return TemplateConfigurationApiFp(configuration).createTemplateConfigurationFromModel(model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} templateConfigurationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTemplateConfiguration(templateConfigurationId: string, options?: any) {
            return TemplateConfigurationApiFp(configuration).deleteTemplateConfiguration(templateConfigurationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} templateConfigurationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableTemplateConfiguration(templateConfigurationId: string, options?: any) {
            return TemplateConfigurationApiFp(configuration).disableTemplateConfiguration(templateConfigurationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} templateConfigurationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableTemplateConfiguration(templateConfigurationId: string, options?: any) {
            return TemplateConfigurationApiFp(configuration).enableTemplateConfiguration(templateConfigurationId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the available template configs
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableTemplateConfigurations(organizationId: string, options?: any) {
            return TemplateConfigurationApiFp(configuration).getAvailableTemplateConfigurations(organizationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationTemplateConfigurations(organizationId: string, options?: any) {
            return TemplateConfigurationApiFp(configuration).getOrganizationTemplateConfigurations(organizationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} templateConfigurationId 
         * @param {TemplateConfigurationModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTemplateConfiguration(templateConfigurationId: string, model?: TemplateConfigurationModel, options?: any) {
            return TemplateConfigurationApiFp(configuration).updateTemplateConfiguration(templateConfigurationId, model, options)(fetch, basePath);
        },
    };
};

/**
 * TemplateConfigurationApi - interface
 * @export
 * @interface TemplateConfigurationApi
 */
export interface TemplateConfigurationApiInterface {
    /**
     * 
     * @param {TemplateConfigurationModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateConfigurationApiInterface
     */
    createTemplateConfigurationFromModel(model?: TemplateConfigurationModel, options?: any): Promise<TemplateConfigurationModel>;

    /**
     * 
     * @param {string} templateConfigurationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateConfigurationApiInterface
     */
    deleteTemplateConfiguration(templateConfigurationId: string, options?: any): Promise<TemplateConfigurationModel>;

    /**
     * 
     * @param {string} templateConfigurationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateConfigurationApiInterface
     */
    disableTemplateConfiguration(templateConfigurationId: string, options?: any): Promise<TemplateConfigurationModel>;

    /**
     * 
     * @param {string} templateConfigurationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateConfigurationApiInterface
     */
    enableTemplateConfiguration(templateConfigurationId: string, options?: any): Promise<TemplateConfigurationModel>;

    /**
     * 
     * @summary Gets the available template configs
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateConfigurationApiInterface
     */
    getAvailableTemplateConfigurations(organizationId: string, options?: any): Promise<Array<TemplateConfigurationModel>>;

    /**
     * 
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateConfigurationApiInterface
     */
    getOrganizationTemplateConfigurations(organizationId: string, options?: any): Promise<Array<TemplateConfigurationModel>>;

    /**
     * 
     * @param {string} templateConfigurationId 
     * @param {TemplateConfigurationModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateConfigurationApiInterface
     */
    updateTemplateConfiguration(templateConfigurationId: string, model?: TemplateConfigurationModel, options?: any): Promise<TemplateConfigurationModel>;

}

/**
 * TemplateConfigurationApi - object-oriented interface
 * @export
 * @class TemplateConfigurationApi
 * @extends {BaseAPI}
 */
export class TemplateConfigurationApi extends BaseAPI implements TemplateConfigurationApiInterface {
    /**
     * 
     * @param {TemplateConfigurationModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateConfigurationApi
     */
    public createTemplateConfigurationFromModel(model?: TemplateConfigurationModel, options?: any) {
        return TemplateConfigurationApiFp(this.configuration).createTemplateConfigurationFromModel(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} templateConfigurationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateConfigurationApi
     */
    public deleteTemplateConfiguration(templateConfigurationId: string, options?: any) {
        return TemplateConfigurationApiFp(this.configuration).deleteTemplateConfiguration(templateConfigurationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} templateConfigurationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateConfigurationApi
     */
    public disableTemplateConfiguration(templateConfigurationId: string, options?: any) {
        return TemplateConfigurationApiFp(this.configuration).disableTemplateConfiguration(templateConfigurationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} templateConfigurationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateConfigurationApi
     */
    public enableTemplateConfiguration(templateConfigurationId: string, options?: any) {
        return TemplateConfigurationApiFp(this.configuration).enableTemplateConfiguration(templateConfigurationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the available template configs
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateConfigurationApi
     */
    public getAvailableTemplateConfigurations(organizationId: string, options?: any) {
        return TemplateConfigurationApiFp(this.configuration).getAvailableTemplateConfigurations(organizationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateConfigurationApi
     */
    public getOrganizationTemplateConfigurations(organizationId: string, options?: any) {
        return TemplateConfigurationApiFp(this.configuration).getOrganizationTemplateConfigurations(organizationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} templateConfigurationId 
     * @param {TemplateConfigurationModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplateConfigurationApi
     */
    public updateTemplateConfiguration(templateConfigurationId: string, model?: TemplateConfigurationModel, options?: any) {
        return TemplateConfigurationApiFp(this.configuration).updateTemplateConfiguration(templateConfigurationId, model, options)(this.fetch, this.basePath);
    }

}

/**
 * TermApi - fetch parameter creator
 * @export
 */
export const TermApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {NewUserTermRequestModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTermAgreement(model?: NewUserTermRequestModel, options: any = {}): FetchArgs {
            const localVarPath = `/api/Term/agreement`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewUserTermRequestModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestTerm(options: any = {}): FetchArgs {
            const localVarPath = `/api/Term/latest`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TermApi - functional programming interface
 * @export
 */
export const TermApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {NewUserTermRequestModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTermAgreement(model?: NewUserTermRequestModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserTermModel> {
            const localVarFetchArgs = TermApiFetchParamCreator(configuration).addTermAgreement(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestTerm(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TermModel> {
            const localVarFetchArgs = TermApiFetchParamCreator(configuration).getLatestTerm(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TermApi - factory interface
 * @export
 */
export const TermApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {NewUserTermRequestModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTermAgreement(model?: NewUserTermRequestModel, options?: any) {
            return TermApiFp(configuration).addTermAgreement(model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestTerm(options?: any) {
            return TermApiFp(configuration).getLatestTerm(options)(fetch, basePath);
        },
    };
};

/**
 * TermApi - interface
 * @export
 * @interface TermApi
 */
export interface TermApiInterface {
    /**
     * 
     * @param {NewUserTermRequestModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermApiInterface
     */
    addTermAgreement(model?: NewUserTermRequestModel, options?: any): Promise<UserTermModel>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermApiInterface
     */
    getLatestTerm(options?: any): Promise<TermModel>;

}

/**
 * TermApi - object-oriented interface
 * @export
 * @class TermApi
 * @extends {BaseAPI}
 */
export class TermApi extends BaseAPI implements TermApiInterface {
    /**
     * 
     * @param {NewUserTermRequestModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermApi
     */
    public addTermAgreement(model?: NewUserTermRequestModel, options?: any) {
        return TermApiFp(this.configuration).addTermAgreement(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermApi
     */
    public getLatestTerm(options?: any) {
        return TermApiFp(this.configuration).getLatestTerm(options)(this.fetch, this.basePath);
    }

}

/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Changes the current user's password
         * @param {ChangePasswordRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(model?: ChangePasswordRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/User/ChangePassword`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ChangePasswordRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an api-only user, mainly for integration use
         * @param {NewApiUserRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiUser(model?: NewApiUserRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/User/ApiUser`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewApiUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates the user.
         * @param {NewUserRequest} [model] Model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(model?: NewUserRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/User`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the current user's info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserData(options: any = {}): FetchArgs {
            const localVarPath = `/api/User/me`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the current user's terms agreement info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserTermsAgreement(options: any = {}): FetchArgs {
            const localVarPath = `/api/User/terms`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Checks if sso is available for this user's email.
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleSignOnAvailability(email: string, options: any = {}): FetchArgs {
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling getSingleSignOnAvailability.');
            }
            const localVarPath = `/api/User/useSso/{email}`
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemUserRoles(options: any = {}): FetchArgs {
            const localVarPath = `/api/User/SystemRoles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Requests to reset the user's password
         * @param {ResetRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPasswordReset(model?: ResetRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/User/ResetPassword`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ResetRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets the user's password based on the reset request
         * @param {CreateNewPasswordRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPassword(model?: CreateNewPasswordRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/User/SetPassword`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateNewPasswordRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateUserRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDetails(model?: UpdateUserRequest, options: any = {}): FetchArgs {
            const localVarPath = `/api/User/UpdateDetails`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileImage(file?: any, options: any = {}): FetchArgs {
            const localVarPath = `/api/User/UpdateImage`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Changes the current user's password
         * @param {ChangePasswordRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(model?: ChangePasswordRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).changePassword(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create an api-only user, mainly for integration use
         * @param {NewApiUserRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiUser(model?: NewApiUserRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiUserModel> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).createApiUser(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates the user.
         * @param {NewUserRequest} [model] Model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(model?: NewUserRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserModel> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).createUser(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the current user's info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserData(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserModel> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getCurrentUserData(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the current user's terms agreement info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserTermsAgreement(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserTermAgreementModel> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getCurrentUserTermsAgreement(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Checks if sso is available for this user's email.
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleSignOnAvailability(email: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getSingleSignOnAvailability(email, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemUserRoles(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserRoleModel>> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getSystemUserRoles(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Requests to reset the user's password
         * @param {ResetRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPasswordReset(model?: ResetRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PasswordResetModel> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).requestPasswordReset(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Sets the user's password based on the reset request
         * @param {CreateNewPasswordRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPassword(model?: CreateNewPasswordRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).setPassword(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {UpdateUserRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDetails(model?: UpdateUserRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).updateDetails(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileImage(file?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserModel> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).updateProfileImage(file, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Changes the current user's password
         * @param {ChangePasswordRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePassword(model?: ChangePasswordRequest, options?: any) {
            return UserApiFp(configuration).changePassword(model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create an api-only user, mainly for integration use
         * @param {NewApiUserRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiUser(model?: NewApiUserRequest, options?: any) {
            return UserApiFp(configuration).createApiUser(model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates the user.
         * @param {NewUserRequest} [model] Model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(model?: NewUserRequest, options?: any) {
            return UserApiFp(configuration).createUser(model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the current user's info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserData(options?: any) {
            return UserApiFp(configuration).getCurrentUserData(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the current user's terms agreement info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserTermsAgreement(options?: any) {
            return UserApiFp(configuration).getCurrentUserTermsAgreement(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Checks if sso is available for this user's email.
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSingleSignOnAvailability(email: string, options?: any) {
            return UserApiFp(configuration).getSingleSignOnAvailability(email, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemUserRoles(options?: any) {
            return UserApiFp(configuration).getSystemUserRoles(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Requests to reset the user's password
         * @param {ResetRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPasswordReset(model?: ResetRequest, options?: any) {
            return UserApiFp(configuration).requestPasswordReset(model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Sets the user's password based on the reset request
         * @param {CreateNewPasswordRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPassword(model?: CreateNewPasswordRequest, options?: any) {
            return UserApiFp(configuration).setPassword(model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {UpdateUserRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDetails(model?: UpdateUserRequest, options?: any) {
            return UserApiFp(configuration).updateDetails(model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {any} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileImage(file?: any, options?: any) {
            return UserApiFp(configuration).updateProfileImage(file, options)(fetch, basePath);
        },
    };
};

/**
 * UserApi - interface
 * @export
 * @interface UserApi
 */
export interface UserApiInterface {
    /**
     * 
     * @summary Changes the current user's password
     * @param {ChangePasswordRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    changePassword(model?: ChangePasswordRequest, options?: any): Promise<{}>;

    /**
     * 
     * @summary Create an api-only user, mainly for integration use
     * @param {NewApiUserRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    createApiUser(model?: NewApiUserRequest, options?: any): Promise<ApiUserModel>;

    /**
     * 
     * @summary Creates the user.
     * @param {NewUserRequest} [model] Model.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    createUser(model?: NewUserRequest, options?: any): Promise<UserModel>;

    /**
     * 
     * @summary Gets the current user's info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getCurrentUserData(options?: any): Promise<UserModel>;

    /**
     * 
     * @summary Gets the current user's terms agreement info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getCurrentUserTermsAgreement(options?: any): Promise<UserTermAgreementModel>;

    /**
     * 
     * @summary Checks if sso is available for this user's email.
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getSingleSignOnAvailability(email: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getSystemUserRoles(options?: any): Promise<Array<UserRoleModel>>;

    /**
     * 
     * @summary Requests to reset the user's password
     * @param {ResetRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    requestPasswordReset(model?: ResetRequest, options?: any): Promise<PasswordResetModel>;

    /**
     * 
     * @summary Sets the user's password based on the reset request
     * @param {CreateNewPasswordRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    setPassword(model?: CreateNewPasswordRequest, options?: any): Promise<{}>;

    /**
     * 
     * @param {UpdateUserRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    updateDetails(model?: UpdateUserRequest, options?: any): Promise<{}>;

    /**
     * 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    updateProfileImage(file?: any, options?: any): Promise<UserModel>;

}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI implements UserApiInterface {
    /**
     * 
     * @summary Changes the current user's password
     * @param {ChangePasswordRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public changePassword(model?: ChangePasswordRequest, options?: any) {
        return UserApiFp(this.configuration).changePassword(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create an api-only user, mainly for integration use
     * @param {NewApiUserRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createApiUser(model?: NewApiUserRequest, options?: any) {
        return UserApiFp(this.configuration).createApiUser(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates the user.
     * @param {NewUserRequest} [model] Model.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUser(model?: NewUserRequest, options?: any) {
        return UserApiFp(this.configuration).createUser(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the current user's info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getCurrentUserData(options?: any) {
        return UserApiFp(this.configuration).getCurrentUserData(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the current user's terms agreement info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getCurrentUserTermsAgreement(options?: any) {
        return UserApiFp(this.configuration).getCurrentUserTermsAgreement(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Checks if sso is available for this user's email.
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getSingleSignOnAvailability(email: string, options?: any) {
        return UserApiFp(this.configuration).getSingleSignOnAvailability(email, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getSystemUserRoles(options?: any) {
        return UserApiFp(this.configuration).getSystemUserRoles(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Requests to reset the user's password
     * @param {ResetRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public requestPasswordReset(model?: ResetRequest, options?: any) {
        return UserApiFp(this.configuration).requestPasswordReset(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Sets the user's password based on the reset request
     * @param {CreateNewPasswordRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public setPassword(model?: CreateNewPasswordRequest, options?: any) {
        return UserApiFp(this.configuration).setPassword(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {UpdateUserRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateDetails(model?: UpdateUserRequest, options?: any) {
        return UserApiFp(this.configuration).updateDetails(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {any} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateProfileImage(file?: any, options?: any) {
        return UserApiFp(this.configuration).updateProfileImage(file, options)(this.fetch, this.basePath);
    }

}

/**
 * VoicifyNotificationApi - fetch parameter creator
 * @export
 */
export const VoicifyNotificationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadNotifications(options: any = {}): FetchArgs {
            const localVarPath = `/api/VoicifyNotification/unread`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotifications(options: any = {}): FetchArgs {
            const localVarPath = `/api/VoicifyNotification/all`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAllAsRead(options: any = {}): FetchArgs {
            const localVarPath = `/api/VoicifyNotification/read`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsRead(notificationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'notificationId' is not null or undefined
            if (notificationId === null || notificationId === undefined) {
                throw new RequiredError('notificationId','Required parameter notificationId was null or undefined when calling markAsRead.');
            }
            const localVarPath = `/api/VoicifyNotification/{notificationId}/read`
                .replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VoicifyNotificationApi - functional programming interface
 * @export
 */
export const VoicifyNotificationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadNotifications(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserVoicifyNotificationModel>> {
            const localVarFetchArgs = VoicifyNotificationApiFetchParamCreator(configuration).getUnreadNotifications(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotifications(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserVoicifyNotificationModel>> {
            const localVarFetchArgs = VoicifyNotificationApiFetchParamCreator(configuration).getUserNotifications(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAllAsRead(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<UserVoicifyNotificationModel>> {
            const localVarFetchArgs = VoicifyNotificationApiFetchParamCreator(configuration).markAllAsRead(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsRead(notificationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserVoicifyNotificationModel> {
            const localVarFetchArgs = VoicifyNotificationApiFetchParamCreator(configuration).markAsRead(notificationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VoicifyNotificationApi - factory interface
 * @export
 */
export const VoicifyNotificationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnreadNotifications(options?: any) {
            return VoicifyNotificationApiFp(configuration).getUnreadNotifications(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserNotifications(options?: any) {
            return VoicifyNotificationApiFp(configuration).getUserNotifications(options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAllAsRead(options?: any) {
            return VoicifyNotificationApiFp(configuration).markAllAsRead(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} notificationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsRead(notificationId: string, options?: any) {
            return VoicifyNotificationApiFp(configuration).markAsRead(notificationId, options)(fetch, basePath);
        },
    };
};

/**
 * VoicifyNotificationApi - interface
 * @export
 * @interface VoicifyNotificationApi
 */
export interface VoicifyNotificationApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoicifyNotificationApiInterface
     */
    getUnreadNotifications(options?: any): Promise<Array<UserVoicifyNotificationModel>>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoicifyNotificationApiInterface
     */
    getUserNotifications(options?: any): Promise<Array<UserVoicifyNotificationModel>>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoicifyNotificationApiInterface
     */
    markAllAsRead(options?: any): Promise<Array<UserVoicifyNotificationModel>>;

    /**
     * 
     * @param {string} notificationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoicifyNotificationApiInterface
     */
    markAsRead(notificationId: string, options?: any): Promise<UserVoicifyNotificationModel>;

}

/**
 * VoicifyNotificationApi - object-oriented interface
 * @export
 * @class VoicifyNotificationApi
 * @extends {BaseAPI}
 */
export class VoicifyNotificationApi extends BaseAPI implements VoicifyNotificationApiInterface {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoicifyNotificationApi
     */
    public getUnreadNotifications(options?: any) {
        return VoicifyNotificationApiFp(this.configuration).getUnreadNotifications(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoicifyNotificationApi
     */
    public getUserNotifications(options?: any) {
        return VoicifyNotificationApiFp(this.configuration).getUserNotifications(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoicifyNotificationApi
     */
    public markAllAsRead(options?: any) {
        return VoicifyNotificationApiFp(this.configuration).markAllAsRead(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} notificationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoicifyNotificationApi
     */
    public markAsRead(notificationId: string, options?: any) {
        return VoicifyNotificationApiFp(this.configuration).markAsRead(notificationId, options)(this.fetch, this.basePath);
    }

}

/**
 * WebhookApi - fetch parameter creator
 * @export
 */
export const WebhookApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} webhookId 
         * @param {NewWebhookParameterRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhookParameter(webhookId: string, model?: NewWebhookParameterRequest, options: any = {}): FetchArgs {
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId','Required parameter webhookId was null or undefined when calling addWebhookParameter.');
            }
            const localVarPath = `/api/Webhook/{webhookId}/parameter`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewWebhookParameterRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {NewWebhookRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(organizationId: string, model?: NewWebhookRequest, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling createWebhook.');
            }
            const localVarPath = `/api/Webhook/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewWebhookRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationWebhooks(organizationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'organizationId' is not null or undefined
            if (organizationId === null || organizationId === undefined) {
                throw new RequiredError('organizationId','Required parameter organizationId was null or undefined when calling getOrganizationWebhooks.');
            }
            const localVarPath = `/api/Webhook/fromOrganization/{organizationId}`
                .replace(`{${"organizationId"}}`, encodeURIComponent(String(organizationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookTypes(options: any = {}): FetchArgs {
            const localVarPath = `/api/Webhook/types`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(webhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId','Required parameter webhookId was null or undefined when calling removeWebhook.');
            }
            const localVarPath = `/api/Webhook/{webhookId}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {UpdateWebhookRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhookId: string, model?: UpdateWebhookRequest, options: any = {}): FetchArgs {
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId','Required parameter webhookId was null or undefined when calling updateWebhook.');
            }
            const localVarPath = `/api/Webhook/{webhookId}`
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateWebhookRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebhookApi - functional programming interface
 * @export
 */
export const WebhookApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} webhookId 
         * @param {NewWebhookParameterRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhookParameter(webhookId: string, model?: NewWebhookParameterRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).addWebhookParameter(webhookId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {NewWebhookRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(organizationId: string, model?: NewWebhookRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookModel> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).createWebhook(organizationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationWebhooks(organizationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<WebhookModel>> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).getOrganizationWebhooks(organizationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookTypes(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<WebhookTypeModel>> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).getWebhookTypes(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(webhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).removeWebhook(webhookId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {UpdateWebhookRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhookId: string, model?: UpdateWebhookRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WebhookModel> {
            const localVarFetchArgs = WebhookApiFetchParamCreator(configuration).updateWebhook(webhookId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WebhookApi - factory interface
 * @export
 */
export const WebhookApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @param {string} webhookId 
         * @param {NewWebhookParameterRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhookParameter(webhookId: string, model?: NewWebhookParameterRequest, options?: any) {
            return WebhookApiFp(configuration).addWebhookParameter(webhookId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {NewWebhookRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWebhook(organizationId: string, model?: NewWebhookRequest, options?: any) {
            return WebhookApiFp(configuration).createWebhook(organizationId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} organizationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrganizationWebhooks(organizationId: string, options?: any) {
            return WebhookApiFp(configuration).getOrganizationWebhooks(organizationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhookTypes(options?: any) {
            return WebhookApiFp(configuration).getWebhookTypes(options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(webhookId: string, options?: any) {
            return WebhookApiFp(configuration).removeWebhook(webhookId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} webhookId 
         * @param {UpdateWebhookRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhook(webhookId: string, model?: UpdateWebhookRequest, options?: any) {
            return WebhookApiFp(configuration).updateWebhook(webhookId, model, options)(fetch, basePath);
        },
    };
};

/**
 * WebhookApi - interface
 * @export
 * @interface WebhookApi
 */
export interface WebhookApiInterface {
    /**
     * 
     * @param {string} webhookId 
     * @param {NewWebhookParameterRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    addWebhookParameter(webhookId: string, model?: NewWebhookParameterRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} organizationId 
     * @param {NewWebhookRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    createWebhook(organizationId: string, model?: NewWebhookRequest, options?: any): Promise<WebhookModel>;

    /**
     * 
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    getOrganizationWebhooks(organizationId: string, options?: any): Promise<Array<WebhookModel>>;

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    getWebhookTypes(options?: any): Promise<Array<WebhookTypeModel>>;

    /**
     * 
     * @param {string} webhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    removeWebhook(webhookId: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} webhookId 
     * @param {UpdateWebhookRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApiInterface
     */
    updateWebhook(webhookId: string, model?: UpdateWebhookRequest, options?: any): Promise<WebhookModel>;

}

/**
 * WebhookApi - object-oriented interface
 * @export
 * @class WebhookApi
 * @extends {BaseAPI}
 */
export class WebhookApi extends BaseAPI implements WebhookApiInterface {
    /**
     * 
     * @param {string} webhookId 
     * @param {NewWebhookParameterRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public addWebhookParameter(webhookId: string, model?: NewWebhookParameterRequest, options?: any) {
        return WebhookApiFp(this.configuration).addWebhookParameter(webhookId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} organizationId 
     * @param {NewWebhookRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public createWebhook(organizationId: string, model?: NewWebhookRequest, options?: any) {
        return WebhookApiFp(this.configuration).createWebhook(organizationId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} organizationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public getOrganizationWebhooks(organizationId: string, options?: any) {
        return WebhookApiFp(this.configuration).getOrganizationWebhooks(organizationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public getWebhookTypes(options?: any) {
        return WebhookApiFp(this.configuration).getWebhookTypes(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} webhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public removeWebhook(webhookId: string, options?: any) {
        return WebhookApiFp(this.configuration).removeWebhook(webhookId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} webhookId 
     * @param {UpdateWebhookRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebhookApi
     */
    public updateWebhook(webhookId: string, model?: UpdateWebhookRequest, options?: any) {
        return WebhookApiFp(this.configuration).updateWebhook(webhookId, model, options)(this.fetch, this.basePath);
    }

}

/**
 * WelcomeMessageApi - fetch parameter creator
 * @export
 */
export const WelcomeMessageApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds an audio file to the welcome message
         * @param {string} welcomeMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFileImage(welcomeMessageId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'welcomeMessageId' is not null or undefined
            if (welcomeMessageId === null || welcomeMessageId === undefined) {
                throw new RequiredError('welcomeMessageId','Required parameter welcomeMessageId was null or undefined when calling addAudioFileImage.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addAudioFileImage.');
            }
            const localVarPath = `/api/WelcomeMessage/{welcomeMessageId}/addAudioFile/{mediaItemId}`
                .replace(`{${"welcomeMessageId"}}`, encodeURIComponent(String(welcomeMessageId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a large image to the welcome message
         * @param {string} welcomeMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(welcomeMessageId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'welcomeMessageId' is not null or undefined
            if (welcomeMessageId === null || welcomeMessageId === undefined) {
                throw new RequiredError('welcomeMessageId','Required parameter welcomeMessageId was null or undefined when calling addLargeImage.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addLargeImage.');
            }
            const localVarPath = `/api/WelcomeMessage/{welcomeMessageId}/addLargeImage/{mediaItemId}`
                .replace(`{${"welcomeMessageId"}}`, encodeURIComponent(String(welcomeMessageId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a small image to the welcome message
         * @param {string} welcomeMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(welcomeMessageId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'welcomeMessageId' is not null or undefined
            if (welcomeMessageId === null || welcomeMessageId === undefined) {
                throw new RequiredError('welcomeMessageId','Required parameter welcomeMessageId was null or undefined when calling addSmallImage.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addSmallImage.');
            }
            const localVarPath = `/api/WelcomeMessage/{welcomeMessageId}/addSmallImage/{mediaItemId}`
                .replace(`{${"welcomeMessageId"}}`, encodeURIComponent(String(welcomeMessageId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a video file to the welcome message
         * @param {string} welcomeMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(welcomeMessageId: string, mediaItemId: string, options: any = {}): FetchArgs {
            // verify required parameter 'welcomeMessageId' is not null or undefined
            if (welcomeMessageId === null || welcomeMessageId === undefined) {
                throw new RequiredError('welcomeMessageId','Required parameter welcomeMessageId was null or undefined when calling addVideoFile.');
            }
            // verify required parameter 'mediaItemId' is not null or undefined
            if (mediaItemId === null || mediaItemId === undefined) {
                throw new RequiredError('mediaItemId','Required parameter mediaItemId was null or undefined when calling addVideoFile.');
            }
            const localVarPath = `/api/WelcomeMessage/{welcomeMessageId}/addVideoFile/{mediaItemId}`
                .replace(`{${"welcomeMessageId"}}`, encodeURIComponent(String(welcomeMessageId)))
                .replace(`{${"mediaItemId"}}`, encodeURIComponent(String(mediaItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} welcomeMessageId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(welcomeMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'welcomeMessageId' is not null or undefined
            if (welcomeMessageId === null || welcomeMessageId === undefined) {
                throw new RequiredError('welcomeMessageId','Required parameter welcomeMessageId was null or undefined when calling addWebhook.');
            }
            // verify required parameter 'webhookId' is not null or undefined
            if (webhookId === null || webhookId === undefined) {
                throw new RequiredError('webhookId','Required parameter webhookId was null or undefined when calling addWebhook.');
            }
            const localVarPath = `/api/WelcomeMessage/{welcomeMessageId}/webhooks/{webhookId}`
                .replace(`{${"welcomeMessageId"}}`, encodeURIComponent(String(welcomeMessageId)))
                .replace(`{${"webhookId"}}`, encodeURIComponent(String(webhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a new welcome message to the given application
         * @param {string} applicationId 
         * @param {NewWelcomeMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWelcomeMessage(applicationId: string, model?: NewWelcomeMessageRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling addWelcomeMessage.');
            }
            const localVarPath = `/api/WelcomeMessage/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewWelcomeMessageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a new welcome message to the given application
         * @param {string} applicationId 
         * @param {NewWelcomeMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWelcomeMessageStub(applicationId: string, model?: NewWelcomeMessageStubRequest, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling addWelcomeMessageStub.');
            }
            const localVarPath = `/api/WelcomeMessage/{applicationId}/stub`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NewWelcomeMessageStubRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} welcomeMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(welcomeMessageId: string, options: any = {}): FetchArgs {
            // verify required parameter 'welcomeMessageId' is not null or undefined
            if (welcomeMessageId === null || welcomeMessageId === undefined) {
                throw new RequiredError('welcomeMessageId','Required parameter welcomeMessageId was null or undefined when calling copyContentItem.');
            }
            const localVarPath = `/api/WelcomeMessage/{welcomeMessageId}/copy`
                .replace(`{${"welcomeMessageId"}}`, encodeURIComponent(String(welcomeMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {WelcomeMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: WelcomeMessageModel, options: any = {}): FetchArgs {
            const localVarPath = `/api/WelcomeMessage/full`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WelcomeMessageModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling createUserDefinedParameter.');
            }
            const localVarPath = `/api/WelcomeMessage/webhook/{instanceWebhookId}/userParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDefinedWebhookParameterCreateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes the given message
         * @param {string} welcomeMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWelcomeMessage(welcomeMessageId: string, options: any = {}): FetchArgs {
            // verify required parameter 'welcomeMessageId' is not null or undefined
            if (welcomeMessageId === null || welcomeMessageId === undefined) {
                throw new RequiredError('welcomeMessageId','Required parameter welcomeMessageId was null or undefined when calling deleteWelcomeMessage.');
            }
            const localVarPath = `/api/WelcomeMessage/{welcomeMessageId}`
                .replace(`{${"welcomeMessageId"}}`, encodeURIComponent(String(welcomeMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling findFullById.');
            }
            const localVarPath = `/api/WelcomeMessage/full/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling getByApplicationFeature.');
            }
            const localVarPath = `/api/WelcomeMessage/byFeature/{applicationFeatureId}`
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} welcomeMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(welcomeMessageId: string, options: any = {}): FetchArgs {
            // verify required parameter 'welcomeMessageId' is not null or undefined
            if (welcomeMessageId === null || welcomeMessageId === undefined) {
                throw new RequiredError('welcomeMessageId','Required parameter welcomeMessageId was null or undefined when calling getWebhooks.');
            }
            const localVarPath = `/api/WelcomeMessage/{welcomeMessageId}/webhooks`
                .replace(`{${"welcomeMessageId"}}`, encodeURIComponent(String(welcomeMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the welcome messages for the given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWelcomeMessagesForApplication(applicationId: string, options: any = {}): FetchArgs {
            // verify required parameter 'applicationId' is not null or undefined
            if (applicationId === null || applicationId === undefined) {
                throw new RequiredError('applicationId','Required parameter applicationId was null or undefined when calling getWelcomeMessagesForApplication.');
            }
            const localVarPath = `/api/WelcomeMessage/{applicationId}`
                .replace(`{${"applicationId"}}`, encodeURIComponent(String(applicationId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options: any = {}): FetchArgs {
            // verify required parameter 'contentItemId' is not null or undefined
            if (contentItemId === null || contentItemId === undefined) {
                throw new RequiredError('contentItemId','Required parameter contentItemId was null or undefined when calling moveContentItemToApplicationFeature.');
            }
            // verify required parameter 'applicationFeatureId' is not null or undefined
            if (applicationFeatureId === null || applicationFeatureId === undefined) {
                throw new RequiredError('applicationFeatureId','Required parameter applicationFeatureId was null or undefined when calling moveContentItemToApplicationFeature.');
            }
            const localVarPath = `/api/WelcomeMessage/{contentItemId}/MoveToFeature/{applicationFeatureId}`
                .replace(`{${"contentItemId"}}`, encodeURIComponent(String(contentItemId)))
                .replace(`{${"applicationFeatureId"}}`, encodeURIComponent(String(applicationFeatureId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling removeUserDefinedParameter.');
            }
            // verify required parameter 'parameterName' is not null or undefined
            if (parameterName === null || parameterName === undefined) {
                throw new RequiredError('parameterName','Required parameter parameterName was null or undefined when calling removeUserDefinedParameter.');
            }
            const localVarPath = `/api/WelcomeMessage/webhook/{instanceWebhookId}/userParameters/{parameterName}`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)))
                .replace(`{${"parameterName"}}`, encodeURIComponent(String(parameterName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} welcomeMessageWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(welcomeMessageWebhookId: string, options: any = {}): FetchArgs {
            // verify required parameter 'welcomeMessageWebhookId' is not null or undefined
            if (welcomeMessageWebhookId === null || welcomeMessageWebhookId === undefined) {
                throw new RequiredError('welcomeMessageWebhookId','Required parameter welcomeMessageWebhookId was null or undefined when calling removeWebhook.');
            }
            const localVarPath = `/api/WelcomeMessage/webhook/{welcomeMessageWebhookId}`
                .replace(`{${"welcomeMessageWebhookId"}}`, encodeURIComponent(String(welcomeMessageWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Toggles whether the given welcome Message is live or not
         * @param {string} welcomeMessageId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleIsLive(welcomeMessageId: string, model?: ToggleLiveRequest, options: any = {}): FetchArgs {
            // verify required parameter 'welcomeMessageId' is not null or undefined
            if (welcomeMessageId === null || welcomeMessageId === undefined) {
                throw new RequiredError('welcomeMessageId','Required parameter welcomeMessageId was null or undefined when calling toggleIsLive.');
            }
            const localVarPath = `/api/WelcomeMessage/{welcomeMessageId}/isLive`
                .replace(`{${"welcomeMessageId"}}`, encodeURIComponent(String(welcomeMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ToggleLiveRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} welcomeMessageId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(welcomeMessageId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options: any = {}): FetchArgs {
            // verify required parameter 'welcomeMessageId' is not null or undefined
            if (welcomeMessageId === null || welcomeMessageId === undefined) {
                throw new RequiredError('welcomeMessageId','Required parameter welcomeMessageId was null or undefined when calling updateAttachedWebhook.');
            }
            // verify required parameter 'webhookInstanceId' is not null or undefined
            if (webhookInstanceId === null || webhookInstanceId === undefined) {
                throw new RequiredError('webhookInstanceId','Required parameter webhookInstanceId was null or undefined when calling updateAttachedWebhook.');
            }
            const localVarPath = `/api/WelcomeMessage/{welcomeMessageId}/webhooks/{webhookInstanceId}`
                .replace(`{${"welcomeMessageId"}}`, encodeURIComponent(String(welcomeMessageId)))
                .replace(`{${"webhookInstanceId"}}`, encodeURIComponent(String(webhookInstanceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParametersRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(parameters || {}) : (parameters || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {WelcomeMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: WelcomeMessageModel, options: any = {}): FetchArgs {
            // verify required parameter 'contentItemId' is not null or undefined
            if (contentItemId === null || contentItemId === undefined) {
                throw new RequiredError('contentItemId','Required parameter contentItemId was null or undefined when calling updateFullContentItem.');
            }
            const localVarPath = `/api/WelcomeMessage/{contentItemId}/full`
                .replace(`{${"contentItemId"}}`, encodeURIComponent(String(contentItemId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WelcomeMessageModel" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateUserDefinedParameter.');
            }
            const localVarPath = `/api/WelcomeMessage/webhook/{instanceWebhookId}/userParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserDefinedWebhookParameterUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'instanceWebhookId' is not null or undefined
            if (instanceWebhookId === null || instanceWebhookId === undefined) {
                throw new RequiredError('instanceWebhookId','Required parameter instanceWebhookId was null or undefined when calling updateWebhookParameter.');
            }
            const localVarPath = `/api/WelcomeMessage/webhook/{instanceWebhookId}/webhookParameters`
                .replace(`{${"instanceWebhookId"}}`, encodeURIComponent(String(instanceWebhookId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WebhookParameterUpdateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(request || {}) : (request || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the content of the given welcome message id
         * @param {string} welcomeMessageId 
         * @param {UpdateWelcomeMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWelcomeMessage(welcomeMessageId: string, model?: UpdateWelcomeMessageRequest, options: any = {}): FetchArgs {
            // verify required parameter 'welcomeMessageId' is not null or undefined
            if (welcomeMessageId === null || welcomeMessageId === undefined) {
                throw new RequiredError('welcomeMessageId','Required parameter welcomeMessageId was null or undefined when calling updateWelcomeMessage.');
            }
            const localVarPath = `/api/WelcomeMessage/{welcomeMessageId}/update`
                .replace(`{${"welcomeMessageId"}}`, encodeURIComponent(String(welcomeMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateWelcomeMessageRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the content of the given welcome message id
         * @param {string} welcomeMessageId 
         * @param {UpdateWelcomeMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWelcomeMessageStub(welcomeMessageId: string, model?: UpdateWelcomeMessageStubRequest, options: any = {}): FetchArgs {
            // verify required parameter 'welcomeMessageId' is not null or undefined
            if (welcomeMessageId === null || welcomeMessageId === undefined) {
                throw new RequiredError('welcomeMessageId','Required parameter welcomeMessageId was null or undefined when calling updateWelcomeMessageStub.');
            }
            const localVarPath = `/api/WelcomeMessage/{welcomeMessageId}/update/stub`
                .replace(`{${"welcomeMessageId"}}`, encodeURIComponent(String(welcomeMessageId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Authorization")
					: configuration.apiKey;
                localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateWelcomeMessageStubRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(model || {}) : (model || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WelcomeMessageApi - functional programming interface
 * @export
 */
export const WelcomeMessageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds an audio file to the welcome message
         * @param {string} welcomeMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFileImage(welcomeMessageId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WelcomeMessageModel> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).addAudioFileImage(welcomeMessageId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a large image to the welcome message
         * @param {string} welcomeMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(welcomeMessageId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WelcomeMessageModel> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).addLargeImage(welcomeMessageId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a small image to the welcome message
         * @param {string} welcomeMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(welcomeMessageId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WelcomeMessageModel> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).addSmallImage(welcomeMessageId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a video file to the welcome message
         * @param {string} welcomeMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(welcomeMessageId: string, mediaItemId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WelcomeMessageModel> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).addVideoFile(welcomeMessageId, mediaItemId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} welcomeMessageId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(welcomeMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WelcomeMessageWebhookModel> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).addWebhook(welcomeMessageId, webhookId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a new welcome message to the given application
         * @param {string} applicationId 
         * @param {NewWelcomeMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWelcomeMessage(applicationId: string, model?: NewWelcomeMessageRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WelcomeMessageModel> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).addWelcomeMessage(applicationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Adds a new welcome message to the given application
         * @param {string} applicationId 
         * @param {NewWelcomeMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWelcomeMessageStub(applicationId: string, model?: NewWelcomeMessageStubRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WelcomeMessageModel> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).addWelcomeMessageStub(applicationId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} welcomeMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(welcomeMessageId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WelcomeMessageModel> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).copyContentItem(welcomeMessageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {WelcomeMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: WelcomeMessageModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WelcomeMessageModel> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).createFullContentItem(model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).createUserDefinedParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes the given message
         * @param {string} welcomeMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWelcomeMessage(welcomeMessageId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WelcomeMessageModel> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).deleteWelcomeMessage(welcomeMessageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WelcomeMessageModel> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).findFullById(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<WelcomeMessageModel>> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).getByApplicationFeature(applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} welcomeMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(welcomeMessageId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<WelcomeMessageWebhookModel>> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).getWebhooks(welcomeMessageId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Gets the welcome messages for the given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWelcomeMessagesForApplication(applicationId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<WelcomeMessageModel>> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).getWelcomeMessagesForApplication(applicationId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WelcomeMessageModel> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} welcomeMessageWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(welcomeMessageWebhookId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WelcomeMessageWebhookModel> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).removeWebhook(welcomeMessageWebhookId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Toggles whether the given welcome Message is live or not
         * @param {string} welcomeMessageId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleIsLive(welcomeMessageId: string, model?: ToggleLiveRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WelcomeMessageModel> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).toggleIsLive(welcomeMessageId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} welcomeMessageId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(welcomeMessageId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WelcomeMessageWebhookModel> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).updateAttachedWebhook(welcomeMessageId, webhookInstanceId, parameters, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {WelcomeMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: WelcomeMessageModel, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WelcomeMessageModel> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).updateFullContentItem(contentItemId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).updateUserDefinedParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<boolean> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).updateWebhookParameter(instanceWebhookId, request, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the content of the given welcome message id
         * @param {string} welcomeMessageId 
         * @param {UpdateWelcomeMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWelcomeMessage(welcomeMessageId: string, model?: UpdateWelcomeMessageRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WelcomeMessageModel> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).updateWelcomeMessage(welcomeMessageId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the content of the given welcome message id
         * @param {string} welcomeMessageId 
         * @param {UpdateWelcomeMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWelcomeMessageStub(welcomeMessageId: string, model?: UpdateWelcomeMessageStubRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<WelcomeMessageModel> {
            const localVarFetchArgs = WelcomeMessageApiFetchParamCreator(configuration).updateWelcomeMessageStub(welcomeMessageId, model, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WelcomeMessageApi - factory interface
 * @export
 */
export const WelcomeMessageApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Adds an audio file to the welcome message
         * @param {string} welcomeMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAudioFileImage(welcomeMessageId: string, mediaItemId: string, options?: any) {
            return WelcomeMessageApiFp(configuration).addAudioFileImage(welcomeMessageId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a large image to the welcome message
         * @param {string} welcomeMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLargeImage(welcomeMessageId: string, mediaItemId: string, options?: any) {
            return WelcomeMessageApiFp(configuration).addLargeImage(welcomeMessageId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a small image to the welcome message
         * @param {string} welcomeMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSmallImage(welcomeMessageId: string, mediaItemId: string, options?: any) {
            return WelcomeMessageApiFp(configuration).addSmallImage(welcomeMessageId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a video file to the welcome message
         * @param {string} welcomeMessageId 
         * @param {string} mediaItemId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVideoFile(welcomeMessageId: string, mediaItemId: string, options?: any) {
            return WelcomeMessageApiFp(configuration).addVideoFile(welcomeMessageId, mediaItemId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} welcomeMessageId 
         * @param {string} webhookId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebhook(welcomeMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
            return WelcomeMessageApiFp(configuration).addWebhook(welcomeMessageId, webhookId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a new welcome message to the given application
         * @param {string} applicationId 
         * @param {NewWelcomeMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWelcomeMessage(applicationId: string, model?: NewWelcomeMessageRequest, options?: any) {
            return WelcomeMessageApiFp(configuration).addWelcomeMessage(applicationId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Adds a new welcome message to the given application
         * @param {string} applicationId 
         * @param {NewWelcomeMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWelcomeMessageStub(applicationId: string, model?: NewWelcomeMessageStubRequest, options?: any) {
            return WelcomeMessageApiFp(configuration).addWelcomeMessageStub(applicationId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Copies the content item in the same application and feature
         * @param {string} welcomeMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyContentItem(welcomeMessageId: string, options?: any) {
            return WelcomeMessageApiFp(configuration).copyContentItem(welcomeMessageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates a new content item entity from a dto
         * @param {WelcomeMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFullContentItem(model?: WelcomeMessageModel, options?: any) {
            return WelcomeMessageApiFp(configuration).createFullContentItem(model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterCreateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any) {
            return WelcomeMessageApiFp(configuration).createUserDefinedParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes the given message
         * @param {string} welcomeMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWelcomeMessage(welcomeMessageId: string, options?: any) {
            return WelcomeMessageApiFp(configuration).deleteWelcomeMessage(welcomeMessageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Finds the full content item by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFullById(id: string, options?: any) {
            return WelcomeMessageApiFp(configuration).findFullById(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the content for the given application feature
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByApplicationFeature(applicationFeatureId: string, options?: any) {
            return WelcomeMessageApiFp(configuration).getByApplicationFeature(applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} welcomeMessageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebhooks(welcomeMessageId: string, options?: any) {
            return WelcomeMessageApiFp(configuration).getWebhooks(welcomeMessageId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Gets the welcome messages for the given application
         * @param {string} applicationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWelcomeMessagesForApplication(applicationId: string, options?: any) {
            return WelcomeMessageApiFp(configuration).getWelcomeMessagesForApplication(applicationId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} contentItemId 
         * @param {string} applicationFeatureId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any) {
            return WelcomeMessageApiFp(configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {string} parameterName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any) {
            return WelcomeMessageApiFp(configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} welcomeMessageWebhookId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeWebhook(welcomeMessageWebhookId: string, options?: any) {
            return WelcomeMessageApiFp(configuration).removeWebhook(welcomeMessageWebhookId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Toggles whether the given welcome Message is live or not
         * @param {string} welcomeMessageId 
         * @param {ToggleLiveRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleIsLive(welcomeMessageId: string, model?: ToggleLiveRequest, options?: any) {
            return WelcomeMessageApiFp(configuration).toggleIsLive(welcomeMessageId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} welcomeMessageId 
         * @param {string} webhookInstanceId 
         * @param {WebhookParametersRequest} [parameters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAttachedWebhook(welcomeMessageId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any) {
            return WelcomeMessageApiFp(configuration).updateAttachedWebhook(welcomeMessageId, webhookInstanceId, parameters, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the content item from a specified dto
         * @param {string} contentItemId 
         * @param {WelcomeMessageModel} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFullContentItem(contentItemId: string, model?: WelcomeMessageModel, options?: any) {
            return WelcomeMessageApiFp(configuration).updateFullContentItem(contentItemId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any) {
            return WelcomeMessageApiFp(configuration).updateUserDefinedParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @param {string} instanceWebhookId 
         * @param {WebhookParameterUpdateRequest} [request] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any) {
            return WelcomeMessageApiFp(configuration).updateWebhookParameter(instanceWebhookId, request, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the content of the given welcome message id
         * @param {string} welcomeMessageId 
         * @param {UpdateWelcomeMessageRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWelcomeMessage(welcomeMessageId: string, model?: UpdateWelcomeMessageRequest, options?: any) {
            return WelcomeMessageApiFp(configuration).updateWelcomeMessage(welcomeMessageId, model, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the content of the given welcome message id
         * @param {string} welcomeMessageId 
         * @param {UpdateWelcomeMessageStubRequest} [model] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWelcomeMessageStub(welcomeMessageId: string, model?: UpdateWelcomeMessageStubRequest, options?: any) {
            return WelcomeMessageApiFp(configuration).updateWelcomeMessageStub(welcomeMessageId, model, options)(fetch, basePath);
        },
    };
};

/**
 * WelcomeMessageApi - interface
 * @export
 * @interface WelcomeMessageApi
 */
export interface WelcomeMessageApiInterface {
    /**
     * 
     * @summary Adds an audio file to the welcome message
     * @param {string} welcomeMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    addAudioFileImage(welcomeMessageId: string, mediaItemId: string, options?: any): Promise<WelcomeMessageModel>;

    /**
     * 
     * @summary Adds a large image to the welcome message
     * @param {string} welcomeMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    addLargeImage(welcomeMessageId: string, mediaItemId: string, options?: any): Promise<WelcomeMessageModel>;

    /**
     * 
     * @summary Adds a small image to the welcome message
     * @param {string} welcomeMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    addSmallImage(welcomeMessageId: string, mediaItemId: string, options?: any): Promise<WelcomeMessageModel>;

    /**
     * 
     * @summary Adds a video file to the welcome message
     * @param {string} welcomeMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    addVideoFile(welcomeMessageId: string, mediaItemId: string, options?: any): Promise<WelcomeMessageModel>;

    /**
     * 
     * @param {string} welcomeMessageId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    addWebhook(welcomeMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any): Promise<WelcomeMessageWebhookModel>;

    /**
     * 
     * @summary Adds a new welcome message to the given application
     * @param {string} applicationId 
     * @param {NewWelcomeMessageRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    addWelcomeMessage(applicationId: string, model?: NewWelcomeMessageRequest, options?: any): Promise<WelcomeMessageModel>;

    /**
     * 
     * @summary Adds a new welcome message to the given application
     * @param {string} applicationId 
     * @param {NewWelcomeMessageStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    addWelcomeMessageStub(applicationId: string, model?: NewWelcomeMessageStubRequest, options?: any): Promise<WelcomeMessageModel>;

    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param {string} welcomeMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    copyContentItem(welcomeMessageId: string, options?: any): Promise<WelcomeMessageModel>;

    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param {WelcomeMessageModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    createFullContentItem(model?: WelcomeMessageModel, options?: any): Promise<WelcomeMessageModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterCreateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @summary Deletes the given message
     * @param {string} welcomeMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    deleteWelcomeMessage(welcomeMessageId: string, options?: any): Promise<WelcomeMessageModel>;

    /**
     * 
     * @summary Finds the full content item by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    findFullById(id: string, options?: any): Promise<WelcomeMessageModel>;

    /**
     * 
     * @summary Gets the content for the given application feature
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    getByApplicationFeature(applicationFeatureId: string, options?: any): Promise<Array<WelcomeMessageModel>>;

    /**
     * 
     * @param {string} welcomeMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    getWebhooks(welcomeMessageId: string, options?: any): Promise<Array<WelcomeMessageWebhookModel>>;

    /**
     * 
     * @summary Gets the welcome messages for the given application
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    getWelcomeMessagesForApplication(applicationId: string, options?: any): Promise<Array<WelcomeMessageModel>>;

    /**
     * 
     * @param {string} contentItemId 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any): Promise<WelcomeMessageModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {string} parameterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} welcomeMessageWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    removeWebhook(welcomeMessageWebhookId: string, options?: any): Promise<WelcomeMessageWebhookModel>;

    /**
     * 
     * @summary Toggles whether the given welcome Message is live or not
     * @param {string} welcomeMessageId 
     * @param {ToggleLiveRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    toggleIsLive(welcomeMessageId: string, model?: ToggleLiveRequest, options?: any): Promise<WelcomeMessageModel>;

    /**
     * 
     * @param {string} welcomeMessageId 
     * @param {string} webhookInstanceId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    updateAttachedWebhook(welcomeMessageId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any): Promise<WelcomeMessageWebhookModel>;

    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param {string} contentItemId 
     * @param {WelcomeMessageModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    updateFullContentItem(contentItemId: string, model?: WelcomeMessageModel, options?: any): Promise<WelcomeMessageModel>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {WebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any): Promise<boolean>;

    /**
     * 
     * @summary Updates the content of the given welcome message id
     * @param {string} welcomeMessageId 
     * @param {UpdateWelcomeMessageRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    updateWelcomeMessage(welcomeMessageId: string, model?: UpdateWelcomeMessageRequest, options?: any): Promise<WelcomeMessageModel>;

    /**
     * 
     * @summary Updates the content of the given welcome message id
     * @param {string} welcomeMessageId 
     * @param {UpdateWelcomeMessageStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApiInterface
     */
    updateWelcomeMessageStub(welcomeMessageId: string, model?: UpdateWelcomeMessageStubRequest, options?: any): Promise<WelcomeMessageModel>;

}

/**
 * WelcomeMessageApi - object-oriented interface
 * @export
 * @class WelcomeMessageApi
 * @extends {BaseAPI}
 */
export class WelcomeMessageApi extends BaseAPI implements WelcomeMessageApiInterface {
    /**
     * 
     * @summary Adds an audio file to the welcome message
     * @param {string} welcomeMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public addAudioFileImage(welcomeMessageId: string, mediaItemId: string, options?: any) {
        return WelcomeMessageApiFp(this.configuration).addAudioFileImage(welcomeMessageId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a large image to the welcome message
     * @param {string} welcomeMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public addLargeImage(welcomeMessageId: string, mediaItemId: string, options?: any) {
        return WelcomeMessageApiFp(this.configuration).addLargeImage(welcomeMessageId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a small image to the welcome message
     * @param {string} welcomeMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public addSmallImage(welcomeMessageId: string, mediaItemId: string, options?: any) {
        return WelcomeMessageApiFp(this.configuration).addSmallImage(welcomeMessageId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a video file to the welcome message
     * @param {string} welcomeMessageId 
     * @param {string} mediaItemId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public addVideoFile(welcomeMessageId: string, mediaItemId: string, options?: any) {
        return WelcomeMessageApiFp(this.configuration).addVideoFile(welcomeMessageId, mediaItemId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} welcomeMessageId 
     * @param {string} webhookId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public addWebhook(welcomeMessageId: string, webhookId: string, parameters?: WebhookParametersRequest, options?: any) {
        return WelcomeMessageApiFp(this.configuration).addWebhook(welcomeMessageId, webhookId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a new welcome message to the given application
     * @param {string} applicationId 
     * @param {NewWelcomeMessageRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public addWelcomeMessage(applicationId: string, model?: NewWelcomeMessageRequest, options?: any) {
        return WelcomeMessageApiFp(this.configuration).addWelcomeMessage(applicationId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Adds a new welcome message to the given application
     * @param {string} applicationId 
     * @param {NewWelcomeMessageStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public addWelcomeMessageStub(applicationId: string, model?: NewWelcomeMessageStubRequest, options?: any) {
        return WelcomeMessageApiFp(this.configuration).addWelcomeMessageStub(applicationId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Copies the content item in the same application and feature
     * @param {string} welcomeMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public copyContentItem(welcomeMessageId: string, options?: any) {
        return WelcomeMessageApiFp(this.configuration).copyContentItem(welcomeMessageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Creates a new content item entity from a dto
     * @param {WelcomeMessageModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public createFullContentItem(model?: WelcomeMessageModel, options?: any) {
        return WelcomeMessageApiFp(this.configuration).createFullContentItem(model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterCreateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public createUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterCreateRequest, options?: any) {
        return WelcomeMessageApiFp(this.configuration).createUserDefinedParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes the given message
     * @param {string} welcomeMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public deleteWelcomeMessage(welcomeMessageId: string, options?: any) {
        return WelcomeMessageApiFp(this.configuration).deleteWelcomeMessage(welcomeMessageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Finds the full content item by id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public findFullById(id: string, options?: any) {
        return WelcomeMessageApiFp(this.configuration).findFullById(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the content for the given application feature
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public getByApplicationFeature(applicationFeatureId: string, options?: any) {
        return WelcomeMessageApiFp(this.configuration).getByApplicationFeature(applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} welcomeMessageId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public getWebhooks(welcomeMessageId: string, options?: any) {
        return WelcomeMessageApiFp(this.configuration).getWebhooks(welcomeMessageId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Gets the welcome messages for the given application
     * @param {string} applicationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public getWelcomeMessagesForApplication(applicationId: string, options?: any) {
        return WelcomeMessageApiFp(this.configuration).getWelcomeMessagesForApplication(applicationId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} contentItemId 
     * @param {string} applicationFeatureId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public moveContentItemToApplicationFeature(contentItemId: string, applicationFeatureId: string, options?: any) {
        return WelcomeMessageApiFp(this.configuration).moveContentItemToApplicationFeature(contentItemId, applicationFeatureId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {string} parameterName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public removeUserDefinedParameter(instanceWebhookId: string, parameterName: string, options?: any) {
        return WelcomeMessageApiFp(this.configuration).removeUserDefinedParameter(instanceWebhookId, parameterName, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} welcomeMessageWebhookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public removeWebhook(welcomeMessageWebhookId: string, options?: any) {
        return WelcomeMessageApiFp(this.configuration).removeWebhook(welcomeMessageWebhookId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Toggles whether the given welcome Message is live or not
     * @param {string} welcomeMessageId 
     * @param {ToggleLiveRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public toggleIsLive(welcomeMessageId: string, model?: ToggleLiveRequest, options?: any) {
        return WelcomeMessageApiFp(this.configuration).toggleIsLive(welcomeMessageId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} welcomeMessageId 
     * @param {string} webhookInstanceId 
     * @param {WebhookParametersRequest} [parameters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public updateAttachedWebhook(welcomeMessageId: string, webhookInstanceId: string, parameters?: WebhookParametersRequest, options?: any) {
        return WelcomeMessageApiFp(this.configuration).updateAttachedWebhook(welcomeMessageId, webhookInstanceId, parameters, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the content item from a specified dto
     * @param {string} contentItemId 
     * @param {WelcomeMessageModel} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public updateFullContentItem(contentItemId: string, model?: WelcomeMessageModel, options?: any) {
        return WelcomeMessageApiFp(this.configuration).updateFullContentItem(contentItemId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {UserDefinedWebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public updateUserDefinedParameter(instanceWebhookId: string, request?: UserDefinedWebhookParameterUpdateRequest, options?: any) {
        return WelcomeMessageApiFp(this.configuration).updateUserDefinedParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @param {string} instanceWebhookId 
     * @param {WebhookParameterUpdateRequest} [request] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public updateWebhookParameter(instanceWebhookId: string, request?: WebhookParameterUpdateRequest, options?: any) {
        return WelcomeMessageApiFp(this.configuration).updateWebhookParameter(instanceWebhookId, request, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the content of the given welcome message id
     * @param {string} welcomeMessageId 
     * @param {UpdateWelcomeMessageRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public updateWelcomeMessage(welcomeMessageId: string, model?: UpdateWelcomeMessageRequest, options?: any) {
        return WelcomeMessageApiFp(this.configuration).updateWelcomeMessage(welcomeMessageId, model, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the content of the given welcome message id
     * @param {string} welcomeMessageId 
     * @param {UpdateWelcomeMessageStubRequest} [model] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WelcomeMessageApi
     */
    public updateWelcomeMessageStub(welcomeMessageId: string, model?: UpdateWelcomeMessageStubRequest, options?: any) {
        return WelcomeMessageApiFp(this.configuration).updateWelcomeMessageStub(welcomeMessageId, model, options)(this.fetch, this.basePath);
    }

}

